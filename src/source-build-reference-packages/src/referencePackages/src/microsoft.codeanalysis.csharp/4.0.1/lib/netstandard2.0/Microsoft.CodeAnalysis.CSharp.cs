// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------

using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security;

[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: ReferenceAssembly]
[assembly: AssemblyTitle("Microsoft.CodeAnalysis.CSharp")]
[assembly: AssemblyDescription("Microsoft.CodeAnalysis.CSharp")]
[assembly: AssemblyDefaultAlias("Microsoft.CodeAnalysis.CSharp")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft® .NET Framework")]
[assembly: AssemblyCopyright("© Microsoft Corporation.  All rights reserved.")]
[assembly: AssemblyFileVersion("4.0.121.55815")]
[assembly: AssemblyInformationalVersion("4.0.121.55815 built by: SOURCEBUILD")]
[assembly: CLSCompliant(false)]
[assembly: AssemblyMetadata("", "")]
[assembly: AssemblyVersion("4.0.0.0")]




namespace Microsoft.CodeAnalysis
{
    public static partial class CSharpExtensions
    {
        public static bool Any(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool Any(this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool Any<TNode>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool Any<TNode>(this Microsoft.CodeAnalysis.SyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static int IndexOf(this Microsoft.CodeAnalysis.SyntaxTokenList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static int IndexOf(this Microsoft.CodeAnalysis.SyntaxTriviaList list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static int IndexOf<TNode>(this Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static int IndexOf<TNode>(this Microsoft.CodeAnalysis.SyntaxList<TNode> list, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxNode? node, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsKind(this Microsoft.CodeAnalysis.SyntaxTrivia trivia, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
    }
}
namespace Microsoft.CodeAnalysis.CSharp
{
    public partial struct AwaitExpressionInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public Microsoft.CodeAnalysis.IMethodSymbol? GetAwaiterMethod { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? GetResultMethod { get { throw null; } }
        public Microsoft.CodeAnalysis.IPropertySymbol? IsCompletedProperty { get { throw null; } }
        public bool IsDynamic { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public partial struct Conversion : System.IEquatable<Microsoft.CodeAnalysis.CSharp.Conversion>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public bool Exists { get { throw null; } }
        public bool IsAnonymousFunction { get { throw null; } }
        public bool IsBoxing { get { throw null; } }
        public bool IsConditionalExpression { get { throw null; } }
        public bool IsConstantExpression { get { throw null; } }
        public bool IsDefaultLiteral { get { throw null; } }
        public bool IsDynamic { get { throw null; } }
        public bool IsEnumeration { get { throw null; } }
        public bool IsExplicit { get { throw null; } }
        public bool IsIdentity { get { throw null; } }
        public bool IsImplicit { get { throw null; } }
        public bool IsInterpolatedString { get { throw null; } }
        public bool IsInterpolatedStringHandler { get { throw null; } }
        public bool IsIntPtr { get { throw null; } }
        public bool IsMethodGroup { get { throw null; } }
        public bool IsNullable { get { throw null; } }
        public bool IsNullLiteral { get { throw null; } }
        public bool IsNumeric { get { throw null; } }
        public bool IsPointer { get { throw null; } }
        public bool IsReference { get { throw null; } }
        public bool IsStackAlloc { get { throw null; } }
        public bool IsSwitchExpression { get { throw null; } }
        public bool IsThrow { get { throw null; } }
        public bool IsTupleConversion { get { throw null; } }
        public bool IsTupleLiteralConversion { get { throw null; } }
        public bool IsUnboxing { get { throw null; } }
        public bool IsUserDefined { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? MethodSymbol { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.Conversion other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public static bool operator ==(Microsoft.CodeAnalysis.CSharp.Conversion left, Microsoft.CodeAnalysis.CSharp.Conversion right) { throw null; }
        public static bool operator !=(Microsoft.CodeAnalysis.CSharp.Conversion left, Microsoft.CodeAnalysis.CSharp.Conversion right) { throw null; }
        public Microsoft.CodeAnalysis.Operations.CommonConversion ToCommonConversion() { throw null; }
        public override string ToString() { throw null; }
    }
    public sealed partial class CSharpCommandLineArguments : Microsoft.CodeAnalysis.CommandLineArguments
    {
        internal CSharpCommandLineArguments() { }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions CompilationOptions { get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CompilationOptionsCore { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions ParseOptions { get { throw null; } }
        protected override Microsoft.CodeAnalysis.ParseOptions ParseOptionsCore { get { throw null; } }
    }
    public partial class CSharpCommandLineParser : Microsoft.CodeAnalysis.CommandLineParser
    {
        internal CSharpCommandLineParser() { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser Default { get { throw null; } }
        protected override string RegularFileExtension { get { throw null; } }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser Script { get { throw null; } }
        protected override string ScriptFileExtension { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments Parse(System.Collections.Generic.IEnumerable<string> args, string? baseDirectory, string? sdkDirectory, string? additionalReferenceDirectories = null) { throw null; }
        public static System.Collections.Generic.IEnumerable<string> ParseConditionalCompilationSymbols(string value, out System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> diagnostics) { throw null; }
    }
    public sealed partial class CSharpCompilation : Microsoft.CodeAnalysis.Compilation
    {
        internal CSharpCompilation() { }
        protected override Microsoft.CodeAnalysis.IAssemblySymbol CommonAssembly { get { throw null; } }
        protected override Microsoft.CodeAnalysis.ITypeSymbol CommonDynamicType { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonGlobalNamespace { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonObjectType { get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonOptions { get { throw null; } }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol? CommonScriptClass { get { throw null; } }
        protected override Microsoft.CodeAnalysis.ITypeSymbol? CommonScriptGlobalsType { get { throw null; } }
        protected override Microsoft.CodeAnalysis.IModuleSymbol CommonSourceModule { get { throw null; } }
        protected override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxTree> CommonSyntaxTrees { get { throw null; } }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.MetadataReference> DirectiveReferences { get { throw null; } }
        public override bool IsCaseSensitive { get { throw null; } }
        public override string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions Options { get { throw null; } }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.AssemblyIdentity> ReferencedAssemblyNames { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo? ScriptCompilationInfo { get { throw null; } }
        public new System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SyntaxTree> SyntaxTrees { get { throw null; } }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation AddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override void AppendDefaultVersionResource(System.IO.Stream resourceStream) { }
        public override Microsoft.CodeAnalysis.Operations.CommonConversion ClassifyCommonConversion(Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation Clone() { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonClone() { throw null; }
        protected override bool CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree? syntaxTree) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> memberTypes, System.Collections.Immutable.ImmutableArray<string> memberNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location> memberLocations, System.Collections.Immutable.ImmutableArray<bool> memberIsReadOnly, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.NullableAnnotation> memberNullableAnnotations) { throw null; }
        protected override Microsoft.CodeAnalysis.IArrayTypeSymbol CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType, int rank, Microsoft.CodeAnalysis.NullableAnnotation elementNullableAnnotation) { throw null; }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol CommonCreateErrorNamespaceSymbol(Microsoft.CodeAnalysis.INamespaceSymbol container, string name) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol? container, string name, int arity) { throw null; }
        protected override Microsoft.CodeAnalysis.IFunctionPointerTypeSymbol CommonCreateFunctionPointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol returnType, Microsoft.CodeAnalysis.RefKind returnRefKind, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> parameterTypes, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.RefKind> parameterRefKinds, System.Reflection.Metadata.SignatureCallingConvention callingConvention, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.INamedTypeSymbol> callingConventionTypes) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateNativeIntegerTypeSymbol(bool signed) { throw null; }
        protected override Microsoft.CodeAnalysis.IPointerTypeSymbol CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol elementType) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(Microsoft.CodeAnalysis.INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray<string?> elementNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location?> elementLocations, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.NullableAnnotation> elementNullableAnnotations) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol CommonCreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ITypeSymbol> elementTypes, System.Collections.Immutable.ImmutableArray<string?> elementNames, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Location?> elementLocations, System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.NullableAnnotation> elementNullableAnnotations) { throw null; }
        protected override Microsoft.CodeAnalysis.ISymbol? CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference reference) { throw null; }
        protected override Microsoft.CodeAnalysis.INamespaceSymbol? CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol namespaceSymbol) { throw null; }
        protected override Microsoft.CodeAnalysis.IMethodSymbol? CommonGetEntryPoint(System.Threading.CancellationToken cancellationToken) { throw null; }
        protected override Microsoft.CodeAnalysis.SemanticModel CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }
        protected override Microsoft.CodeAnalysis.INamedTypeSymbol? CommonGetTypeByMetadataName(string metadataName) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonRemoveAllSyntaxTrees() { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree? newTree) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithAssemblyName(string? assemblyName) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions options) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> newReferences) { throw null; }
        protected override Microsoft.CodeAnalysis.Compilation CommonWithScriptCompilationInfo(Microsoft.CodeAnalysis.ScriptCompilationInfo? info) { throw null; }
        public override bool ContainsSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override bool ContainsSymbolsWithName(string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public new bool ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree? syntaxTree) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation Create(string? assemblyName, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree>? syntaxTrees = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference>? references = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions? options = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpCompilation CreateScriptCompilation(string assemblyName, Microsoft.CodeAnalysis.SyntaxTree? syntaxTree = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference>? references = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions? options = null, Microsoft.CodeAnalysis.CSharp.CSharpCompilation? previousScriptCompilation = null, System.Type? returnType = null, System.Type? globalsType = null) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDeclarationDiagnostics(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public Microsoft.CodeAnalysis.MetadataReference? GetDirectiveReference(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax directive) { throw null; }
        public new Microsoft.CodeAnalysis.MetadataReference? GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol assemblySymbol) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetMethodBodyDiagnostics(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Diagnostic> GetParseDiagnostics(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public new Microsoft.CodeAnalysis.SemanticModel GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> GetSymbolsWithName(System.Func<string, bool> predicate, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> GetSymbolsWithName(string name, Microsoft.CodeAnalysis.SymbolFilter filter = Microsoft.CodeAnalysis.SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.MetadataReference> GetUsedAssemblyReferences(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllReferences() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveAllSyntaxTrees() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(params Microsoft.CodeAnalysis.SyntaxTree[] trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation RemoveSyntaxTrees(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTree> trees) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceReference(Microsoft.CodeAnalysis.MetadataReference oldReference, Microsoft.CodeAnalysis.MetadataReference newReference) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree oldTree, Microsoft.CodeAnalysis.SyntaxTree? newTree) { throw null; }
        public override Microsoft.CodeAnalysis.CompilationReference ToMetadataReference(System.Collections.Immutable.ImmutableArray<string> aliases = default(System.Collections.Immutable.ImmutableArray<string>), bool embedInteropTypes = false) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithAssemblyName(string? assemblyName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithOptions(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions options) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(params Microsoft.CodeAnalysis.MetadataReference[] references) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithReferences(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference>? references) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilation WithScriptCompilationInfo(Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo? info) { throw null; }
    }
    public sealed partial class CSharpCompilationOptions : Microsoft.CodeAnalysis.CompilationOptions, System.IEquatable<Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions>
    {
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider, bool publicSign) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider, bool publicSign, Microsoft.CodeAnalysis.MetadataImportOptions metadataImportOptions) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, bool reportSuppressedDiagnostics = false, string? moduleName = null, string? mainTypeName = null, string? scriptClassName = null, System.Collections.Generic.IEnumerable<string>? usings = null, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel = Microsoft.CodeAnalysis.OptimizationLevel.Debug, bool checkOverflow = false, bool allowUnsafe = false, string? cryptoKeyContainer = null, string? cryptoKeyFile = null, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey = default(System.Collections.Immutable.ImmutableArray<byte>), bool? delaySign = default(bool?), Microsoft.CodeAnalysis.Platform platform = Microsoft.CodeAnalysis.Platform.AnyCpu, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption = Microsoft.CodeAnalysis.ReportDiagnostic.Default, int warningLevel = 4, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver = null, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver = null, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver = null, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer = null, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider = null, bool publicSign = false, Microsoft.CodeAnalysis.MetadataImportOptions metadataImportOptions = Microsoft.CodeAnalysis.MetadataImportOptions.Public, Microsoft.CodeAnalysis.NullableContextOptions nullableContextOptions = Microsoft.CodeAnalysis.NullableContextOptions.Disable) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider) { }
        public CSharpCompilationOptions(Microsoft.CodeAnalysis.OutputKind outputKind, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, Microsoft.CodeAnalysis.OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Microsoft.CodeAnalysis.Platform platform, Microsoft.CodeAnalysis.ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, Microsoft.CodeAnalysis.XmlReferenceResolver? xmlReferenceResolver, Microsoft.CodeAnalysis.SourceReferenceResolver? sourceReferenceResolver, Microsoft.CodeAnalysis.MetadataReferenceResolver? metadataReferenceResolver, Microsoft.CodeAnalysis.AssemblyIdentityComparer? assemblyIdentityComparer, Microsoft.CodeAnalysis.StrongNameProvider? strongNameProvider) { }
        public bool AllowUnsafe { get { throw null; } }
        public override string Language { get { throw null; } }
        public override Microsoft.CodeAnalysis.NullableContextOptions NullableContextOptions { get { throw null; } protected set { } }
        public System.Collections.Immutable.ImmutableArray<string> Usings { get { throw null; } }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer? comparer) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCheckOverflow(bool checkOverflow) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithConcurrentBuild(bool concurrent) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoKeyContainer(string? cryptoKeyContainer) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoKeyFile(string? cryptoKeyFile) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithDelaySign(bool? delaySign) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithDeterministic(bool deterministic) { throw null; }
        [System.ObsoleteAttribute]
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithFeatures(System.Collections.Immutable.ImmutableArray<string> features) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic value) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithMainTypeName(string? mainTypeName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithMetadataImportOptions(Microsoft.CodeAnalysis.MetadataImportOptions value) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver? resolver) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithModuleName(string? moduleName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithOutputKind(Microsoft.CodeAnalysis.OutputKind kind) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithPlatform(Microsoft.CodeAnalysis.Platform platform) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithPublicSign(bool publicSign) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithScriptClassName(string? scriptClassName) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver? resolver) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? specificDiagnosticOptions) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? specificDiagnosticOptions) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider? provider) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithSyntaxTreeOptionsProvider(Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider? provider) { throw null; }
        protected override Microsoft.CodeAnalysis.CompilationOptions CommonWithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver? resolver) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithAllowUnsafe(bool enabled) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer? comparer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoKeyContainer(string? name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoKeyFile(string? path) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithDelaySign(bool? value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithDeterministic(bool deterministic) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithMainTypeName(string? name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithMetadataImportOptions(Microsoft.CodeAnalysis.MetadataImportOptions value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver? resolver) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithModuleName(string? moduleName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithNullableContextOptions(Microsoft.CodeAnalysis.NullableContextOptions options) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel value) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOutputKind(Microsoft.CodeAnalysis.OutputKind kind) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithOverflowChecks(bool enabled) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithPlatform(Microsoft.CodeAnalysis.Platform platform) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithPublicSign(bool publicSign) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithScriptClassName(string? name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver? resolver) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.CodeAnalysis.ReportDiagnostic>>? values) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? values) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider? provider) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithSyntaxTreeOptionsProvider(Microsoft.CodeAnalysis.SyntaxTreeOptionsProvider? provider) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(System.Collections.Generic.IEnumerable<string>? usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(System.Collections.Immutable.ImmutableArray<string> usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithUsings(params string[]? usings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithWarningLevel(int warningLevel) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions WithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver? resolver) { throw null; }
    }
    public partial class CSharpDiagnosticFormatter : Microsoft.CodeAnalysis.DiagnosticFormatter
    {
        internal CSharpDiagnosticFormatter() { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter Instance { get { throw null; } }
    }
    public static partial class CSharpExtensions
    {
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis? AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.ControlFlowAnalysis? AnalyzeControlFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.DataFlowAnalysis? AnalyzeDataFlow(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax firstStatement, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax lastStatement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.Compilation? compilation, Microsoft.CodeAnalysis.ITypeSymbol source, Microsoft.CodeAnalysis.ITypeSymbol destination) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion ClassifyConversion(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.ITypeSymbol destination, bool isExplicitInSource = false) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol? GetAliasInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo GetAwaitExpressionInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax awaitExpression) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetCollectionInitializerSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(this Microsoft.CodeAnalysis.SyntaxTree tree, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.Optional<object> GetConstantValue(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(this Microsoft.CodeAnalysis.Operations.IConversionOperation conversionExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetConversion(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.SyntaxNode expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IMethodSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IMethodSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILocalSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IMethodSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IFieldSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IEventSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamespaceSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILocalSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILabelSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamespaceSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IParameterSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IPropertySymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IRangeVariableSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ILabelSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.INamedTypeSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ITypeParameterSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.ISymbol? GetDeclaredSymbol(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax assignment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.DeconstructionInfo GetDeconstructionInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax @foreach) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetFirstDirective(this Microsoft.CodeAnalysis.SyntaxNode node, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax forEachStatement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo GetForEachStatementInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax forEachStatement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetInConversion(this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.IPropertySymbol> GetIndexerGroup(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetLastDirective(this Microsoft.CodeAnalysis.SyntaxNode node, System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.ISymbol> GetMemberGroup(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetOutConversion(this Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation compoundAssignment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.QueryClauseInfo GetQueryClauseInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.IAliasSymbol? GetSpeculativeAliasInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax nameSyntax, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Conversion GetSpeculativeConversion(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSpeculativeSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetSpeculativeTypeInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SymbolInfo GetSymbolInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.TypeInfo GetTypeInfo(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList Insert(this Microsoft.CodeAnalysis.SyntaxTokenList list, int index, params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public static bool IsContextualKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsReservedKeyword(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsVerbatimIdentifier(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static bool IsVerbatimStringLiteral(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind(this Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(this Microsoft.CodeAnalysis.SyntaxToken token, Microsoft.CodeAnalysis.SyntaxTrivia oldTrivia, Microsoft.CodeAnalysis.SyntaxTrivia newTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ReplaceTrivia(this Microsoft.CodeAnalysis.SyntaxToken token, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivia, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia> computeReplacementTrivia) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax attribute, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax crefSyntax, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax initializer, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModel(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel, Microsoft.CodeAnalysis.SpeculativeBindingOption bindingOption = Microsoft.CodeAnalysis.SpeculativeBindingOption.BindAsExpression) { throw null; }
        public static bool TryGetSpeculativeSemanticModelForMethodBody(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax accessor, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static bool TryGetSpeculativeSemanticModelForMethodBody(this Microsoft.CodeAnalysis.SemanticModel? semanticModel, int position, Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax method, out Microsoft.CodeAnalysis.SemanticModel? speculativeModel) { throw null; }
        public static Microsoft.CodeAnalysis.VarianceKind VarianceKindFromToken(this Microsoft.CodeAnalysis.SyntaxToken node) { throw null; }
    }
    public static partial class CSharpFileSystemExtensions
    {
        public static Microsoft.CodeAnalysis.Emit.EmitResult Emit(this Microsoft.CodeAnalysis.CSharp.CSharpCompilation compilation, string outputPath, string? pdbPath = null, string? xmlDocumentationPath = null, string? win32ResourcesPath = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ResourceDescription>? manifestResources = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
    }
    public sealed partial class CSharpGeneratorDriver : Microsoft.CodeAnalysis.GeneratorDriver
    {
        internal CSharpGeneratorDriver() { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver Create(params Microsoft.CodeAnalysis.IIncrementalGenerator[] incrementalGenerators) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver Create(params Microsoft.CodeAnalysis.ISourceGenerator[] generators) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver Create(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISourceGenerator> generators, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.AdditionalText>? additionalTexts, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? parseOptions, Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider? optionsProvider) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.CSharpGeneratorDriver Create(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISourceGenerator> generators, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.AdditionalText>? additionalTexts = null, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? parseOptions = null, Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider? optionsProvider = null, Microsoft.CodeAnalysis.GeneratorDriverOptions driverOptions = default(Microsoft.CodeAnalysis.GeneratorDriverOptions)) { throw null; }
    }
    public sealed partial class CSharpParseOptions : Microsoft.CodeAnalysis.ParseOptions, System.IEquatable<Microsoft.CodeAnalysis.CSharp.CSharpParseOptions>
    {
        public CSharpParseOptions(Microsoft.CodeAnalysis.CSharp.LanguageVersion languageVersion = Microsoft.CodeAnalysis.CSharp.LanguageVersion.Default, Microsoft.CodeAnalysis.DocumentationMode documentationMode = Microsoft.CodeAnalysis.DocumentationMode.Parse, Microsoft.CodeAnalysis.SourceCodeKind kind = Microsoft.CodeAnalysis.SourceCodeKind.Regular, System.Collections.Generic.IEnumerable<string>? preprocessorSymbols = null) { }
        public static Microsoft.CodeAnalysis.CSharp.CSharpParseOptions Default { get { throw null; } }
        public override System.Collections.Generic.IReadOnlyDictionary<string, string> Features { get { throw null; } }
        public override string Language { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion LanguageVersion { get { throw null; } }
        public override System.Collections.Generic.IEnumerable<string> PreprocessorSymbolNames { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.LanguageVersion SpecifiedLanguageVersion { get { throw null; } }
        protected override Microsoft.CodeAnalysis.ParseOptions CommonWithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode) { throw null; }
        protected override Microsoft.CodeAnalysis.ParseOptions CommonWithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>? features) { throw null; }
        public override Microsoft.CodeAnalysis.ParseOptions CommonWithKind(Microsoft.CodeAnalysis.SourceCodeKind kind) { throw null; }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode documentationMode) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>? features) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithKind(Microsoft.CodeAnalysis.SourceCodeKind kind) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithLanguageVersion(Microsoft.CodeAnalysis.CSharp.LanguageVersion version) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(System.Collections.Generic.IEnumerable<string>? preprocessorSymbols) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(System.Collections.Immutable.ImmutableArray<string> symbols) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.CSharpParseOptions WithPreprocessorSymbols(params string[]? preprocessorSymbols) { throw null; }
    }
    public sealed partial class CSharpScriptCompilationInfo : Microsoft.CodeAnalysis.ScriptCompilationInfo
    {
        internal CSharpScriptCompilationInfo() { }
        public new Microsoft.CodeAnalysis.CSharp.CSharpCompilation? PreviousScriptCompilation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo WithPreviousScriptCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation? compilation) { throw null; }
    }
    public abstract partial class CSharpSyntaxNode : Microsoft.CodeAnalysis.SyntaxNode, System.IFormattable
    {
        internal CSharpSyntaxNode() { }
        public override string Language { get { throw null; } }
        protected override Microsoft.CodeAnalysis.SyntaxTree SyntaxTreeCore { get { throw null; } }
        public abstract void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor);
        public abstract TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor);
        public static Microsoft.CodeAnalysis.SyntaxNode DeserializeFrom(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        protected override bool EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode other) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken FindToken(int position, bool findInsideTrivia = false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTrivia FindTrivia(int position, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, bool> stepInto) { throw null; }
        public new System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetFirstDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetLastDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false) { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTriviaList GetLeadingTrivia() { throw null; }
        public new Microsoft.CodeAnalysis.Location GetLocation() { throw null; }
        public new Microsoft.CodeAnalysis.SyntaxTriviaList GetTrailingTrivia() { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertNodesInListCore(Microsoft.CodeAnalysis.SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodesToInsert, bool insertBefore) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertTokensInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens, bool insertBefore) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode InsertTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia, bool insertBefore) { throw null; }
        protected override bool IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode node, bool topLevel = false) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.SyntaxKind Kind() { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode? RemoveNodesCore(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> nodes, Microsoft.CodeAnalysis.SyntaxRemoveOptions options) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceCore<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes = null, System.Func<TNode, TNode, Microsoft.CodeAnalysis.SyntaxNode>? computeReplacementNode = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>? tokens = null, System.Func<Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken, Microsoft.CodeAnalysis.SyntaxToken>? computeReplacementToken = null, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>? trivia = null, System.Func<Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia, Microsoft.CodeAnalysis.SyntaxTrivia>? computeReplacementTrivia = null) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceNodeInListCore(Microsoft.CodeAnalysis.SyntaxNode originalNode, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> replacementNodes) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceTokenInListCore(Microsoft.CodeAnalysis.SyntaxToken originalToken, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> newTokens) { throw null; }
        protected internal override Microsoft.CodeAnalysis.SyntaxNode ReplaceTriviaInListCore(Microsoft.CodeAnalysis.SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> newTrivia) { throw null; }
        string System.IFormattable.ToString(string? format, System.IFormatProvider? formatProvider) { throw null; }
    }
    public abstract partial class CSharpSyntaxRewriter : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<Microsoft.CodeAnalysis.SyntaxNode?>
    {
        public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia = false) { }
        public virtual bool VisitIntoStructuredTrivia { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxNode? Visit(Microsoft.CodeAnalysis.SyntaxNode? node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBinaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDefaultConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDiscardPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitFunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLineDirectivePosition(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax node) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTokenList VisitList(Microsoft.CodeAnalysis.SyntaxTokenList list) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTriviaList VisitList(Microsoft.CodeAnalysis.SyntaxTriviaList list) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTrivia VisitListElement(Microsoft.CodeAnalysis.SyntaxTrivia element) { throw null; }
        public virtual TNode? VisitListElement<TNode>(TNode? node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxToken VisitListSeparator(Microsoft.CodeAnalysis.SyntaxToken separator) { throw null; }
        public virtual Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> VisitList<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> list) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxList<TNode> VisitList<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> list) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNullableDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRecordDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitRelationalPattern(Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSubpattern(Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxToken VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public virtual Microsoft.CodeAnalysis.SyntaxTrivia VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitTypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitUnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitVarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitWithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxNode? VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { throw null; }
    }
    public abstract partial class CSharpSyntaxTree : Microsoft.CodeAnalysis.SyntaxTree
    {
        protected CSharpSyntaxTree() { }
        public abstract new Microsoft.CodeAnalysis.CSharp.CSharpParseOptions Options { get; }
        protected override Microsoft.CodeAnalysis.ParseOptions OptionsCore { get { throw null; } }
        protected T CloneNodeAsRoot<T>(T node) where T : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode root, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode root, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode root, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode) { throw null; }
        public override System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextSpan> GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree oldTree) { throw null; }
        public override System.Collections.Generic.IList<Microsoft.CodeAnalysis.Text.TextChange> GetChanges(Microsoft.CodeAnalysis.SyntaxTree oldTree) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax GetCompilationUnitRoot(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken nodeOrToken) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.LineMapping> GetLineMappings(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.FileLinePositionSpan GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.LineVisibility GetLineVisibility(int position, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public override Microsoft.CodeAnalysis.Location GetLocation(Microsoft.CodeAnalysis.Text.TextSpan span) { throw null; }
        public override Microsoft.CodeAnalysis.FileLinePositionSpan GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public abstract new Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode GetRoot(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        public virtual new System.Threading.Tasks.Task<Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode> GetRootAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        protected override System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SyntaxNode> GetRootAsyncCore(System.Threading.CancellationToken cancellationToken) { throw null; }
        protected override Microsoft.CodeAnalysis.SyntaxNode GetRootCore(System.Threading.CancellationToken cancellationToken) { throw null; }
        public override bool HasHiddenRegions() { throw null; }
        public override bool IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree tree, bool topLevel = false) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options = null, string path = "", System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(string text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(string text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseText(string text, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public abstract bool TryGetRoot(out Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode? root);
        protected override bool TryGetRootCore(out Microsoft.CodeAnalysis.SyntaxNode? root) { throw null; }
        public override Microsoft.CodeAnalysis.SyntaxTree WithChangedText(Microsoft.CodeAnalysis.Text.SourceText newText) { throw null; }
    }
    public abstract partial class CSharpSyntaxVisitor
    {
        protected CSharpSyntaxVisitor() { }
        public virtual void DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public virtual void Visit(Microsoft.CodeAnalysis.SyntaxNode? node) { }
        public virtual void VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { }
        public virtual void VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { }
        public virtual void VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { }
        public virtual void VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { }
        public virtual void VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { }
        public virtual void VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { }
        public virtual void VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { }
        public virtual void VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { }
        public virtual void VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { }
        public virtual void VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { }
        public virtual void VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { }
        public virtual void VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { }
        public virtual void VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { }
        public virtual void VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { }
        public virtual void VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { }
        public virtual void VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { }
        public virtual void VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { }
        public virtual void VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { }
        public virtual void VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { }
        public virtual void VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { }
        public virtual void VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { }
        public virtual void VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { }
        public virtual void VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { }
        public virtual void VisitBinaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax node) { }
        public virtual void VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { }
        public virtual void VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { }
        public virtual void VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { }
        public virtual void VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { }
        public virtual void VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { }
        public virtual void VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { }
        public virtual void VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { }
        public virtual void VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { }
        public virtual void VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { }
        public virtual void VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { }
        public virtual void VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { }
        public virtual void VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { }
        public virtual void VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { }
        public virtual void VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { }
        public virtual void VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { }
        public virtual void VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { }
        public virtual void VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { }
        public virtual void VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { }
        public virtual void VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { }
        public virtual void VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { }
        public virtual void VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { }
        public virtual void VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { }
        public virtual void VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { }
        public virtual void VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { }
        public virtual void VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { }
        public virtual void VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { }
        public virtual void VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { }
        public virtual void VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { }
        public virtual void VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { }
        public virtual void VisitDefaultConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax node) { }
        public virtual void VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { }
        public virtual void VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { }
        public virtual void VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { }
        public virtual void VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { }
        public virtual void VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { }
        public virtual void VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { }
        public virtual void VisitDiscardPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax node) { }
        public virtual void VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { }
        public virtual void VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { }
        public virtual void VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { }
        public virtual void VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { }
        public virtual void VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { }
        public virtual void VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { }
        public virtual void VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { }
        public virtual void VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { }
        public virtual void VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { }
        public virtual void VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { }
        public virtual void VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { }
        public virtual void VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { }
        public virtual void VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { }
        public virtual void VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { }
        public virtual void VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { }
        public virtual void VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { }
        public virtual void VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { }
        public virtual void VisitExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax node) { }
        public virtual void VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { }
        public virtual void VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { }
        public virtual void VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { }
        public virtual void VisitFileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax node) { }
        public virtual void VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { }
        public virtual void VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { }
        public virtual void VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { }
        public virtual void VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { }
        public virtual void VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { }
        public virtual void VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { }
        public virtual void VisitFunctionPointerCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax node) { }
        public virtual void VisitFunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax node) { }
        public virtual void VisitFunctionPointerParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax node) { }
        public virtual void VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax node) { }
        public virtual void VisitFunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { }
        public virtual void VisitFunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { }
        public virtual void VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { }
        public virtual void VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { }
        public virtual void VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { }
        public virtual void VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { }
        public virtual void VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { }
        public virtual void VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { }
        public virtual void VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { }
        public virtual void VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { }
        public virtual void VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { }
        public virtual void VisitImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax node) { }
        public virtual void VisitImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { }
        public virtual void VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { }
        public virtual void VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { }
        public virtual void VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { }
        public virtual void VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { }
        public virtual void VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { }
        public virtual void VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { }
        public virtual void VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { }
        public virtual void VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { }
        public virtual void VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { }
        public virtual void VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { }
        public virtual void VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { }
        public virtual void VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { }
        public virtual void VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { }
        public virtual void VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { }
        public virtual void VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { }
        public virtual void VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { }
        public virtual void VisitLineDirectivePosition(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax node) { }
        public virtual void VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { }
        public virtual void VisitLineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax node) { }
        public virtual void VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { }
        public virtual void VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { }
        public virtual void VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { }
        public virtual void VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { }
        public virtual void VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { }
        public virtual void VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { }
        public virtual void VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { }
        public virtual void VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { }
        public virtual void VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { }
        public virtual void VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { }
        public virtual void VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { }
        public virtual void VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { }
        public virtual void VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { }
        public virtual void VisitNullableDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax node) { }
        public virtual void VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { }
        public virtual void VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { }
        public virtual void VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { }
        public virtual void VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { }
        public virtual void VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { }
        public virtual void VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { }
        public virtual void VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { }
        public virtual void VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { }
        public virtual void VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { }
        public virtual void VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { }
        public virtual void VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { }
        public virtual void VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { }
        public virtual void VisitParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax node) { }
        public virtual void VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { }
        public virtual void VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { }
        public virtual void VisitPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax node) { }
        public virtual void VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { }
        public virtual void VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { }
        public virtual void VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { }
        public virtual void VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { }
        public virtual void VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { }
        public virtual void VisitPrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax node) { }
        public virtual void VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { }
        public virtual void VisitPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax node) { }
        public virtual void VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { }
        public virtual void VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { }
        public virtual void VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { }
        public virtual void VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { }
        public virtual void VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { }
        public virtual void VisitRangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax node) { }
        public virtual void VisitRecordDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax node) { }
        public virtual void VisitRecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax node) { }
        public virtual void VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { }
        public virtual void VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { }
        public virtual void VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { }
        public virtual void VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { }
        public virtual void VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { }
        public virtual void VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { }
        public virtual void VisitRelationalPattern(Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax node) { }
        public virtual void VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { }
        public virtual void VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { }
        public virtual void VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { }
        public virtual void VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { }
        public virtual void VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { }
        public virtual void VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { }
        public virtual void VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { }
        public virtual void VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { }
        public virtual void VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { }
        public virtual void VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { }
        public virtual void VisitSubpattern(Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax node) { }
        public virtual void VisitSwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax node) { }
        public virtual void VisitSwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax node) { }
        public virtual void VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { }
        public virtual void VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { }
        public virtual void VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { }
        public virtual void VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { }
        public virtual void VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { }
        public virtual void VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { }
        public virtual void VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { }
        public virtual void VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { }
        public virtual void VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { }
        public virtual void VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { }
        public virtual void VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { }
        public virtual void VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { }
        public virtual void VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { }
        public virtual void VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { }
        public virtual void VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { }
        public virtual void VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { }
        public virtual void VisitTypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax node) { }
        public virtual void VisitUnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax node) { }
        public virtual void VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { }
        public virtual void VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { }
        public virtual void VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { }
        public virtual void VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { }
        public virtual void VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { }
        public virtual void VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { }
        public virtual void VisitVarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax node) { }
        public virtual void VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { }
        public virtual void VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { }
        public virtual void VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { }
        public virtual void VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { }
        public virtual void VisitWithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax node) { }
        public virtual void VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { }
        public virtual void VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { }
        public virtual void VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { }
        public virtual void VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { }
        public virtual void VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { }
        public virtual void VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { }
        public virtual void VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { }
        public virtual void VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { }
        public virtual void VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { }
        public virtual void VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { }
        public virtual void VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { }
        public virtual void VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { }
        public virtual void VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { }
        public virtual void VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { }
    }
    public abstract partial class CSharpSyntaxVisitor<TResult>
    {
        protected CSharpSyntaxVisitor() { }
        public virtual TResult? DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public virtual TResult? Visit(Microsoft.CodeAnalysis.SyntaxNode? node) { throw null; }
        public virtual TResult? VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax node) { throw null; }
        public virtual TResult? VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax node) { throw null; }
        public virtual TResult? VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax node) { throw null; }
        public virtual TResult? VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }
        public virtual TResult? VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax node) { throw null; }
        public virtual TResult? VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax node) { throw null; }
        public virtual TResult? VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax node) { throw null; }
        public virtual TResult? VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax node) { throw null; }
        public virtual TResult? VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax node) { throw null; }
        public virtual TResult? VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax node) { throw null; }
        public virtual TResult? VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax node) { throw null; }
        public virtual TResult? VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax node) { throw null; }
        public virtual TResult? VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax node) { throw null; }
        public virtual TResult? VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax node) { throw null; }
        public virtual TResult? VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax node) { throw null; }
        public virtual TResult? VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax node) { throw null; }
        public virtual TResult? VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax node) { throw null; }
        public virtual TResult? VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax node) { throw null; }
        public virtual TResult? VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax node) { throw null; }
        public virtual TResult? VisitBinaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax node) { throw null; }
        public virtual TResult? VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node) { throw null; }
        public virtual TResult? VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax node) { throw null; }
        public virtual TResult? VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax node) { throw null; }
        public virtual TResult? VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax node) { throw null; }
        public virtual TResult? VisitCasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax node) { throw null; }
        public virtual TResult? VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax node) { throw null; }
        public virtual TResult? VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax node) { throw null; }
        public virtual TResult? VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax node) { throw null; }
        public virtual TResult? VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax node) { throw null; }
        public virtual TResult? VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax node) { throw null; }
        public virtual TResult? VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax node) { throw null; }
        public virtual TResult? VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax node) { throw null; }
        public virtual TResult? VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax node) { throw null; }
        public virtual TResult? VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax node) { throw null; }
        public virtual TResult? VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax node) { throw null; }
        public virtual TResult? VisitConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax node) { throw null; }
        public virtual TResult? VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax node) { throw null; }
        public virtual TResult? VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax node) { throw null; }
        public virtual TResult? VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax node) { throw null; }
        public virtual TResult? VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }
        public virtual TResult? VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax node) { throw null; }
        public virtual TResult? VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax node) { throw null; }
        public virtual TResult? VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax node) { throw null; }
        public virtual TResult? VisitDeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitDeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax node) { throw null; }
        public virtual TResult? VisitDefaultConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax node) { throw null; }
        public virtual TResult? VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax node) { throw null; }
        public virtual TResult? VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax node) { throw null; }
        public virtual TResult? VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitDiscardDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax node) { throw null; }
        public virtual TResult? VisitDiscardPattern(Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax node) { throw null; }
        public virtual TResult? VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax node) { throw null; }
        public virtual TResult? VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax node) { throw null; }
        public virtual TResult? VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax node) { throw null; }
        public virtual TResult? VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax node) { throw null; }
        public virtual TResult? VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax node) { throw null; }
        public virtual TResult? VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax node) { throw null; }
        public virtual TResult? VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax node) { throw null; }
        public virtual TResult? VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }
        public virtual TResult? VisitExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax node) { throw null; }
        public virtual TResult? VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax node) { throw null; }
        public virtual TResult? VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax node) { throw null; }
        public virtual TResult? VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitFileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax node) { throw null; }
        public virtual TResult? VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax node) { throw null; }
        public virtual TResult? VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax node) { throw null; }
        public virtual TResult? VisitForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax node) { throw null; }
        public virtual TResult? VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax node) { throw null; }
        public virtual TResult? VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { throw null; }
        public virtual TResult? VisitFunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { throw null; }
        public virtual TResult? VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax node) { throw null; }
        public virtual TResult? VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax node) { throw null; }
        public virtual TResult? VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax node) { throw null; }
        public virtual TResult? VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax node) { throw null; }
        public virtual TResult? VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax node) { throw null; }
        public virtual TResult? VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax node) { throw null; }
        public virtual TResult? VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax node) { throw null; }
        public virtual TResult? VisitImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax node) { throw null; }
        public virtual TResult? VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax node) { throw null; }
        public virtual TResult? VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax node) { throw null; }
        public virtual TResult? VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax node) { throw null; }
        public virtual TResult? VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax node) { throw null; }
        public virtual TResult? VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax node) { throw null; }
        public virtual TResult? VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }
        public virtual TResult? VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax node) { throw null; }
        public virtual TResult? VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitIsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax node) { throw null; }
        public virtual TResult? VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax node) { throw null; }
        public virtual TResult? VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax node) { throw null; }
        public virtual TResult? VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax node) { throw null; }
        public virtual TResult? VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax node) { throw null; }
        public virtual TResult? VisitLineDirectivePosition(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax node) { throw null; }
        public virtual TResult? VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitLineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax node) { throw null; }
        public virtual TResult? VisitLoadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax node) { throw null; }
        public virtual TResult? VisitLocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax node) { throw null; }
        public virtual TResult? VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax node) { throw null; }
        public virtual TResult? VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax node) { throw null; }
        public virtual TResult? VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax node) { throw null; }
        public virtual TResult? VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax node) { throw null; }
        public virtual TResult? VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax node) { throw null; }
        public virtual TResult? VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax node) { throw null; }
        public virtual TResult? VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax node) { throw null; }
        public virtual TResult? VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitNullableDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax node) { throw null; }
        public virtual TResult? VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }
        public virtual TResult? VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax node) { throw null; }
        public virtual TResult? VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax node) { throw null; }
        public virtual TResult? VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax node) { throw null; }
        public virtual TResult? VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax node) { throw null; }
        public virtual TResult? VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax node) { throw null; }
        public virtual TResult? VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax node) { throw null; }
        public virtual TResult? VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax node) { throw null; }
        public virtual TResult? VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }
        public virtual TResult? VisitParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax node) { throw null; }
        public virtual TResult? VisitParenthesizedVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }
        public virtual TResult? VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax node) { throw null; }
        public virtual TResult? VisitPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax node) { throw null; }
        public virtual TResult? VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax node) { throw null; }
        public virtual TResult? VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax node) { throw null; }
        public virtual TResult? VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax node) { throw null; }
        public virtual TResult? VisitPrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax node) { throw null; }
        public virtual TResult? VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax node) { throw null; }
        public virtual TResult? VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax node) { throw null; }
        public virtual TResult? VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax node) { throw null; }
        public virtual TResult? VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax node) { throw null; }
        public virtual TResult? VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax node) { throw null; }
        public virtual TResult? VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax node) { throw null; }
        public virtual TResult? VisitRangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax node) { throw null; }
        public virtual TResult? VisitRecordDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitRecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax node) { throw null; }
        public virtual TResult? VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax node) { throw null; }
        public virtual TResult? VisitRefType(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax node) { throw null; }
        public virtual TResult? VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax node) { throw null; }
        public virtual TResult? VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax node) { throw null; }
        public virtual TResult? VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitRelationalPattern(Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax node) { throw null; }
        public virtual TResult? VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax node) { throw null; }
        public virtual TResult? VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax node) { throw null; }
        public virtual TResult? VisitShebangDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax node) { throw null; }
        public virtual TResult? VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node) { throw null; }
        public virtual TResult? VisitSingleVariableDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax node) { throw null; }
        public virtual TResult? VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax node) { throw null; }
        public virtual TResult? VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax node) { throw null; }
        public virtual TResult? VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }
        public virtual TResult? VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitSubpattern(Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax node) { throw null; }
        public virtual TResult? VisitSwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax node) { throw null; }
        public virtual TResult? VisitSwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax node) { throw null; }
        public virtual TResult? VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax node) { throw null; }
        public virtual TResult? VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax node) { throw null; }
        public virtual TResult? VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax node) { throw null; }
        public virtual TResult? VisitThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax node) { throw null; }
        public virtual TResult? VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax node) { throw null; }
        public virtual TResult? VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax node) { throw null; }
        public virtual TResult? VisitTupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax node) { throw null; }
        public virtual TResult? VisitTupleExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax node) { throw null; }
        public virtual TResult? VisitTupleType(Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax node) { throw null; }
        public virtual TResult? VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax node) { throw null; }
        public virtual TResult? VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax node) { throw null; }
        public virtual TResult? VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax node) { throw null; }
        public virtual TResult? VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax node) { throw null; }
        public virtual TResult? VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax node) { throw null; }
        public virtual TResult? VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }
        public virtual TResult? VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax node) { throw null; }
        public virtual TResult? VisitTypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax node) { throw null; }
        public virtual TResult? VisitUnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax node) { throw null; }
        public virtual TResult? VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax node) { throw null; }
        public virtual TResult? VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax node) { throw null; }
        public virtual TResult? VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax node) { throw null; }
        public virtual TResult? VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax node) { throw null; }
        public virtual TResult? VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax node) { throw null; }
        public virtual TResult? VisitVarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax node) { throw null; }
        public virtual TResult? VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax node) { throw null; }
        public virtual TResult? VisitWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax node) { throw null; }
        public virtual TResult? VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax node) { throw null; }
        public virtual TResult? VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax node) { throw null; }
        public virtual TResult? VisitWithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax node) { throw null; }
        public virtual TResult? VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax node) { throw null; }
        public virtual TResult? VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax node) { throw null; }
        public virtual TResult? VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax node) { throw null; }
        public virtual TResult? VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax node) { throw null; }
        public virtual TResult? VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax node) { throw null; }
        public virtual TResult? VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax node) { throw null; }
        public virtual TResult? VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax node) { throw null; }
        public virtual TResult? VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax node) { throw null; }
        public virtual TResult? VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax node) { throw null; }
        public virtual TResult? VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax node) { throw null; }
        public virtual TResult? VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax node) { throw null; }
        public virtual TResult? VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax node) { throw null; }
        public virtual TResult? VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax node) { throw null; }
        public virtual TResult? VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax node) { throw null; }
    }
    public abstract partial class CSharpSyntaxWalker : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor
    {
        protected CSharpSyntaxWalker(Microsoft.CodeAnalysis.SyntaxWalkerDepth depth = Microsoft.CodeAnalysis.SyntaxWalkerDepth.Node) { }
        protected Microsoft.CodeAnalysis.SyntaxWalkerDepth Depth { get { throw null; } }
        public override void DefaultVisit(Microsoft.CodeAnalysis.SyntaxNode node) { }
        public override void Visit(Microsoft.CodeAnalysis.SyntaxNode? node) { }
        public virtual void VisitLeadingTrivia(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitToken(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken token) { }
        public virtual void VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { }
    }
    public partial struct DeconstructionInfo
    {
        private object _dummy;
        private int _dummyPrimitive;
        public Microsoft.CodeAnalysis.CSharp.Conversion? Conversion { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? Method { get { throw null; } }
        public System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.CSharp.DeconstructionInfo> Nested { get { throw null; } }
    }
    public partial struct ForEachStatementInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public Microsoft.CodeAnalysis.CSharp.Conversion CurrentConversion { get { throw null; } }
        public Microsoft.CodeAnalysis.IPropertySymbol? CurrentProperty { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? DisposeMethod { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Conversion ElementConversion { get { throw null; } }
        public Microsoft.CodeAnalysis.ITypeSymbol? ElementType { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? GetEnumeratorMethod { get { throw null; } }
        public bool IsAsynchronous { get { throw null; } }
        public Microsoft.CodeAnalysis.IMethodSymbol? MoveNextMethod { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public enum LanguageVersion
    {
        Default = 0,
        CSharp1 = 1,
        CSharp2 = 2,
        CSharp3 = 3,
        CSharp4 = 4,
        CSharp5 = 5,
        CSharp6 = 6,
        CSharp7 = 7,
        CSharp7_1 = 701,
        CSharp7_2 = 702,
        CSharp7_3 = 703,
        CSharp8 = 800,
        CSharp9 = 900,
        CSharp10 = 1000,
        LatestMajor = 2147483645,
        Preview = 2147483646,
        Latest = 2147483647,
    }
    public static partial class LanguageVersionFacts
    {
        public static Microsoft.CodeAnalysis.CSharp.LanguageVersion MapSpecifiedToEffectiveVersion(this Microsoft.CodeAnalysis.CSharp.LanguageVersion version) { throw null; }
        public static string ToDisplayString(this Microsoft.CodeAnalysis.CSharp.LanguageVersion version) { throw null; }
        public static bool TryParse(string? version, out Microsoft.CodeAnalysis.CSharp.LanguageVersion result) { throw null; }
    }
    public partial struct QueryClauseInfo : System.IEquatable<Microsoft.CodeAnalysis.CSharp.QueryClauseInfo>
    {
        private object _dummy;
        private int _dummyPrimitive;
        public Microsoft.CodeAnalysis.SymbolInfo CastInfo { get { throw null; } }
        public Microsoft.CodeAnalysis.SymbolInfo OperationInfo { get { throw null; } }
        public bool Equals(Microsoft.CodeAnalysis.CSharp.QueryClauseInfo other) { throw null; }
        public override bool Equals(object? obj) { throw null; }
        public override int GetHashCode() { throw null; }
    }
    public static partial class SymbolDisplay
    {
        public static string FormatLiteral(char c, bool quote) { throw null; }
        public static string FormatLiteral(string value, bool quote) { throw null; }
        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToDisplayParts(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToDisplayParts(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableAnnotation nullableAnnotation, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToDisplayParts(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableFlowState nullableFlowState, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToDisplayString(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToDisplayString(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableAnnotation nullableAnnotation, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToDisplayString(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableFlowState nullableFlowState, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToMinimalDisplayParts(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToMinimalDisplayParts(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableAnnotation nullableAnnotation, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.SymbolDisplayPart> ToMinimalDisplayParts(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableFlowState nullableFlowState, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToMinimalDisplayString(Microsoft.CodeAnalysis.ISymbol symbol, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToMinimalDisplayString(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableAnnotation nullableAnnotation, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
        public static string ToMinimalDisplayString(Microsoft.CodeAnalysis.ITypeSymbol symbol, Microsoft.CodeAnalysis.NullableFlowState nullableFlowState, Microsoft.CodeAnalysis.SemanticModel semanticModel, int position, Microsoft.CodeAnalysis.SymbolDisplayFormat? format = null) { throw null; }
    }
    public static partial class SyntaxExtensions
    {
        public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxToken token, string indentation, bool elasticTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxToken token, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation, bool elasticTrivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList NormalizeWhitespace(this Microsoft.CodeAnalysis.SyntaxTriviaList list, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ToSyntaxTriviaList(this System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> sequence) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(this Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax syntax, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier(this Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax simpleName, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public static partial class SyntaxFactory
    {
        public static Microsoft.CodeAnalysis.SyntaxTrivia CarriageReturn { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia CarriageReturnLineFeed { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticCarriageReturn { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticCarriageReturnLineFeed { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticLineFeed { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticMarker { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticSpace { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticTab { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia LineFeed { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Space { get { throw null; } }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Tab { get { throw null; } }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors = default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AccessorList(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.SyntaxToken colonColonToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax AliasQualifiedName(string alias, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode? oldNode, Microsoft.CodeAnalysis.SyntaxNode? newNode, bool topLevel) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode? oldNode, Microsoft.CodeAnalysis.SyntaxNode? newNode, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool>? ignoreChildNode = null) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken oldToken, Microsoft.CodeAnalysis.SyntaxToken newToken) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxTokenList oldList, Microsoft.CodeAnalysis.SyntaxTokenList newList) { throw null; }
        public static bool AreEquivalent(Microsoft.CodeAnalysis.SyntaxTree? oldTree, Microsoft.CodeAnalysis.SyntaxTree? newTree, bool topLevel) { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> newList, bool topLevel) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> newList, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool>? ignoreChildNode = null) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SyntaxList<TNode> newList, bool topLevel) where TNode : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode { throw null; }
        public static bool AreEquivalent<TNode>(Microsoft.CodeAnalysis.SyntaxList<TNode> oldList, Microsoft.CodeAnalysis.SyntaxList<TNode> newList, System.Func<Microsoft.CodeAnalysis.CSharp.SyntaxKind, bool>? ignoreChildNode = null) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Argument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Argument(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.SyntaxToken refKindKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax? argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AttributeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AttributeArgumentList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax? target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AttributeList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax? target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax AwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax AwaitExpression(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken identifier, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken BadToken(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax BaseExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax BaseExpression(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax BaseList(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax BinaryPattern(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax BinaryPattern(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements = default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax BracketedArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax BracketedArgumentList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax BracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax BracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax CastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax CastExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax? filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax CatchClause(Microsoft.CodeAnalysis.SyntaxToken catchKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax? filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax CatchDeclaration(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax CatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax CatchFilterClause(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax ClassDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Comment(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken questionToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax ConstantPattern(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax ConstructorConstraint() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax ConstructorConstraint(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax? initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax? initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax CrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax CrefParameter(Microsoft.CodeAnalysis.SyntaxToken refKindKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax CrefParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax CrefParameterList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax DeclarationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax DeclarationPattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax DefaultConstraint() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax DefaultConstraint(Microsoft.CodeAnalysis.SyntaxToken defaultKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax DefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax DefaultExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken defineKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax DestructorDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia DisabledText(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax DiscardDesignation() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax DiscardDesignation(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax DiscardPattern() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax DiscardPattern(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationComment(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia DocumentationCommentExterior(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content = default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticEndOfLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia ElasticWhitespace(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax ElementBindingExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax ElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax ElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax ElseClause(Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endIfKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia EndOfLine(string text) { throw null; }
        [System.ObsoleteAttribute("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
        public static Microsoft.CodeAnalysis.SyntaxTrivia EndOfLine(string text, bool elastic) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken enumKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax EnumDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax equalsValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? equalsValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax EqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax EqualsValueClause(Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken errorKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax ExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken externKeyword, Microsoft.CodeAnalysis.SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax FinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax FinallyClause(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(Microsoft.CodeAnalysis.SyntaxToken fromKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(Microsoft.CodeAnalysis.SyntaxToken managedOrUnmanagedKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(Microsoft.CodeAnalysis.SyntaxToken managedOrUnmanagedKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax FunctionPointerParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax FunctionPointerParameterList(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax FunctionPointerType() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax FunctionPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax? callingConvention, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax FunctionPointerType(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.SyntaxToken asteriskToken, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax? callingConvention, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax FunctionPointerUnmanagedCallingConvention(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax GenericName(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? GetNonGenericExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GetStandaloneExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax GroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax GroupClause(Microsoft.CodeAnalysis.SyntaxToken groupKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.SyntaxToken byKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind contextualKind, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Identifier(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax IdentifierName(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax IdentifierName(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax ImplicitElementAccess() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax ImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax IndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax? parameters = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax IndexerMemberCref(Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents, Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax InterpolatedStringText() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax InterpolatedStringText(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax? alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax? formatClause) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Interpolation(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax? alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax? formatClause, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public static bool IsCompleteSubmission(Microsoft.CodeAnalysis.SyntaxTree tree) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax IsPatternExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken isKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax? into) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(Microsoft.CodeAnalysis.SyntaxToken joinKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.SyntaxToken onKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.SyntaxToken equalsKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax? into) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax JoinClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax JoinIntoClause(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax LabeledStatement(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(Microsoft.CodeAnalysis.SyntaxToken letKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax LetClause(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax LineDirectivePosition(Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken character) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax LineDirectivePosition(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.SyntaxToken character, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken line, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax start, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax end, Microsoft.CodeAnalysis.SyntaxToken characterOffset, Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax start, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax end, Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax start, Microsoft.CodeAnalysis.SyntaxToken minusToken, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax end, Microsoft.CodeAnalysis.SyntaxToken characterOffset, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> List<TNode>() where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> List<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, char value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, System.Decimal value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, double value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, int value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, long value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, float value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, uint value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, ulong value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(char value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(System.Decimal value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(double value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(int value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(long value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(float value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, char value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, System.Decimal value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, double value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, int value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, long value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, float value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, uint value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(string text, ulong value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(uint value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Literal(ulong value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken loadKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax MakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax MakeRefExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax MemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken MissingToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken MissingToken(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax NameColon(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax NameEquals(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList(params Microsoft.CodeAnalysis.SyntaxNodeOrToken[] nodesAndTokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxNodeOrTokenList NodeOrTokenList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesAndTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken nullableKeyword, Microsoft.CodeAnalysis.SyntaxToken settingToken, Microsoft.CodeAnalysis.SyntaxToken targetToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken settingToken, Microsoft.CodeAnalysis.SyntaxToken targetToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken settingToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax OrderByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax OrderByClause(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? @default) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax ParenthesizedPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax ParenthesizedPattern(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ParseArgumentList(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax ParseExpression(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax? ParseMemberDeclaration(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParseParameterList(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax ParseStatement(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.ParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.ParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText text, Microsoft.CodeAnalysis.ParseOptions? options = null, string path = "", System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(string text, Microsoft.CodeAnalysis.ParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }
        [System.ObsoleteAttribute("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(string text, Microsoft.CodeAnalysis.ParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, Microsoft.CodeAnalysis.ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree ParseSyntaxTree(string text, Microsoft.CodeAnalysis.ParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken)) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken ParseToken(string text, int offset = 0) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, Microsoft.CodeAnalysis.CSharp.CSharpParseOptions? options = null) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ParseTypeName(string text, int offset = 0, Microsoft.CodeAnalysis.ParseOptions? options = null, bool consumeFullText = true) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ParseTypeName(string text, int offset, bool consumeFullText) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax PositionalPatternClause(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax PositionalPatternClause(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken checksumKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax PredefinedType(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia PreprocessingMessage(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax PropertyPatternClause(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax PropertyPatternClause(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax? continuation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax QueryContinuation(string identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax QueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax RangeExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax RangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? leftOperand, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? rightOperand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax RangeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? leftOperand, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? rightOperand) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken keyword, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.SyntaxToken keyword, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax RecursivePattern() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax RecursivePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax? positionalPatternClause, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax? propertyPatternClause, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken referenceKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken file, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax RefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax RefExpression(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax RefType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax RefType(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax RefType(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.SyntaxToken readOnlyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax RefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax RefTypeExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax RefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax RefValueExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken comma, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken regionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax RelationalPattern(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax SelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax SelectClause(Microsoft.CodeAnalysis.SyntaxToken selectKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>() where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList nodesAndTokens) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken> nodesAndTokens) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>? separators) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken exclamationToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax SimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxList<TNode> SingletonList<TNode>(TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node) where TNode : Microsoft.CodeAnalysis.SyntaxNode { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax SingleVariableDesignation(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax SizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax SizeOfExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax StructDeclaration(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax Subpattern(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax? expressionColon, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax Subpattern(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax Subpattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax governingExpression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax governingExpression, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax> arms) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax SwitchExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax governingExpression, Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax> arms, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.SyntaxToken equalsGreaterThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax SwitchSection() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTree SyntaxTree(Microsoft.CodeAnalysis.SyntaxNode root, Microsoft.CodeAnalysis.ParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia SyntaxTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax ThisExpression() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax ThisExpression(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax ThrowExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax ThrowExpression(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken Token(Microsoft.CodeAnalysis.SyntaxTriviaList leading, Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(params Microsoft.CodeAnalysis.SyntaxToken[] tokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTokenList TokenList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> tokens) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Trivia(Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax node) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList() { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia trivia) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(params Microsoft.CodeAnalysis.SyntaxTrivia[] trivias) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTriviaList TriviaList(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia> trivias) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax? @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax? @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches = default(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax TupleElement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax TupleExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax TupleExpression(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax TupleType(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax TupleType(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax TypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax TypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributes, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax TypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax TypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax TypeOfExpression(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken varianceKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax TypeParameter(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters = default(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax>)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax TypeParameterList(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax TypePattern(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax UnaryPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax UnaryPattern(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken undefKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax UsingDirective(Microsoft.CodeAnalysis.SyntaxToken globalKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax? argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax VariableDeclarator(string identifier) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax VarPattern(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax VarPattern(Microsoft.CodeAnalysis.SyntaxToken varKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken VerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string valueText, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WhenClause(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WhereClause(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxTrivia Whitespace(string text) { throw null; }
        [System.ObsoleteAttribute("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
        public static Microsoft.CodeAnalysis.SyntaxTrivia Whitespace(string text, bool elastic) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken withKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax XmlCDataSection(Microsoft.CodeAnalysis.SyntaxToken startCDataToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax XmlCDataSection(Microsoft.CodeAnalysis.SyntaxTokenList textTokens = default(Microsoft.CodeAnalysis.SyntaxTokenList)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax XmlComment(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax XmlComment(Microsoft.CodeAnalysis.SyntaxTokenList textTokens = default(Microsoft.CodeAnalysis.SyntaxTokenList)) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlElement(string localName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax XmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax XmlElementEndTag(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax XmlElementStartTag(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlEmptyElement(string localName) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlEntity(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExampleElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExampleElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlExceptionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlMultiLineElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlMultiLineElement(string localName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax? prefix, Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax XmlName(string localName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, string identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax XmlNameAttribute(string parameterName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlNewLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlNullKeywordElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParaElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParaElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParamElement(string parameterName, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlParamElement(string parameterName, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlParamRefElement(string parameterName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPermissionElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPlaceholderElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlPlaceholderElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax XmlPrefix(string prefix) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlPreliminaryElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlRemarksElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlRemarksElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlReturnsElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlReturnsElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlSeeAlsoElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSeeAlsoElement(System.Uri linkAddress, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> linkText) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlSeeElement(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSummaryElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlSummaryElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(params Microsoft.CodeAnalysis.SyntaxToken[] textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax XmlText(string value) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, Microsoft.CodeAnalysis.CSharp.SyntaxKind quoteKind, Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, params Microsoft.CodeAnalysis.SyntaxToken[] textTokens) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextLiteral(string text, string value) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(Microsoft.CodeAnalysis.SyntaxTriviaList leading, string text, string value, Microsoft.CodeAnalysis.SyntaxTriviaList trailing) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(string text) { throw null; }
        public static Microsoft.CodeAnalysis.SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlValueElement(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax XmlValueElement(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression = null) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind, Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public static partial class SyntaxFacts
    {
        public static System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.CSharp.SyntaxKind> EqualityComparer { get { throw null; } }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetAccessorDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetAssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetBaseTypeDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetBinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetCheckStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetContextualKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetContextualKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetInstanceExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetLiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetOperatorKind(string operatorMetadataName) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPreprocessorKeywordKind(string text) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetPreprocessorKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetPrimaryFunction(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetPunctuationKinds() { throw null; }
        public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.CSharp.SyntaxKind> GetReservedKeywordKinds() { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetSwitchLabelKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static string GetText(Microsoft.CodeAnalysis.Accessibility accessibility) { throw null; }
        public static string GetText(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static Microsoft.CodeAnalysis.CSharp.SyntaxKind GetTypeDeclarationKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessibilityModifier(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAccessorDeclarationKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static bool IsAliasQualifier(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsAnyOverloadableOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAnyToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAnyUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsAssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsAssignmentExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsAttributeName(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsBinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsBinaryExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsFixedStatementExpression(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsGlobalMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsIdentifierPartCharacter(char ch) { throw null; }
        public static bool IsIdentifierStartCharacter(char ch) { throw null; }
        public static bool IsIndexed(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsInNamespaceOrTypeContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? node) { throw null; }
        public static bool IsInstanceExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsInTypeOnlyContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsInvoked(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsKeywordKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        [System.ObsoleteAttribute("IsLambdaBody API is obsolete", true)]
        public static bool IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsLanguagePunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsLiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsName(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsNamedArgumentName(Microsoft.CodeAnalysis.SyntaxNode node) { throw null; }
        public static bool IsNamespaceAliasQualifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax node) { throw null; }
        public static bool IsNamespaceMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsNewLine(char ch) { throw null; }
        public static bool IsOverloadableBinaryOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsOverloadableUnaryOperator(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPostfixUnaryExpressionToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPredefinedType(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPrefixUnaryExpressionOperatorToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsPreprocessorDirective(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPreprocessorKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPreprocessorPunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPrimaryFunction(Microsoft.CodeAnalysis.CSharp.SyntaxKind keyword) { throw null; }
        public static bool IsPunctuation(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsPunctuationOrKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsQueryContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsReservedKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsReservedTupleElementName(string elementName) { throw null; }
        public static bool IsTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeParameterVarianceKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsTypeSyntax(Microsoft.CodeAnalysis.CSharp.SyntaxKind kind) { throw null; }
        public static bool IsUnaryOperatorDeclarationToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind token) { throw null; }
        public static bool IsValidIdentifier(string? name) { throw null; }
        public static bool IsWhitespace(char ch) { throw null; }
        public static string? TryGetInferredMemberName(this Microsoft.CodeAnalysis.SyntaxNode syntax) { throw null; }
    }
    public enum SyntaxKind : ushort
    {
        None = (ushort)0,
        List = (ushort)1,
        TildeToken = (ushort)8193,
        ExclamationToken = (ushort)8194,
        DollarToken = (ushort)8195,
        PercentToken = (ushort)8196,
        CaretToken = (ushort)8197,
        AmpersandToken = (ushort)8198,
        AsteriskToken = (ushort)8199,
        OpenParenToken = (ushort)8200,
        CloseParenToken = (ushort)8201,
        MinusToken = (ushort)8202,
        PlusToken = (ushort)8203,
        EqualsToken = (ushort)8204,
        OpenBraceToken = (ushort)8205,
        CloseBraceToken = (ushort)8206,
        OpenBracketToken = (ushort)8207,
        CloseBracketToken = (ushort)8208,
        BarToken = (ushort)8209,
        BackslashToken = (ushort)8210,
        ColonToken = (ushort)8211,
        SemicolonToken = (ushort)8212,
        DoubleQuoteToken = (ushort)8213,
        SingleQuoteToken = (ushort)8214,
        LessThanToken = (ushort)8215,
        CommaToken = (ushort)8216,
        GreaterThanToken = (ushort)8217,
        DotToken = (ushort)8218,
        QuestionToken = (ushort)8219,
        HashToken = (ushort)8220,
        SlashToken = (ushort)8221,
        DotDotToken = (ushort)8222,
        SlashGreaterThanToken = (ushort)8232,
        LessThanSlashToken = (ushort)8233,
        XmlCommentStartToken = (ushort)8234,
        XmlCommentEndToken = (ushort)8235,
        XmlCDataStartToken = (ushort)8236,
        XmlCDataEndToken = (ushort)8237,
        XmlProcessingInstructionStartToken = (ushort)8238,
        XmlProcessingInstructionEndToken = (ushort)8239,
        BarBarToken = (ushort)8260,
        AmpersandAmpersandToken = (ushort)8261,
        MinusMinusToken = (ushort)8262,
        PlusPlusToken = (ushort)8263,
        ColonColonToken = (ushort)8264,
        QuestionQuestionToken = (ushort)8265,
        MinusGreaterThanToken = (ushort)8266,
        ExclamationEqualsToken = (ushort)8267,
        EqualsEqualsToken = (ushort)8268,
        EqualsGreaterThanToken = (ushort)8269,
        LessThanEqualsToken = (ushort)8270,
        LessThanLessThanToken = (ushort)8271,
        LessThanLessThanEqualsToken = (ushort)8272,
        GreaterThanEqualsToken = (ushort)8273,
        GreaterThanGreaterThanToken = (ushort)8274,
        GreaterThanGreaterThanEqualsToken = (ushort)8275,
        SlashEqualsToken = (ushort)8276,
        AsteriskEqualsToken = (ushort)8277,
        BarEqualsToken = (ushort)8278,
        AmpersandEqualsToken = (ushort)8279,
        PlusEqualsToken = (ushort)8280,
        MinusEqualsToken = (ushort)8281,
        CaretEqualsToken = (ushort)8282,
        PercentEqualsToken = (ushort)8283,
        QuestionQuestionEqualsToken = (ushort)8284,
        BoolKeyword = (ushort)8304,
        ByteKeyword = (ushort)8305,
        SByteKeyword = (ushort)8306,
        ShortKeyword = (ushort)8307,
        UShortKeyword = (ushort)8308,
        IntKeyword = (ushort)8309,
        UIntKeyword = (ushort)8310,
        LongKeyword = (ushort)8311,
        ULongKeyword = (ushort)8312,
        DoubleKeyword = (ushort)8313,
        FloatKeyword = (ushort)8314,
        DecimalKeyword = (ushort)8315,
        StringKeyword = (ushort)8316,
        CharKeyword = (ushort)8317,
        VoidKeyword = (ushort)8318,
        ObjectKeyword = (ushort)8319,
        TypeOfKeyword = (ushort)8320,
        SizeOfKeyword = (ushort)8321,
        NullKeyword = (ushort)8322,
        TrueKeyword = (ushort)8323,
        FalseKeyword = (ushort)8324,
        IfKeyword = (ushort)8325,
        ElseKeyword = (ushort)8326,
        WhileKeyword = (ushort)8327,
        ForKeyword = (ushort)8328,
        ForEachKeyword = (ushort)8329,
        DoKeyword = (ushort)8330,
        SwitchKeyword = (ushort)8331,
        CaseKeyword = (ushort)8332,
        DefaultKeyword = (ushort)8333,
        TryKeyword = (ushort)8334,
        CatchKeyword = (ushort)8335,
        FinallyKeyword = (ushort)8336,
        LockKeyword = (ushort)8337,
        GotoKeyword = (ushort)8338,
        BreakKeyword = (ushort)8339,
        ContinueKeyword = (ushort)8340,
        ReturnKeyword = (ushort)8341,
        ThrowKeyword = (ushort)8342,
        PublicKeyword = (ushort)8343,
        PrivateKeyword = (ushort)8344,
        InternalKeyword = (ushort)8345,
        ProtectedKeyword = (ushort)8346,
        StaticKeyword = (ushort)8347,
        ReadOnlyKeyword = (ushort)8348,
        SealedKeyword = (ushort)8349,
        ConstKeyword = (ushort)8350,
        FixedKeyword = (ushort)8351,
        StackAllocKeyword = (ushort)8352,
        VolatileKeyword = (ushort)8353,
        NewKeyword = (ushort)8354,
        OverrideKeyword = (ushort)8355,
        AbstractKeyword = (ushort)8356,
        VirtualKeyword = (ushort)8357,
        EventKeyword = (ushort)8358,
        ExternKeyword = (ushort)8359,
        RefKeyword = (ushort)8360,
        OutKeyword = (ushort)8361,
        InKeyword = (ushort)8362,
        IsKeyword = (ushort)8363,
        AsKeyword = (ushort)8364,
        ParamsKeyword = (ushort)8365,
        ArgListKeyword = (ushort)8366,
        MakeRefKeyword = (ushort)8367,
        RefTypeKeyword = (ushort)8368,
        RefValueKeyword = (ushort)8369,
        ThisKeyword = (ushort)8370,
        BaseKeyword = (ushort)8371,
        NamespaceKeyword = (ushort)8372,
        UsingKeyword = (ushort)8373,
        ClassKeyword = (ushort)8374,
        StructKeyword = (ushort)8375,
        InterfaceKeyword = (ushort)8376,
        EnumKeyword = (ushort)8377,
        DelegateKeyword = (ushort)8378,
        CheckedKeyword = (ushort)8379,
        UncheckedKeyword = (ushort)8380,
        UnsafeKeyword = (ushort)8381,
        OperatorKeyword = (ushort)8382,
        ExplicitKeyword = (ushort)8383,
        ImplicitKeyword = (ushort)8384,
        YieldKeyword = (ushort)8405,
        PartialKeyword = (ushort)8406,
        AliasKeyword = (ushort)8407,
        GlobalKeyword = (ushort)8408,
        AssemblyKeyword = (ushort)8409,
        ModuleKeyword = (ushort)8410,
        TypeKeyword = (ushort)8411,
        FieldKeyword = (ushort)8412,
        MethodKeyword = (ushort)8413,
        ParamKeyword = (ushort)8414,
        PropertyKeyword = (ushort)8415,
        TypeVarKeyword = (ushort)8416,
        GetKeyword = (ushort)8417,
        SetKeyword = (ushort)8418,
        AddKeyword = (ushort)8419,
        RemoveKeyword = (ushort)8420,
        WhereKeyword = (ushort)8421,
        FromKeyword = (ushort)8422,
        GroupKeyword = (ushort)8423,
        JoinKeyword = (ushort)8424,
        IntoKeyword = (ushort)8425,
        LetKeyword = (ushort)8426,
        ByKeyword = (ushort)8427,
        SelectKeyword = (ushort)8428,
        OrderByKeyword = (ushort)8429,
        OnKeyword = (ushort)8430,
        EqualsKeyword = (ushort)8431,
        AscendingKeyword = (ushort)8432,
        DescendingKeyword = (ushort)8433,
        NameOfKeyword = (ushort)8434,
        AsyncKeyword = (ushort)8435,
        AwaitKeyword = (ushort)8436,
        WhenKeyword = (ushort)8437,
        OrKeyword = (ushort)8438,
        AndKeyword = (ushort)8439,
        NotKeyword = (ushort)8440,
        WithKeyword = (ushort)8442,
        InitKeyword = (ushort)8443,
        RecordKeyword = (ushort)8444,
        ManagedKeyword = (ushort)8445,
        UnmanagedKeyword = (ushort)8446,
        ElifKeyword = (ushort)8467,
        EndIfKeyword = (ushort)8468,
        RegionKeyword = (ushort)8469,
        EndRegionKeyword = (ushort)8470,
        DefineKeyword = (ushort)8471,
        UndefKeyword = (ushort)8472,
        WarningKeyword = (ushort)8473,
        ErrorKeyword = (ushort)8474,
        LineKeyword = (ushort)8475,
        PragmaKeyword = (ushort)8476,
        HiddenKeyword = (ushort)8477,
        ChecksumKeyword = (ushort)8478,
        DisableKeyword = (ushort)8479,
        RestoreKeyword = (ushort)8480,
        ReferenceKeyword = (ushort)8481,
        InterpolatedStringStartToken = (ushort)8482,
        InterpolatedStringEndToken = (ushort)8483,
        InterpolatedVerbatimStringStartToken = (ushort)8484,
        LoadKeyword = (ushort)8485,
        NullableKeyword = (ushort)8486,
        EnableKeyword = (ushort)8487,
        WarningsKeyword = (ushort)8488,
        AnnotationsKeyword = (ushort)8489,
        VarKeyword = (ushort)8490,
        UnderscoreToken = (ushort)8491,
        OmittedTypeArgumentToken = (ushort)8492,
        OmittedArraySizeExpressionToken = (ushort)8493,
        EndOfDirectiveToken = (ushort)8494,
        EndOfDocumentationCommentToken = (ushort)8495,
        EndOfFileToken = (ushort)8496,
        BadToken = (ushort)8507,
        IdentifierToken = (ushort)8508,
        NumericLiteralToken = (ushort)8509,
        CharacterLiteralToken = (ushort)8510,
        StringLiteralToken = (ushort)8511,
        XmlEntityLiteralToken = (ushort)8512,
        XmlTextLiteralToken = (ushort)8513,
        XmlTextLiteralNewLineToken = (ushort)8514,
        InterpolatedStringToken = (ushort)8515,
        InterpolatedStringTextToken = (ushort)8517,
        EndOfLineTrivia = (ushort)8539,
        WhitespaceTrivia = (ushort)8540,
        SingleLineCommentTrivia = (ushort)8541,
        MultiLineCommentTrivia = (ushort)8542,
        DocumentationCommentExteriorTrivia = (ushort)8543,
        SingleLineDocumentationCommentTrivia = (ushort)8544,
        MultiLineDocumentationCommentTrivia = (ushort)8545,
        DisabledTextTrivia = (ushort)8546,
        PreprocessingMessageTrivia = (ushort)8547,
        IfDirectiveTrivia = (ushort)8548,
        ElifDirectiveTrivia = (ushort)8549,
        ElseDirectiveTrivia = (ushort)8550,
        EndIfDirectiveTrivia = (ushort)8551,
        RegionDirectiveTrivia = (ushort)8552,
        EndRegionDirectiveTrivia = (ushort)8553,
        DefineDirectiveTrivia = (ushort)8554,
        UndefDirectiveTrivia = (ushort)8555,
        ErrorDirectiveTrivia = (ushort)8556,
        WarningDirectiveTrivia = (ushort)8557,
        LineDirectiveTrivia = (ushort)8558,
        PragmaWarningDirectiveTrivia = (ushort)8559,
        PragmaChecksumDirectiveTrivia = (ushort)8560,
        ReferenceDirectiveTrivia = (ushort)8561,
        BadDirectiveTrivia = (ushort)8562,
        SkippedTokensTrivia = (ushort)8563,
        ConflictMarkerTrivia = (ushort)8564,
        XmlElement = (ushort)8574,
        XmlElementStartTag = (ushort)8575,
        XmlElementEndTag = (ushort)8576,
        XmlEmptyElement = (ushort)8577,
        XmlTextAttribute = (ushort)8578,
        XmlCrefAttribute = (ushort)8579,
        XmlNameAttribute = (ushort)8580,
        XmlName = (ushort)8581,
        XmlPrefix = (ushort)8582,
        XmlText = (ushort)8583,
        XmlCDataSection = (ushort)8584,
        XmlComment = (ushort)8585,
        XmlProcessingInstruction = (ushort)8586,
        TypeCref = (ushort)8597,
        QualifiedCref = (ushort)8598,
        NameMemberCref = (ushort)8599,
        IndexerMemberCref = (ushort)8600,
        OperatorMemberCref = (ushort)8601,
        ConversionOperatorMemberCref = (ushort)8602,
        CrefParameterList = (ushort)8603,
        CrefBracketedParameterList = (ushort)8604,
        CrefParameter = (ushort)8605,
        IdentifierName = (ushort)8616,
        QualifiedName = (ushort)8617,
        GenericName = (ushort)8618,
        TypeArgumentList = (ushort)8619,
        AliasQualifiedName = (ushort)8620,
        PredefinedType = (ushort)8621,
        ArrayType = (ushort)8622,
        ArrayRankSpecifier = (ushort)8623,
        PointerType = (ushort)8624,
        NullableType = (ushort)8625,
        OmittedTypeArgument = (ushort)8626,
        ParenthesizedExpression = (ushort)8632,
        ConditionalExpression = (ushort)8633,
        InvocationExpression = (ushort)8634,
        ElementAccessExpression = (ushort)8635,
        ArgumentList = (ushort)8636,
        BracketedArgumentList = (ushort)8637,
        Argument = (ushort)8638,
        NameColon = (ushort)8639,
        CastExpression = (ushort)8640,
        AnonymousMethodExpression = (ushort)8641,
        SimpleLambdaExpression = (ushort)8642,
        ParenthesizedLambdaExpression = (ushort)8643,
        ObjectInitializerExpression = (ushort)8644,
        CollectionInitializerExpression = (ushort)8645,
        ArrayInitializerExpression = (ushort)8646,
        AnonymousObjectMemberDeclarator = (ushort)8647,
        ComplexElementInitializerExpression = (ushort)8648,
        ObjectCreationExpression = (ushort)8649,
        AnonymousObjectCreationExpression = (ushort)8650,
        ArrayCreationExpression = (ushort)8651,
        ImplicitArrayCreationExpression = (ushort)8652,
        StackAllocArrayCreationExpression = (ushort)8653,
        OmittedArraySizeExpression = (ushort)8654,
        InterpolatedStringExpression = (ushort)8655,
        ImplicitElementAccess = (ushort)8656,
        IsPatternExpression = (ushort)8657,
        RangeExpression = (ushort)8658,
        ImplicitObjectCreationExpression = (ushort)8659,
        AddExpression = (ushort)8668,
        SubtractExpression = (ushort)8669,
        MultiplyExpression = (ushort)8670,
        DivideExpression = (ushort)8671,
        ModuloExpression = (ushort)8672,
        LeftShiftExpression = (ushort)8673,
        RightShiftExpression = (ushort)8674,
        LogicalOrExpression = (ushort)8675,
        LogicalAndExpression = (ushort)8676,
        BitwiseOrExpression = (ushort)8677,
        BitwiseAndExpression = (ushort)8678,
        ExclusiveOrExpression = (ushort)8679,
        EqualsExpression = (ushort)8680,
        NotEqualsExpression = (ushort)8681,
        LessThanExpression = (ushort)8682,
        LessThanOrEqualExpression = (ushort)8683,
        GreaterThanExpression = (ushort)8684,
        GreaterThanOrEqualExpression = (ushort)8685,
        IsExpression = (ushort)8686,
        AsExpression = (ushort)8687,
        CoalesceExpression = (ushort)8688,
        SimpleMemberAccessExpression = (ushort)8689,
        PointerMemberAccessExpression = (ushort)8690,
        ConditionalAccessExpression = (ushort)8691,
        MemberBindingExpression = (ushort)8707,
        ElementBindingExpression = (ushort)8708,
        SimpleAssignmentExpression = (ushort)8714,
        AddAssignmentExpression = (ushort)8715,
        SubtractAssignmentExpression = (ushort)8716,
        MultiplyAssignmentExpression = (ushort)8717,
        DivideAssignmentExpression = (ushort)8718,
        ModuloAssignmentExpression = (ushort)8719,
        AndAssignmentExpression = (ushort)8720,
        ExclusiveOrAssignmentExpression = (ushort)8721,
        OrAssignmentExpression = (ushort)8722,
        LeftShiftAssignmentExpression = (ushort)8723,
        RightShiftAssignmentExpression = (ushort)8724,
        CoalesceAssignmentExpression = (ushort)8725,
        UnaryPlusExpression = (ushort)8730,
        UnaryMinusExpression = (ushort)8731,
        BitwiseNotExpression = (ushort)8732,
        LogicalNotExpression = (ushort)8733,
        PreIncrementExpression = (ushort)8734,
        PreDecrementExpression = (ushort)8735,
        PointerIndirectionExpression = (ushort)8736,
        AddressOfExpression = (ushort)8737,
        PostIncrementExpression = (ushort)8738,
        PostDecrementExpression = (ushort)8739,
        AwaitExpression = (ushort)8740,
        IndexExpression = (ushort)8741,
        ThisExpression = (ushort)8746,
        BaseExpression = (ushort)8747,
        ArgListExpression = (ushort)8748,
        NumericLiteralExpression = (ushort)8749,
        StringLiteralExpression = (ushort)8750,
        CharacterLiteralExpression = (ushort)8751,
        TrueLiteralExpression = (ushort)8752,
        FalseLiteralExpression = (ushort)8753,
        NullLiteralExpression = (ushort)8754,
        DefaultLiteralExpression = (ushort)8755,
        TypeOfExpression = (ushort)8760,
        SizeOfExpression = (ushort)8761,
        CheckedExpression = (ushort)8762,
        UncheckedExpression = (ushort)8763,
        DefaultExpression = (ushort)8764,
        MakeRefExpression = (ushort)8765,
        RefValueExpression = (ushort)8766,
        RefTypeExpression = (ushort)8767,
        QueryExpression = (ushort)8774,
        QueryBody = (ushort)8775,
        FromClause = (ushort)8776,
        LetClause = (ushort)8777,
        JoinClause = (ushort)8778,
        JoinIntoClause = (ushort)8779,
        WhereClause = (ushort)8780,
        OrderByClause = (ushort)8781,
        AscendingOrdering = (ushort)8782,
        DescendingOrdering = (ushort)8783,
        SelectClause = (ushort)8784,
        GroupClause = (ushort)8785,
        QueryContinuation = (ushort)8786,
        Block = (ushort)8792,
        LocalDeclarationStatement = (ushort)8793,
        VariableDeclaration = (ushort)8794,
        VariableDeclarator = (ushort)8795,
        EqualsValueClause = (ushort)8796,
        ExpressionStatement = (ushort)8797,
        EmptyStatement = (ushort)8798,
        LabeledStatement = (ushort)8799,
        GotoStatement = (ushort)8800,
        GotoCaseStatement = (ushort)8801,
        GotoDefaultStatement = (ushort)8802,
        BreakStatement = (ushort)8803,
        ContinueStatement = (ushort)8804,
        ReturnStatement = (ushort)8805,
        YieldReturnStatement = (ushort)8806,
        YieldBreakStatement = (ushort)8807,
        ThrowStatement = (ushort)8808,
        WhileStatement = (ushort)8809,
        DoStatement = (ushort)8810,
        ForStatement = (ushort)8811,
        ForEachStatement = (ushort)8812,
        UsingStatement = (ushort)8813,
        FixedStatement = (ushort)8814,
        CheckedStatement = (ushort)8815,
        UncheckedStatement = (ushort)8816,
        UnsafeStatement = (ushort)8817,
        LockStatement = (ushort)8818,
        IfStatement = (ushort)8819,
        ElseClause = (ushort)8820,
        SwitchStatement = (ushort)8821,
        SwitchSection = (ushort)8822,
        CaseSwitchLabel = (ushort)8823,
        DefaultSwitchLabel = (ushort)8824,
        TryStatement = (ushort)8825,
        CatchClause = (ushort)8826,
        CatchDeclaration = (ushort)8827,
        CatchFilterClause = (ushort)8828,
        FinallyClause = (ushort)8829,
        LocalFunctionStatement = (ushort)8830,
        CompilationUnit = (ushort)8840,
        GlobalStatement = (ushort)8841,
        NamespaceDeclaration = (ushort)8842,
        UsingDirective = (ushort)8843,
        ExternAliasDirective = (ushort)8844,
        FileScopedNamespaceDeclaration = (ushort)8845,
        AttributeList = (ushort)8847,
        AttributeTargetSpecifier = (ushort)8848,
        Attribute = (ushort)8849,
        AttributeArgumentList = (ushort)8850,
        AttributeArgument = (ushort)8851,
        NameEquals = (ushort)8852,
        ClassDeclaration = (ushort)8855,
        StructDeclaration = (ushort)8856,
        InterfaceDeclaration = (ushort)8857,
        EnumDeclaration = (ushort)8858,
        DelegateDeclaration = (ushort)8859,
        BaseList = (ushort)8864,
        SimpleBaseType = (ushort)8865,
        TypeParameterConstraintClause = (ushort)8866,
        ConstructorConstraint = (ushort)8867,
        ClassConstraint = (ushort)8868,
        StructConstraint = (ushort)8869,
        TypeConstraint = (ushort)8870,
        ExplicitInterfaceSpecifier = (ushort)8871,
        EnumMemberDeclaration = (ushort)8872,
        FieldDeclaration = (ushort)8873,
        EventFieldDeclaration = (ushort)8874,
        MethodDeclaration = (ushort)8875,
        OperatorDeclaration = (ushort)8876,
        ConversionOperatorDeclaration = (ushort)8877,
        ConstructorDeclaration = (ushort)8878,
        BaseConstructorInitializer = (ushort)8889,
        ThisConstructorInitializer = (ushort)8890,
        DestructorDeclaration = (ushort)8891,
        PropertyDeclaration = (ushort)8892,
        EventDeclaration = (ushort)8893,
        IndexerDeclaration = (ushort)8894,
        AccessorList = (ushort)8895,
        GetAccessorDeclaration = (ushort)8896,
        SetAccessorDeclaration = (ushort)8897,
        AddAccessorDeclaration = (ushort)8898,
        RemoveAccessorDeclaration = (ushort)8899,
        UnknownAccessorDeclaration = (ushort)8900,
        ParameterList = (ushort)8906,
        BracketedParameterList = (ushort)8907,
        Parameter = (ushort)8908,
        TypeParameterList = (ushort)8909,
        TypeParameter = (ushort)8910,
        IncompleteMember = (ushort)8916,
        ArrowExpressionClause = (ushort)8917,
        Interpolation = (ushort)8918,
        InterpolatedStringText = (ushort)8919,
        InterpolationAlignmentClause = (ushort)8920,
        InterpolationFormatClause = (ushort)8921,
        ShebangDirectiveTrivia = (ushort)8922,
        LoadDirectiveTrivia = (ushort)8923,
        TupleType = (ushort)8924,
        TupleElement = (ushort)8925,
        TupleExpression = (ushort)8926,
        SingleVariableDesignation = (ushort)8927,
        ParenthesizedVariableDesignation = (ushort)8928,
        ForEachVariableStatement = (ushort)8929,
        DeclarationPattern = (ushort)9000,
        ConstantPattern = (ushort)9002,
        CasePatternSwitchLabel = (ushort)9009,
        WhenClause = (ushort)9013,
        DiscardDesignation = (ushort)9014,
        RecursivePattern = (ushort)9020,
        PropertyPatternClause = (ushort)9021,
        Subpattern = (ushort)9022,
        PositionalPatternClause = (ushort)9023,
        DiscardPattern = (ushort)9024,
        SwitchExpression = (ushort)9025,
        SwitchExpressionArm = (ushort)9026,
        VarPattern = (ushort)9027,
        ParenthesizedPattern = (ushort)9028,
        RelationalPattern = (ushort)9029,
        TypePattern = (ushort)9030,
        OrPattern = (ushort)9031,
        AndPattern = (ushort)9032,
        NotPattern = (ushort)9033,
        DeclarationExpression = (ushort)9040,
        RefExpression = (ushort)9050,
        RefType = (ushort)9051,
        ThrowExpression = (ushort)9052,
        ImplicitStackAllocArrayCreationExpression = (ushort)9053,
        SuppressNullableWarningExpression = (ushort)9054,
        NullableDirectiveTrivia = (ushort)9055,
        FunctionPointerType = (ushort)9056,
        FunctionPointerParameter = (ushort)9057,
        FunctionPointerParameterList = (ushort)9058,
        FunctionPointerCallingConvention = (ushort)9059,
        InitAccessorDeclaration = (ushort)9060,
        WithExpression = (ushort)9061,
        WithInitializerExpression = (ushort)9062,
        RecordDeclaration = (ushort)9063,
        DefaultConstraint = (ushort)9064,
        PrimaryConstructorBaseType = (ushort)9065,
        FunctionPointerUnmanagedCallingConventionList = (ushort)9066,
        FunctionPointerUnmanagedCallingConvention = (ushort)9067,
        RecordStructDeclaration = (ushort)9068,
        ExpressionColon = (ushort)9069,
        LineDirectivePosition = (ushort)9070,
        LineSpanDirectiveTrivia = (ushort)9071,
    }
    public static partial class TypedConstantExtensions
    {
        public static string ToCSharpString(this Microsoft.CodeAnalysis.TypedConstant constant) { throw null; }
    }
}
namespace Microsoft.CodeAnalysis.CSharp.Syntax
{
    public sealed partial class AccessorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AccessorDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class AccessorListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AccessorListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> Accessors { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax AddAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithAccessors(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax> accessors) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class AliasQualifiedNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal AliasQualifiedNameSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Alias { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ColonColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias, Microsoft.CodeAnalysis.SyntaxToken colonColonToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithAlias(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax alias) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithColonColonToken(Microsoft.CodeAnalysis.SyntaxToken colonColonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
    }
    public abstract partial class AnonymousFunctionExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AnonymousFunctionExpressionSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Block { get; }
        public Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode Body { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? ExpressionBody { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
    }
    public sealed partial class AnonymousMethodExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax
    {
        internal AnonymousMethodExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DelegateKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? ParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList) { throw null; }
    }
    public sealed partial class AnonymousObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AnonymousObjectCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> Initializers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax AddInitializers(params Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class AnonymousObjectMemberDeclaratorSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AnonymousObjectMemberDeclaratorSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? NameEquals { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax WithNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals) { throw null; }
    }
    public sealed partial class ArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax
    {
        internal ArgumentListSyntax() { }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ArgumentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArgumentSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? NameColon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefKindKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefOrOutKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.SyntaxToken refKindKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithRefKindKeyword(Microsoft.CodeAnalysis.SyntaxToken refKindKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword) { throw null; }
    }
    public sealed partial class ArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax type) { throw null; }
    }
    public sealed partial class ArrayRankSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArrayRankSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public int Rank { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Sizes { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax AddSizes(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax WithSizes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> sizes) { throw null; }
    }
    public sealed partial class ArrayTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal ArrayTypeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> RankSpecifiers { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax AddRankSpecifiers(params Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax WithRankSpecifiers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
    }
    public sealed partial class ArrowExpressionClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ArrowExpressionClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class AssignmentExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AssignmentExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
    }
    public sealed partial class AttributeArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeArgumentListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class AttributeArgumentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeArgumentSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? NameColon { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? NameEquals { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals, Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax WithNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? nameEquals) { throw null; }
    }
    public sealed partial class AttributeListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax? Target { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax? target, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithAttributes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax WithTarget(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax? target) { throw null; }
    }
    public sealed partial class AttributeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax? ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax? argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax? argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
    }
    public sealed partial class AttributeTargetSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal AttributeTargetSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class AwaitExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal AwaitExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class BadDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal BadDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public abstract partial class BaseArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseArgumentListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
    }
    public abstract partial class BaseCrefParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseCrefParameterListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters) { throw null; }
    }
    public abstract partial class BaseExpressionColonSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseExpressionColonSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ColonToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class BaseExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax
    {
        internal BaseExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public abstract partial class BaseFieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseFieldDeclarationSyntax() { }
        public abstract override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get; }
        public abstract override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class BaseListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> Types { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax AddTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax WithTypes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax> types) { throw null; }
    }
    public abstract partial class BaseMethodDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseMethodDeclarationSyntax() { }
        public abstract override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get; }
        public abstract override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public abstract partial class BaseNamespaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseNamespaceDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken NamespaceKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public abstract partial class BaseObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal BaseObjectCreationExpressionSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? ArgumentList { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? Initializer { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
    }
    public abstract partial class BaseParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseParameterListSyntax() { }
        public abstract Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters) { throw null; }
    }
    public abstract partial class BaseParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseParameterSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public abstract partial class BasePropertyDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BasePropertyDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? AccessorList { get; }
        public abstract override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get; }
        public abstract override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class BaseTypeDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal BaseTypeDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Identifier { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public abstract partial class BaseTypeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal BaseTypeSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class BinaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal BinaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax right) { throw null; }
    }
    public sealed partial class BinaryPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal BinaryPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax left, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BinaryPatternSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax right) { throw null; }
    }
    public sealed partial class BlockSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal BlockSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> Statements { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax AddStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax WithStatements(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
    }
    public sealed partial class BracketedArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax
    {
        internal BracketedArgumentListSyntax() { }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
    }
    public sealed partial class BracketedParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax
    {
        internal BracketedParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters) { throw null; }
    }
    public abstract partial class BranchingDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal BranchingDirectiveTriviaSyntax() { }
        public abstract bool BranchTaken { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
    }
    public sealed partial class BreakStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal BreakStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken BreakKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken breakKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax WithBreakKeyword(Microsoft.CodeAnalysis.SyntaxToken breakKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class CasePatternSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal CasePatternSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? WhenClause { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CasePatternSwitchLabelSyntax WithWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause) { throw null; }
    }
    public sealed partial class CaseSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal CaseSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class CastExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal CastExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CatchClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CatchKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax? Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax? Filter { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken catchKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax? filter, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithCatchKeyword(Microsoft.CodeAnalysis.SyntaxToken catchKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax? declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax WithFilter(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax? filter) { throw null; }
    }
    public sealed partial class CatchDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CatchFilterClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CatchFilterClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax FilterExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhenKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithFilterExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax filterExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax WithWhenKeyword(Microsoft.CodeAnalysis.SyntaxToken whenKeyword) { throw null; }
    }
    public sealed partial class CheckedExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal CheckedExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class CheckedStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal CheckedStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class ClassDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal ClassDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class ClassOrStructConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal ClassOrStructConstraintSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ClassOrStructKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken QuestionToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax WithClassOrStructKeyword(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
    }
    public abstract partial class CommonForEachStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal CommonForEachStatementSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken InKeyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithForEachKeyword(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class CompilationUnitSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.ICompilationUnitSyntax
    {
        internal CompilationUnitSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndOfFileToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public System.Collections.Generic.IList<Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax> GetLoadDirectives() { throw null; }
        public System.Collections.Generic.IList<Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax> GetReferenceDirectives() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithEndOfFileToken(Microsoft.CodeAnalysis.SyntaxToken endOfFileToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public sealed partial class ConditionalAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ConditionalAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenNotNull { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax WithWhenNotNull(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenNotNull) { throw null; }
    }
    public abstract partial class ConditionalDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax
    {
        internal ConditionalDirectiveTriviaSyntax() { }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get; }
        public abstract bool ConditionValue { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
    }
    public sealed partial class ConditionalExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ConditionalExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken QuestionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenFalse { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax WhenTrue { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken questionToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithWhenFalse(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenFalse) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax WithWhenTrue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax whenTrue) { throw null; }
    }
    public sealed partial class ConstantPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal ConstantPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstantPatternSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ConstructorConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal ConstructorConstraintSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ConstructorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal ConstructorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax? Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax? initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax initializer, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ConstructorInitializerSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ConstructorInitializerSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisOrBaseKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax WithThisOrBaseKeyword(Microsoft.CodeAnalysis.SyntaxToken thisOrBaseKeyword) { throw null; }
    }
    public sealed partial class ContinueStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ContinueStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ContinueKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken continueKeyword, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax WithContinueKeyword(Microsoft.CodeAnalysis.SyntaxToken continueKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ConversionOperatorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal ConversionOperatorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class ConversionOperatorMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal ConversionOperatorMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? Parameters { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(Microsoft.CodeAnalysis.SyntaxToken implicitOrExplicitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class CrefBracketedParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax
    {
        internal CrefBracketedParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class CrefParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax
    {
        internal CrefParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class CrefParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CrefParameterSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken RefKindKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefOrOutKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKindKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax WithRefKindKeyword(Microsoft.CodeAnalysis.SyntaxToken refKindKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax WithRefOrOutKeyword(Microsoft.CodeAnalysis.SyntaxToken refOrOutKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class CrefSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal CrefSyntax() { }
    }
    public sealed partial class DeclarationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal DeclarationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DeclarationPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal DeclarationPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DeclarationPatternSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DefaultConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal DefaultConstraintSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DefaultKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax Update(Microsoft.CodeAnalysis.SyntaxToken defaultKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultConstraintSyntax WithDefaultKeyword(Microsoft.CodeAnalysis.SyntaxToken defaultKeyword) { throw null; }
    }
    public sealed partial class DefaultExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal DefaultExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class DefaultSwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax
    {
        internal DefaultSwitchLabelSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class DefineDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal DefineDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DefineKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken defineKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithDefineKeyword(Microsoft.CodeAnalysis.SyntaxToken defineKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax WithName(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
    }
    public sealed partial class DelegateDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal DelegateDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DelegateKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class DestructorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal DestructorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken TildeToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken tildeToken, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax WithTildeToken(Microsoft.CodeAnalysis.SyntaxToken tildeToken) { throw null; }
    }
    public abstract partial class DirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax
    {
        internal DirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DirectiveNameToken { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken HashToken { get; }
        public abstract bool IsActive { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetNextDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax? GetPreviousDirective(System.Func<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }
        public System.Collections.Generic.List<Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax> GetRelatedDirectives() { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
    }
    public sealed partial class DiscardDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal DiscardDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken UnderscoreToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardDesignationSyntax WithUnderscoreToken(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
    }
    public sealed partial class DiscardPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal DiscardPatternSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken UnderscoreToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax Update(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DiscardPatternSyntax WithUnderscoreToken(Microsoft.CodeAnalysis.SyntaxToken underscoreToken) { throw null; }
    }
    public sealed partial class DocumentationCommentTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax
    {
        internal DocumentationCommentTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> Content { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndOfComment { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax AddContent(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax WithContent(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax WithEndOfComment(Microsoft.CodeAnalysis.SyntaxToken endOfComment) { throw null; }
    }
    public sealed partial class DoStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal DoStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DoKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhileKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken doKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithDoKeyword(Microsoft.CodeAnalysis.SyntaxToken doKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken whileKeyword) { throw null; }
    }
    public sealed partial class ElementAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ElementAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ElementBindingExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ElementBindingExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
    }
    public sealed partial class ElifDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax
    {
        internal ElifDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public override bool ConditionValue { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ElifKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithElifKeyword(Microsoft.CodeAnalysis.SyntaxToken elifKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class ElseClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ElseClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ElseKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken elseKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ElseDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax
    {
        internal ElseDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ElseKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken elseKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithElseKeyword(Microsoft.CodeAnalysis.SyntaxToken elseKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EmptyStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal EmptyStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class EndIfDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal EndIfDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndIfKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endIfKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithEndIfKeyword(Microsoft.CodeAnalysis.SyntaxToken endIfKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EndRegionDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal EndRegionDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EndRegionKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken endRegionKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EnumDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax
    {
        internal EnumDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EnumKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken enumKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithEnumKeyword(Microsoft.CodeAnalysis.SyntaxToken enumKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class EnumMemberDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal EnumMemberDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? EqualsValue { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax equalsValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? equalsValue) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithEqualsValue(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? equalsValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
    }
    public sealed partial class EqualsValueClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal EqualsValueClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class ErrorDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ErrorDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ErrorKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken errorKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithErrorKeyword(Microsoft.CodeAnalysis.SyntaxToken errorKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class EventDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal EventDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EventKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax accessorList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithEventKeyword(Microsoft.CodeAnalysis.SyntaxToken eventKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class EventFieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax
    {
        internal EventFieldDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken EventKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken eventKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithEventKeyword(Microsoft.CodeAnalysis.SyntaxToken eventKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class ExplicitInterfaceSpecifierSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExplicitInterfaceSpecifierSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
    }
    public sealed partial class ExpressionColonSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax
    {
        internal ExpressionColonSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionColonSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public abstract partial class ExpressionOrPatternSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExpressionOrPatternSyntax() { }
    }
    public sealed partial class ExpressionStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ExpressionStatementSyntax() { }
        public bool AllowsAnyExpression { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public abstract partial class ExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionOrPatternSyntax
    {
        internal ExpressionSyntax() { }
    }
    public sealed partial class ExternAliasDirectiveSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal ExternAliasDirectiveSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AliasKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ExternKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax Update(Microsoft.CodeAnalysis.SyntaxToken externKeyword, Microsoft.CodeAnalysis.SyntaxToken aliasKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithAliasKeyword(Microsoft.CodeAnalysis.SyntaxToken aliasKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithExternKeyword(Microsoft.CodeAnalysis.SyntaxToken externKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class FieldDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax
    {
        internal FieldDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class FileScopedNamespaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax
    {
        internal FileScopedNamespaceDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken NamespaceKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FileScopedNamespaceDeclarationSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public sealed partial class FinallyClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FinallyClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FinallyKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax WithFinallyKeyword(Microsoft.CodeAnalysis.SyntaxToken finallyKeyword) { throw null; }
    }
    public sealed partial class FixedStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal FixedStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FixedKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithFixedKeyword(Microsoft.CodeAnalysis.SyntaxToken fixedKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ForEachStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax
    {
        internal ForEachStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithForEachKeyword(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class ForEachVariableStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CommonForEachStatementSyntax
    {
        internal ForEachVariableStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken ForEachKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Variable { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken forEachKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithForEachKeyword(Microsoft.CodeAnalysis.SyntaxToken forEachKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForEachVariableStatementSyntax WithVariable(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax variable) { throw null; }
    }
    public sealed partial class ForStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ForStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FirstSemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ForKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Incrementors { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Initializers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SecondSemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax AddIncrementors(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax AddInitializers(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken forKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers, Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition, Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithFirstSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken firstSemicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithForKeyword(Microsoft.CodeAnalysis.SyntaxToken forKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithIncrementors(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> incrementors) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithInitializers(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> initializers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithSecondSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken secondSemicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class FromClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal FromClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FromKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken fromKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithFromKeyword(Microsoft.CodeAnalysis.SyntaxToken fromKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public sealed partial class FunctionPointerCallingConventionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FunctionPointerCallingConventionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ManagedOrUnmanagedKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax? UnmanagedCallingConventionList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax AddUnmanagedCallingConventionListCallingConventions(params Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken managedOrUnmanagedKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax WithManagedOrUnmanagedKeyword(Microsoft.CodeAnalysis.SyntaxToken managedOrUnmanagedKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax WithUnmanagedCallingConventionList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }
    }
    public sealed partial class FunctionPointerParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FunctionPointerParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class FunctionPointerParameterSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax
    {
        internal FunctionPointerParameterSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class FunctionPointerTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal FunctionPointerTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AsteriskToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax? CallingConvention { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DelegateKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax ParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword, Microsoft.CodeAnalysis.SyntaxToken asteriskToken, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax? callingConvention, Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax WithAsteriskToken(Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax WithCallingConvention(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerCallingConventionSyntax? callingConvention) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax WithDelegateKeyword(Microsoft.CodeAnalysis.SyntaxToken delegateKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerTypeSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }
    }
    public sealed partial class FunctionPointerUnmanagedCallingConventionListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FunctionPointerUnmanagedCallingConventionListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax> CallingConventions { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax AddCallingConventions(params Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax WithCallingConventions(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
    }
    public sealed partial class FunctionPointerUnmanagedCallingConventionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal FunctionPointerUnmanagedCallingConventionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax WithName(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
    }
    public sealed partial class GenericNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax
    {
        internal GenericNameSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public bool IsUnboundGenericName { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax TypeArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax AddTypeArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax WithTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }
    }
    public sealed partial class GlobalStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal GlobalStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class GotoStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal GotoStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CaseOrDefaultKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GotoKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken gotoKeyword, Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithCaseOrDefaultKeyword(Microsoft.CodeAnalysis.SyntaxToken caseOrDefaultKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithGotoKeyword(Microsoft.CodeAnalysis.SyntaxToken gotoKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class GroupClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
    {
        internal GroupClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax ByExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ByKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GroupExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GroupKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken groupKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression, Microsoft.CodeAnalysis.SyntaxToken byKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithByExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax byExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithByKeyword(Microsoft.CodeAnalysis.SyntaxToken byKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithGroupExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax groupExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax WithGroupKeyword(Microsoft.CodeAnalysis.SyntaxToken groupKeyword) { throw null; }
    }
    public sealed partial class IdentifierNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax
    {
        internal IdentifierNameSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class IfDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax
    {
        internal IfDirectiveTriviaSyntax() { }
        public override bool BranchTaken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public override bool ConditionValue { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IfKeyword { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken ifKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class IfStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal IfStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? Else { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IfKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken ifKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement, Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithElse(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax? @else) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithIfKeyword(Microsoft.CodeAnalysis.SyntaxToken ifKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class ImplicitArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ImplicitArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Commas { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax AddCommas(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxTokenList commas, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithCommas(Microsoft.CodeAnalysis.SyntaxTokenList commas) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
    }
    public sealed partial class ImplicitElementAccessSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ImplicitElementAccessSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax ArgumentList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax argumentList) { throw null; }
    }
    public sealed partial class ImplicitObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax
    {
        internal ImplicitObjectCreationExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
    }
    public sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ImplicitStackAllocArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBracketToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StackAllocKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax AddInitializerExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.SyntaxToken openBracketToken, Microsoft.CodeAnalysis.SyntaxToken closeBracketToken, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax WithCloseBracketToken(Microsoft.CodeAnalysis.SyntaxToken closeBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax WithOpenBracketToken(Microsoft.CodeAnalysis.SyntaxToken openBracketToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword) { throw null; }
    }
    public sealed partial class IncompleteMemberSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax
    {
        internal IncompleteMemberSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public sealed partial class IndexerDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal IndexerDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax ParameterList { get { throw null; } }
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.SyntaxToken Semicolon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax parameterList) { throw null; }
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithSemicolon(Microsoft.CodeAnalysis.SyntaxToken semicolon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithThisKeyword(Microsoft.CodeAnalysis.SyntaxToken thisKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class IndexerMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal IndexerMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax? Parameters { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThisKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken thisKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax WithThisKeyword(Microsoft.CodeAnalysis.SyntaxToken thisKeyword) { throw null; }
    }
    public sealed partial class InitializerExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InitializerExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> Expressions { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax AddExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithExpressions(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> expressions) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public abstract partial class InstanceExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InstanceExpressionSyntax() { }
    }
    public sealed partial class InterfaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal InterfaceDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public abstract partial class InterpolatedStringContentSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolatedStringContentSyntax() { }
    }
    public sealed partial class InterpolatedStringExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InterpolatedStringExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> Contents { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StringEndToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StringStartToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax AddContents(params Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stringStartToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents, Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithContents(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax> contents) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithStringEndToken(Microsoft.CodeAnalysis.SyntaxToken stringEndToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax WithStringStartToken(Microsoft.CodeAnalysis.SyntaxToken stringStartToken) { throw null; }
    }
    public sealed partial class InterpolatedStringTextSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax
    {
        internal InterpolatedStringTextSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken TextToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax Update(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax WithTextToken(Microsoft.CodeAnalysis.SyntaxToken textToken) { throw null; }
    }
    public sealed partial class InterpolationAlignmentClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolationAlignmentClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CommaToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Value { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken commaToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax WithValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax value) { throw null; }
    }
    public sealed partial class InterpolationFormatClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal InterpolationFormatClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken FormatStringToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax WithFormatStringToken(Microsoft.CodeAnalysis.SyntaxToken formatStringToken) { throw null; }
    }
    public sealed partial class InterpolationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax
    {
        internal InterpolationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax? AlignmentClause { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax? FormatClause { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax? alignmentClause, Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax? formatClause, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax? alignmentClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax? formatClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
    }
    public sealed partial class InvocationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal InvocationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class IsPatternExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal IsPatternExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IsKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken isKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithIsKeyword(Microsoft.CodeAnalysis.SyntaxToken isKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IsPatternExpressionSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
    }
    public sealed partial class JoinClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal JoinClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax InExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken InKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax? Into { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken JoinKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax LeftExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OnKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax RightExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken joinKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken inKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression, Microsoft.CodeAnalysis.SyntaxToken onKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression, Microsoft.CodeAnalysis.SyntaxToken equalsKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax? into) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithEqualsKeyword(Microsoft.CodeAnalysis.SyntaxToken equalsKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax inExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInKeyword(Microsoft.CodeAnalysis.SyntaxToken inKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithInto(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax? into) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithJoinKeyword(Microsoft.CodeAnalysis.SyntaxToken joinKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithLeftExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax leftExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithOnKeyword(Microsoft.CodeAnalysis.SyntaxToken onKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithRightExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax rightExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public sealed partial class JoinIntoClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal JoinIntoClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IntoKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken intoKeyword) { throw null; }
    }
    public sealed partial class LabeledStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LabeledStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public abstract partial class LambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax
    {
        internal LambdaExpressionSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
    }
    public sealed partial class LetClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal LetClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LetKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken letKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax WithLetKeyword(Microsoft.CodeAnalysis.SyntaxToken letKeyword) { throw null; }
    }
    public sealed partial class LineDirectivePositionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal LineDirectivePositionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Character { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CommaToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Line { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken commaToken, Microsoft.CodeAnalysis.SyntaxToken character, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax WithCharacter(Microsoft.CodeAnalysis.SyntaxToken character) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax WithCommaToken(Microsoft.CodeAnalysis.SyntaxToken commaToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax WithLine(Microsoft.CodeAnalysis.SyntaxToken line) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class LineDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax
    {
        internal LineDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Line { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken LineKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.SyntaxToken line, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithLine(Microsoft.CodeAnalysis.SyntaxToken line) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax WithLineKeyword(Microsoft.CodeAnalysis.SyntaxToken lineKeyword) { throw null; }
    }
    public abstract partial class LineOrSpanDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal LineOrSpanDirectiveTriviaSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken File { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken LineKeyword { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax WithLineKeyword(Microsoft.CodeAnalysis.SyntaxToken lineKeyword) { throw null; }
    }
    public sealed partial class LineSpanDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LineOrSpanDirectiveTriviaSyntax
    {
        internal LineSpanDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CharacterOffset { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax End { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken LineKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken MinusToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax Start { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken lineKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax start, Microsoft.CodeAnalysis.SyntaxToken minusToken, Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax end, Microsoft.CodeAnalysis.SyntaxToken characterOffset, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithCharacterOffset(Microsoft.CodeAnalysis.SyntaxToken characterOffset) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithEnd(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax end) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithLineKeyword(Microsoft.CodeAnalysis.SyntaxToken lineKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithMinusToken(Microsoft.CodeAnalysis.SyntaxToken minusToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LineSpanDirectiveTriviaSyntax WithStart(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectivePositionSyntax start) { throw null; }
    }
    public sealed partial class LiteralExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal LiteralExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public sealed partial class LoadDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal LoadDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LoadKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken loadKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax WithLoadKeyword(Microsoft.CodeAnalysis.SyntaxToken loadKeyword) { throw null; }
    }
    public sealed partial class LocalDeclarationStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LocalDeclarationStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Declaration { get { throw null; } }
        public bool IsConst { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UsingKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax AddDeclarationVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken usingKeyword) { throw null; }
    }
    public sealed partial class LocalFunctionStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LocalFunctionStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LocalFunctionStatementSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class LockStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal LockStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LockKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lockKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithLockKeyword(Microsoft.CodeAnalysis.SyntaxToken lockKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
    }
    public sealed partial class MakeRefExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MakeRefExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class MemberAccessExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MemberAccessExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class MemberBindingExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal MemberBindingExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public abstract partial class MemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal MemberCrefSyntax() { }
    }
    public abstract partial class MemberDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal MemberDeclarationSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
    }
    public sealed partial class MethodDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal MethodDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class NameColonSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax
    {
        internal NameColonSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
    }
    public sealed partial class NameEqualsSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal NameEqualsSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
    }
    public sealed partial class NameMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal NameMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
    }
    public sealed partial class NamespaceDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseNamespaceDeclarationSyntax
    {
        internal NamespaceDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> Externs { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken NamespaceKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> Usings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddExterns(params Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax AddUsings(params Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithExterns(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax> externs) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithNamespaceKeyword(Microsoft.CodeAnalysis.SyntaxToken namespaceKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax WithUsings(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> usings) { throw null; }
    }
    public abstract partial class NameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal NameSyntax() { }
        public int Arity { get { throw null; } }
    }
    public sealed partial class NullableDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal NullableDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken NullableKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SettingToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken TargetToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken nullableKeyword, Microsoft.CodeAnalysis.SyntaxToken settingToken, Microsoft.CodeAnalysis.SyntaxToken targetToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithNullableKeyword(Microsoft.CodeAnalysis.SyntaxToken nullableKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithSettingToken(Microsoft.CodeAnalysis.SyntaxToken settingToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableDirectiveTriviaSyntax WithTargetToken(Microsoft.CodeAnalysis.SyntaxToken targetToken) { throw null; }
    }
    public sealed partial class NullableTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal NullableTypeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken QuestionToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax WithQuestionToken(Microsoft.CodeAnalysis.SyntaxToken questionToken) { throw null; }
    }
    public sealed partial class ObjectCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseObjectCreationExpressionSyntax
    {
        internal ObjectCreationExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? ArgumentList { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken NewKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken newKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax? argumentList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithNewKeyword(Microsoft.CodeAnalysis.SyntaxToken newKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class OmittedArraySizeExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal OmittedArraySizeExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OmittedArraySizeExpressionToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(Microsoft.CodeAnalysis.SyntaxToken omittedArraySizeExpressionToken) { throw null; }
    }
    public sealed partial class OmittedTypeArgumentSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal OmittedTypeArgumentSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OmittedTypeArgumentToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax Update(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(Microsoft.CodeAnalysis.SyntaxToken omittedTypeArgumentToken) { throw null; }
    }
    public sealed partial class OperatorDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax
    {
        internal OperatorDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ReturnType { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddBodyAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddBodyStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType, Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax returnType) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class OperatorMemberCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax
    {
        internal OperatorMemberCrefSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax AddParametersParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithOperatorKeyword(Microsoft.CodeAnalysis.SyntaxToken operatorKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax WithParameters(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax? parameters) { throw null; }
    }
    public sealed partial class OrderByClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal OrderByClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OrderByKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> Orderings { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax AddOrderings(params Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax WithOrderByKeyword(Microsoft.CodeAnalysis.SyntaxToken orderByKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax WithOrderings(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax> orderings) { throw null; }
    }
    public sealed partial class OrderingSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal OrderingSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AscendingOrDescendingKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax WithAscendingOrDescendingKeyword(Microsoft.CodeAnalysis.SyntaxToken ascendingOrDescendingKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
    }
    public sealed partial class ParameterListSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax
    {
        internal ParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class ParameterSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterSyntax
    {
        internal ParameterSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? Default { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? @default) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithDefault(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? @default) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public sealed partial class ParenthesizedExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ParenthesizedExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class ParenthesizedLambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax
    {
        internal ParenthesizedLambdaExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Block { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax ParameterList { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? ReturnType { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? returnType, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax parameterList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax WithReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? returnType) { throw null; }
    }
    public sealed partial class ParenthesizedPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal ParenthesizedPatternSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedPatternSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
    }
    public sealed partial class ParenthesizedVariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal ParenthesizedVariableDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> Variables { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax AddVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedVariableDesignationSyntax WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax> variables) { throw null; }
    }
    public abstract partial class PatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionOrPatternSyntax
    {
        internal PatternSyntax() { }
    }
    public sealed partial class PointerTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal PointerTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken AsteriskToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax ElementType { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType, Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax WithAsteriskToken(Microsoft.CodeAnalysis.SyntaxToken asteriskToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax WithElementType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax elementType) { throw null; }
    }
    public sealed partial class PositionalPatternClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal PositionalPatternClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> Subpatterns { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax AddSubpatterns(params Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax WithSubpatterns(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns) { throw null; }
    }
    public sealed partial class PostfixUnaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal PostfixUnaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Operand { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand, Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax WithOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class PragmaChecksumDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal PragmaChecksumDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Bytes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ChecksumKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Guid { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken PragmaKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken checksumKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken guid, Microsoft.CodeAnalysis.SyntaxToken bytes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithBytes(Microsoft.CodeAnalysis.SyntaxToken bytes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(Microsoft.CodeAnalysis.SyntaxToken checksumKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithGuid(Microsoft.CodeAnalysis.SyntaxToken guid) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword) { throw null; }
    }
    public sealed partial class PragmaWarningDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal PragmaWarningDirectiveTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DisableOrRestoreKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> ErrorCodes { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken PragmaKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WarningKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(Microsoft.CodeAnalysis.SyntaxToken disableOrRestoreKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithErrorCodes(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax> errorCodes) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(Microsoft.CodeAnalysis.SyntaxToken pragmaKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken warningKeyword) { throw null; }
    }
    public sealed partial class PredefinedTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal PredefinedTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class PrefixUnaryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal PrefixUnaryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Operand { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax WithOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax operand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class PrimaryConstructorBaseTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax
    {
        internal PrimaryConstructorBaseTypeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax ArgumentList { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argumentList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PrimaryConstructorBaseTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class PropertyDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax
    {
        internal PropertyDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? AccessorList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? Initializer { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.SyntaxToken Semicolon { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddAccessorListAccessors(params Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList, Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax? accessorList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        [System.ObsoleteAttribute("This member is obsolete.", true)]
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithSemicolon(Microsoft.CodeAnalysis.SyntaxToken semicolon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class PropertyPatternClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal PropertyPatternClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> Subpatterns { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax AddSubpatterns(params Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax WithSubpatterns(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax> subpatterns) { throw null; }
    }
    public sealed partial class QualifiedCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal QualifiedCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Container { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax Member { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithContainer(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax container) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax WithMember(Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax member) { throw null; }
    }
    public sealed partial class QualifiedNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal QualifiedNameSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken DotToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Left { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax Right { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left, Microsoft.CodeAnalysis.SyntaxToken dotToken, Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithDotToken(Microsoft.CodeAnalysis.SyntaxToken dotToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithLeft(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax left) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax WithRight(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax right) { throw null; }
    }
    public sealed partial class QueryBodySyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryBodySyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> Clauses { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax? Continuation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax SelectOrGroup { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax AddClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses, Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup, Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax? continuation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax> clauses) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax? continuation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax WithSelectOrGroup(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax selectOrGroup) { throw null; }
    }
    public abstract partial class QueryClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryClauseSyntax() { }
    }
    public sealed partial class QueryContinuationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal QueryContinuationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken IntoKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax AddBodyClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken intoKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax WithIntoKeyword(Microsoft.CodeAnalysis.SyntaxToken intoKeyword) { throw null; }
    }
    public sealed partial class QueryExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal QueryExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax Body { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax FromClause { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax AddBodyClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause, Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax WithFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax fromClause) { throw null; }
    }
    public sealed partial class RangeExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RangeExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? LeftOperand { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? RightOperand { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? leftOperand, Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? rightOperand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax WithLeftOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? leftOperand) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RangeExpressionSyntax WithRightOperand(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? rightOperand) { throw null; }
    }
    public sealed partial class RecordDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal RecordDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ClassOrStructKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? ParameterList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithClassOrStructKeyword(Microsoft.CodeAnalysis.SyntaxToken classOrStructKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax? parameterList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RecordDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class RecursivePatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal RecursivePatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax? PositionalPatternClause { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax? PropertyPatternClause { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax AddPositionalPatternClauseSubpatterns(params Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax AddPropertyPatternClauseSubpatterns(params Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type, Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax? positionalPatternClause, Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax? propertyPatternClause, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax? designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax WithPositionalPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PositionalPatternClauseSyntax? positionalPatternClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax WithPropertyPatternClause(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyPatternClauseSyntax? propertyPatternClause) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RecursivePatternSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax? type) { throw null; }
    }
    public sealed partial class ReferenceDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ReferenceDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken File { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReferenceKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken referenceKeyword, Microsoft.CodeAnalysis.SyntaxToken file, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithFile(Microsoft.CodeAnalysis.SyntaxToken file) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax WithReferenceKeyword(Microsoft.CodeAnalysis.SyntaxToken referenceKeyword) { throw null; }
    }
    public sealed partial class RefExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefExpressionSyntax WithRefKeyword(Microsoft.CodeAnalysis.SyntaxToken refKeyword) { throw null; }
    }
    public sealed partial class RefTypeExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefTypeExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class RefTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal RefTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ReadOnlyKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RefKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken refKeyword, Microsoft.CodeAnalysis.SyntaxToken readOnlyKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax WithReadOnlyKeyword(Microsoft.CodeAnalysis.SyntaxToken readOnlyKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax WithRefKeyword(Microsoft.CodeAnalysis.SyntaxToken refKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class RefValueExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal RefValueExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Comma { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken comma, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithComma(Microsoft.CodeAnalysis.SyntaxToken comma) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class RegionDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal RegionDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken RegionKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken regionKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax WithRegionKeyword(Microsoft.CodeAnalysis.SyntaxToken regionKeyword) { throw null; }
    }
    public sealed partial class RelationalPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal RelationalPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.RelationalPatternSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
    }
    public sealed partial class ReturnStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ReturnStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReturnKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken returnKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithReturnKeyword(Microsoft.CodeAnalysis.SyntaxToken returnKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
    }
    public sealed partial class SelectClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax
    {
        internal SelectClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SelectKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken selectKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax WithSelectKeyword(Microsoft.CodeAnalysis.SyntaxToken selectKeyword) { throw null; }
    }
    public abstract partial class SelectOrGroupClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SelectOrGroupClauseSyntax() { }
    }
    public sealed partial class ShebangDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal ShebangDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ExclamationToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken exclamationToken, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithExclamationToken(Microsoft.CodeAnalysis.SyntaxToken exclamationToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }
    public sealed partial class SimpleBaseTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax
    {
        internal SimpleBaseTypeSyntax() { }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class SimpleLambdaExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax
    {
        internal SimpleLambdaExpressionSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken ArrowToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken AsyncKeyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? Block { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? ExpressionBody { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax Parameter { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddParameterAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax AddParameterModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter, Microsoft.CodeAnalysis.SyntaxToken arrowToken, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithArrowToken(Microsoft.CodeAnalysis.SyntaxToken arrowToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithAsyncKeyword(Microsoft.CodeAnalysis.SyntaxToken asyncKeyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax? block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithBody(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode body) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expressionBody) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax WithParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax parameter) { throw null; }
    }
    public abstract partial class SimpleNameSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax
    {
        internal SimpleNameSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Identifier { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class SingleVariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax
    {
        internal SingleVariableDesignationSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SingleVariableDesignationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
    }
    public sealed partial class SizeOfExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal SizeOfExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class SkippedTokensTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax, Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax
    {
        internal SkippedTokensTriviaSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxTokenList Tokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax AddTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax WithTokens(Microsoft.CodeAnalysis.SyntaxTokenList tokens) { throw null; }
    }
    public sealed partial class StackAllocArrayCreationExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal StackAllocArrayCreationExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StackAllocKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(Microsoft.CodeAnalysis.SyntaxToken stackAllocKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class StatementSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal StatementSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
    }
    public sealed partial class StructDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax
    {
        internal StructDeclarationSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? BaseList { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxTokenList Modifiers { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxTokenList modifiers, Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList, Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public abstract partial class StructuredTriviaSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, Microsoft.CodeAnalysis.IStructuredTriviaSyntax
    {
        internal StructuredTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxTrivia ParentTrivia { get { throw null; } }
    }
    public sealed partial class SubpatternSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SubpatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax? ExpressionColon { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? NameColon { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax? expressionColon, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax WithExpressionColon(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionColonSyntax? expressionColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax WithNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax? nameColon) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SubpatternSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
    }
    public sealed partial class SwitchExpressionArmSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SwitchExpressionArmSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EqualsGreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? WhenClause { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern, Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause, Microsoft.CodeAnalysis.SyntaxToken equalsGreaterThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax WithEqualsGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken equalsGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax WithWhenClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax? whenClause) { throw null; }
    }
    public sealed partial class SwitchExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal SwitchExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax> Arms { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax GoverningExpression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SwitchKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax AddArms(params Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax governingExpression, Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax> arms, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax WithArms(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionArmSyntax> arms) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax WithGoverningExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax governingExpression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchExpressionSyntax WithSwitchKeyword(Microsoft.CodeAnalysis.SyntaxToken switchKeyword) { throw null; }
    }
    public abstract partial class SwitchLabelSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SwitchLabelSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken ColonToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Keyword { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
    }
    public sealed partial class SwitchSectionSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal SwitchSectionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> Labels { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> Statements { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax AddLabels(params Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax AddStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax WithLabels(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax> labels) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax WithStatements(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax> statements) { throw null; }
    }
    public sealed partial class SwitchStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal SwitchStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenBraceToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> Sections { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SwitchKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax AddSections(params Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken switchKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.SyntaxToken openBraceToken, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections, Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithSections(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax> sections) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax WithSwitchKeyword(Microsoft.CodeAnalysis.SyntaxToken switchKeyword) { throw null; }
    }
    public sealed partial class ThisExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax
    {
        internal ThisExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Token { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax WithToken(Microsoft.CodeAnalysis.SyntaxToken token) { throw null; }
    }
    public sealed partial class ThrowExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal ThrowExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThrowKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowExpressionSyntax WithThrowKeyword(Microsoft.CodeAnalysis.SyntaxToken throwKeyword) { throw null; }
    }
    public sealed partial class ThrowStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal ThrowStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ThrowKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken throwKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax WithThrowKeyword(Microsoft.CodeAnalysis.SyntaxToken throwKeyword) { throw null; }
    }
    public sealed partial class TryStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal TryStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> Catches { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax? Finally { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken TryKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax AddCatches(params Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax? @finally) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken tryKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches, Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax @finally) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithCatches(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax> catches) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithFinally(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax? @finally) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax WithTryKeyword(Microsoft.CodeAnalysis.SyntaxToken tryKeyword) { throw null; }
    }
    public sealed partial class TupleElementSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TupleElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TupleExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TupleExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class TupleTypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax
    {
        internal TupleTypeSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> Elements { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax AddElements(params Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax Update(Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithElements(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TupleElementSyntax> elements) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TupleTypeSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
    }
    public sealed partial class TypeArgumentListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeArgumentListSyntax() { }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> Arguments { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax AddArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithArguments(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax> arguments) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
    }
    public sealed partial class TypeConstraintSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax
    {
        internal TypeConstraintSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TypeCrefSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax
    {
        internal TypeCrefSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class TypeDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax
    {
        internal TypeDeclarationSyntax() { }
        public int Arity { get { throw null; } }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken Keyword { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> Members { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? TypeParameterList { get; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax AddBaseListTypes(params Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax AddConstraintClauses(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax AddMembers(params Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax AddModifiers(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax AddTypeParameterListParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax? baseList) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithCloseBraceToken(Microsoft.CodeAnalysis.SyntaxToken closeBraceToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithConstraintClauses(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithMembers(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax> members) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithModifiers(Microsoft.CodeAnalysis.SyntaxTokenList modifiers) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithOpenBraceToken(Microsoft.CodeAnalysis.SyntaxToken openBraceToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax WithTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax? typeParameterList) { throw null; }
    }
    public sealed partial class TypeOfExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TypeOfExpressionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Keyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken keyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithKeyword(Microsoft.CodeAnalysis.SyntaxToken keyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public sealed partial class TypeParameterConstraintClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterConstraintClauseSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> Constraints { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhereKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax AddConstraints(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken colonToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithConstraints(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax WithWhereKeyword(Microsoft.CodeAnalysis.SyntaxToken whereKeyword) { throw null; }
    }
    public abstract partial class TypeParameterConstraintSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterConstraintSyntax() { }
    }
    public sealed partial class TypeParameterListSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterListSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> Parameters { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax AddParameters(params Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax WithParameters(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax> parameters) { throw null; }
    }
    public sealed partial class TypeParameterSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal TypeParameterSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken VarianceKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken varianceKeyword, Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax WithVarianceKeyword(Microsoft.CodeAnalysis.SyntaxToken varianceKeyword) { throw null; }
    }
    public sealed partial class TypePatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal TypePatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypePatternSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
    }
    public abstract partial class TypeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal TypeSyntax() { }
        public bool IsNint { get { throw null; } }
        public bool IsNotNull { get { throw null; } }
        public bool IsNuint { get { throw null; } }
        public bool IsUnmanaged { get { throw null; } }
        public bool IsVar { get { throw null; } }
    }
    public sealed partial class UnaryPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal UnaryPatternSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken OperatorToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax Pattern { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax Update(Microsoft.CodeAnalysis.SyntaxToken operatorToken, Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax WithOperatorToken(Microsoft.CodeAnalysis.SyntaxToken operatorToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnaryPatternSyntax WithPattern(Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax pattern) { throw null; }
    }
    public sealed partial class UndefDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal UndefDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UndefKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken undefKeyword, Microsoft.CodeAnalysis.SyntaxToken name, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithName(Microsoft.CodeAnalysis.SyntaxToken name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax WithUndefKeyword(Microsoft.CodeAnalysis.SyntaxToken undefKeyword) { throw null; }
    }
    public sealed partial class UnsafeStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal UnsafeStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax Block { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UnsafeKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax AddBlockAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax AddBlockStatements(params Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax WithBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax block) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax WithUnsafeKeyword(Microsoft.CodeAnalysis.SyntaxToken unsafeKeyword) { throw null; }
    }
    public sealed partial class UsingDirectiveSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal UsingDirectiveSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? Alias { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GlobalKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StaticKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UsingKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax Update(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax Update(Microsoft.CodeAnalysis.SyntaxToken globalKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken staticKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias, Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithAlias(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax? alias) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithGlobalKeyword(Microsoft.CodeAnalysis.SyntaxToken globalKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithStaticKeyword(Microsoft.CodeAnalysis.SyntaxToken staticKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken usingKeyword) { throw null; }
    }
    public sealed partial class UsingStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal UsingStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken AwaitKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? Declaration { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken UsingKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword, Microsoft.CodeAnalysis.SyntaxToken usingKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithAwaitKeyword(Microsoft.CodeAnalysis.SyntaxToken awaitKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax? declaration) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax WithUsingKeyword(Microsoft.CodeAnalysis.SyntaxToken usingKeyword) { throw null; }
    }
    public sealed partial class VariableDeclarationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDeclarationSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax Type { get { throw null; } }
        public Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> Variables { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax AddVariables(params Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type, Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax WithType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax type) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax WithVariables(Microsoft.CodeAnalysis.SeparatedSyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax> variables) { throw null; }
    }
    public sealed partial class VariableDeclaratorSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDeclaratorSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax? ArgumentList { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Identifier { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? Initializer { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax AddArgumentListArguments(params Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax Update(Microsoft.CodeAnalysis.SyntaxToken identifier, Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax? argumentList, Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax? argumentList) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithIdentifier(Microsoft.CodeAnalysis.SyntaxToken identifier) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax? initializer) { throw null; }
    }
    public abstract partial class VariableDesignationSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal VariableDesignationSyntax() { }
    }
    public sealed partial class VarPatternSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax
    {
        internal VarPatternSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax Designation { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken VarKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax Update(Microsoft.CodeAnalysis.SyntaxToken varKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax WithDesignation(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDesignationSyntax designation) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.VarPatternSyntax WithVarKeyword(Microsoft.CodeAnalysis.SyntaxToken varKeyword) { throw null; }
    }
    public sealed partial class WarningDirectiveTriviaSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax
    {
        internal WarningDirectiveTriviaSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndOfDirectiveToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken HashToken { get { throw null; } }
        public override bool IsActive { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WarningKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax Update(Microsoft.CodeAnalysis.SyntaxToken hashToken, Microsoft.CodeAnalysis.SyntaxToken warningKeyword, Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(Microsoft.CodeAnalysis.SyntaxToken endOfDirectiveToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithHashToken(Microsoft.CodeAnalysis.SyntaxToken hashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax WithWarningKeyword(Microsoft.CodeAnalysis.SyntaxToken warningKeyword) { throw null; }
    }
    public sealed partial class WhenClauseSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal WhenClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhenKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whenKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhenClauseSyntax WithWhenKeyword(Microsoft.CodeAnalysis.SyntaxToken whenKeyword) { throw null; }
    }
    public sealed partial class WhereClauseSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax
    {
        internal WhereClauseSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhereKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whereKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax WithWhereKeyword(Microsoft.CodeAnalysis.SyntaxToken whereKeyword) { throw null; }
    }
    public sealed partial class WhileStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal WhileStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken CloseParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Condition { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken OpenParenToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax Statement { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WhileKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken whileKeyword, Microsoft.CodeAnalysis.SyntaxToken openParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition, Microsoft.CodeAnalysis.SyntaxToken closeParenToken, Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithCloseParenToken(Microsoft.CodeAnalysis.SyntaxToken closeParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithCondition(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax condition) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithOpenParenToken(Microsoft.CodeAnalysis.SyntaxToken openParenToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax statement) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax WithWhileKeyword(Microsoft.CodeAnalysis.SyntaxToken whileKeyword) { throw null; }
    }
    public sealed partial class WithExpressionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax
    {
        internal WithExpressionSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax Initializer { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken WithKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax AddInitializerExpressions(params Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken withKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax WithInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax initializer) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.WithExpressionSyntax WithWithKeyword(Microsoft.CodeAnalysis.SyntaxToken withKeyword) { throw null; }
    }
    public abstract partial class XmlAttributeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlAttributeSyntax() { }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get; }
        public abstract Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get; }
        public abstract Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
    }
    public sealed partial class XmlCDataSectionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlCDataSectionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndCDataToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StartCDataToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken startCDataToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithEndCDataToken(Microsoft.CodeAnalysis.SyntaxToken endCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithStartCDataToken(Microsoft.CodeAnalysis.SyntaxToken startCDataToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlCommentSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlCommentSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanExclamationMinusMinusToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken MinusMinusGreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithLessThanExclamationMinusMinusToken(Microsoft.CodeAnalysis.SyntaxToken lessThanExclamationMinusMinusToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithMinusMinusGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken minusMinusGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlCrefAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlCrefAttributeSyntax() { }
        public Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax Cref { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax cref) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
    }
    public sealed partial class XmlElementEndTagSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlElementEndTagSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanSlashToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithLessThanSlashToken(Microsoft.CodeAnalysis.SyntaxToken lessThanSlashToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
    }
    public sealed partial class XmlElementStartTagSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlElementStartTagSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken GreaterThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithAttributes(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken greaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
    }
    public sealed partial class XmlElementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> Content { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax EndTag { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax StartTag { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax AddContent(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax AddStartTagAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content, Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithContent(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax> content) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax endTag) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax WithStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax startTag) { throw null; }
    }
    public sealed partial class XmlEmptyElementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlEmptyElementSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> Attributes { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken LessThanToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SlashGreaterThanToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax AddAttributes(params Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken lessThanToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes, Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithAttributes(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax> attributes) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithLessThanToken(Microsoft.CodeAnalysis.SyntaxToken lessThanToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax WithSlashGreaterThanToken(Microsoft.CodeAnalysis.SyntaxToken slashGreaterThanToken) { throw null; }
    }
    public enum XmlNameAttributeElementKind : byte
    {
        Parameter = (byte)0,
        ParameterReference = (byte)1,
        TypeParameter = (byte)2,
        TypeParameterReference = (byte)3,
    }
    public sealed partial class XmlNameAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlNameAttributeSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax Identifier { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax identifier) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
    }
    public sealed partial class XmlNameSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlNameSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken LocalName { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax? Prefix { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax? prefix, Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax WithLocalName(Microsoft.CodeAnalysis.SyntaxToken localName) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax WithPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax? prefix) { throw null; }
    }
    public abstract partial class XmlNodeSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlNodeSyntax() { }
    }
    public sealed partial class XmlPrefixSyntax : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode
    {
        internal XmlPrefixSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken ColonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken Prefix { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax Update(Microsoft.CodeAnalysis.SyntaxToken prefix, Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax WithColonToken(Microsoft.CodeAnalysis.SyntaxToken colonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax WithPrefix(Microsoft.CodeAnalysis.SyntaxToken prefix) { throw null; }
    }
    public sealed partial class XmlProcessingInstructionSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlProcessingInstructionSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxToken EndProcessingInstructionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken StartProcessingInstructionToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax Update(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken, Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(Microsoft.CodeAnalysis.SyntaxToken endProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(Microsoft.CodeAnalysis.SyntaxToken startProcessingInstructionToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlTextAttributeSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax
    {
        internal XmlTextAttributeSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxToken EndQuoteToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken EqualsToken { get { throw null; } }
        public override Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax Name { get { throw null; } }
        public override Microsoft.CodeAnalysis.SyntaxToken StartQuoteToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax Update(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name, Microsoft.CodeAnalysis.SyntaxToken equalsToken, Microsoft.CodeAnalysis.SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.SyntaxTokenList textTokens, Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithEndQuoteToken(Microsoft.CodeAnalysis.SyntaxToken endQuoteToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithEqualsToken(Microsoft.CodeAnalysis.SyntaxToken equalsToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax name) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithStartQuoteToken(Microsoft.CodeAnalysis.SyntaxToken startQuoteToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class XmlTextSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax
    {
        internal XmlTextSyntax() { }
        public Microsoft.CodeAnalysis.SyntaxTokenList TextTokens { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax AddTextTokens(params Microsoft.CodeAnalysis.SyntaxToken[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax Update(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax WithTextTokens(Microsoft.CodeAnalysis.SyntaxTokenList textTokens) { throw null; }
    }
    public sealed partial class YieldStatementSyntax : Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax
    {
        internal YieldStatementSyntax() { }
        public override Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> AttributeLists { get { throw null; } }
        public Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? Expression { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken ReturnOrBreakKeyword { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken SemicolonToken { get { throw null; } }
        public Microsoft.CodeAnalysis.SyntaxToken YieldKeyword { get { throw null; } }
        public override void Accept(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor visitor) { }
        public override TResult? Accept<TResult>(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor<TResult> visitor) where TResult : default { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax AddAttributeLists(params Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax[] items) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax Update(Microsoft.CodeAnalysis.SyntaxToken yieldKeyword, Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax expression, Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public new Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithAttributeLists(Microsoft.CodeAnalysis.SyntaxList<Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax> attributeLists) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax? expression) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithReturnOrBreakKeyword(Microsoft.CodeAnalysis.SyntaxToken returnOrBreakKeyword) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithSemicolonToken(Microsoft.CodeAnalysis.SyntaxToken semicolonToken) { throw null; }
        public Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax WithYieldKeyword(Microsoft.CodeAnalysis.SyntaxToken yieldKeyword) { throw null; }
    }
}

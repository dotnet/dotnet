// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------
[assembly: System.Runtime.CompilerServices.CompilationRelaxations(8)]
[assembly: System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("csc, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("csi, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("VBCSCompiler.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Rebuild.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.CommandLine.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Emit.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Emit2.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EndToEnd.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.WinRT.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.IOperation.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Semantic.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Symbol.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Syntax.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Test.Utilities, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.ExpressionEvaluator.ExpressionCompiler.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Test.Utilities, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.Scripting.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.Scripting.Desktop.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("InteractiveHost.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.CSharp.EditorFeatures.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.CodeAnalysis.EditorFeatures2.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("CompilerBenchmarks, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Microsoft.Build.Tasks.CodeAnalysis.UnitTests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100b5fc90e7027f67871e773a8fde8938c81dd402ba65b9201d60593e96c492651e889cc13f1415ebb53fac1131ae0bd333c5ee6021672d9718ea31a8aebd0da0072f25d87dba6fc90ffd598ed4da35e44c398c454307e8e33b8426143daec9f596836f97c8f74750e5975c64e2189f45def46b2a2b1247adc3652bf5c308055da9")]
[assembly: System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly: System.Reflection.AssemblyConfiguration("Release")]
[assembly: System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")]
[assembly: System.Reflection.AssemblyFileVersion("4.600.23.25908")]
[assembly: System.Reflection.AssemblyInformationalVersion("4.6.0-3.23259.8+c3cc1d0ceeab1a65da0217e403851a1e8a30086a")]
[assembly: System.Reflection.AssemblyProduct("Microsoft.CodeAnalysis.CSharp")]
[assembly: System.Reflection.AssemblyTitle("Microsoft.CodeAnalysis.CSharp")]
[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/dotnet/roslyn")]
[assembly: System.Resources.NeutralResourcesLanguage("en-US")]
[assembly: System.Reflection.AssemblyVersionAttribute("4.6.0.0")]
[assembly: System.Runtime.CompilerServices.ReferenceAssembly]
[assembly: System.Reflection.AssemblyFlagsAttribute((System.Reflection.AssemblyNameFlags)0x70)]
namespace Microsoft.CodeAnalysis
{
    public static partial class CSharpExtensions
    {
        public static bool Any(this SyntaxTokenList list, CSharp.SyntaxKind kind) { throw null; }

        public static bool Any(this SyntaxTriviaList list, CSharp.SyntaxKind kind) { throw null; }

        public static bool Any<TNode>(this SeparatedSyntaxList<TNode> list, CSharp.SyntaxKind kind)
            where TNode : SyntaxNode { throw null; }

        public static bool Any<TNode>(this SyntaxList<TNode> list, CSharp.SyntaxKind kind)
            where TNode : SyntaxNode { throw null; }

        public static bool ContainsDirective(this SyntaxNode node, CSharp.SyntaxKind kind) { throw null; }

        public static int IndexOf(this SyntaxTokenList list, CSharp.SyntaxKind kind) { throw null; }

        public static int IndexOf(this SyntaxTriviaList list, CSharp.SyntaxKind kind) { throw null; }

        public static int IndexOf<TNode>(this SeparatedSyntaxList<TNode> list, CSharp.SyntaxKind kind)
            where TNode : SyntaxNode { throw null; }

        public static int IndexOf<TNode>(this SyntaxList<TNode> list, CSharp.SyntaxKind kind)
            where TNode : SyntaxNode { throw null; }

        public static bool IsKind(this SyntaxNode? node, CSharp.SyntaxKind kind) { throw null; }

        public static bool IsKind(this SyntaxNodeOrToken nodeOrToken, CSharp.SyntaxKind kind) { throw null; }

        public static bool IsKind(this SyntaxToken token, CSharp.SyntaxKind kind) { throw null; }

        public static bool IsKind(this SyntaxTrivia trivia, CSharp.SyntaxKind kind) { throw null; }
    }
}

namespace Microsoft.CodeAnalysis.CSharp
{
    public readonly partial struct AwaitExpressionInfo : System.IEquatable<AwaitExpressionInfo>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public IMethodSymbol? GetAwaiterMethod { get { throw null; } }

        public IMethodSymbol? GetResultMethod { get { throw null; } }

        public IPropertySymbol? IsCompletedProperty { get { throw null; } }

        public bool IsDynamic { get { throw null; } }

        public readonly bool Equals(AwaitExpressionInfo other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }
    }

    public readonly partial struct Conversion : System.IEquatable<Conversion>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public ITypeSymbol? ConstrainedToType { get { throw null; } }

        public bool Exists { get { throw null; } }

        public bool IsAnonymousFunction { get { throw null; } }

        public bool IsBoxing { get { throw null; } }

        public bool IsConditionalExpression { get { throw null; } }

        public bool IsConstantExpression { get { throw null; } }

        public bool IsDefaultLiteral { get { throw null; } }

        public bool IsDynamic { get { throw null; } }

        public bool IsEnumeration { get { throw null; } }

        public bool IsExplicit { get { throw null; } }

        public bool IsIdentity { get { throw null; } }

        public bool IsImplicit { get { throw null; } }

        public bool IsInterpolatedString { get { throw null; } }

        public bool IsInterpolatedStringHandler { get { throw null; } }

        public bool IsIntPtr { get { throw null; } }

        public bool IsMethodGroup { get { throw null; } }

        public bool IsNullable { get { throw null; } }

        public bool IsNullLiteral { get { throw null; } }

        public bool IsNumeric { get { throw null; } }

        public bool IsObjectCreation { get { throw null; } }

        public bool IsPointer { get { throw null; } }

        public bool IsReference { get { throw null; } }

        public bool IsStackAlloc { get { throw null; } }

        public bool IsSwitchExpression { get { throw null; } }

        public bool IsThrow { get { throw null; } }

        public bool IsTupleConversion { get { throw null; } }

        public bool IsTupleLiteralConversion { get { throw null; } }

        public bool IsUnboxing { get { throw null; } }

        public bool IsUserDefined { get { throw null; } }

        public IMethodSymbol? MethodSymbol { get { throw null; } }

        public readonly bool Equals(Conversion other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }

        public static bool operator ==(Conversion left, Conversion right) { throw null; }

        public static bool operator !=(Conversion left, Conversion right) { throw null; }

        public readonly Operations.CommonConversion ToCommonConversion() { throw null; }

        public override readonly string ToString() { throw null; }
    }

    public sealed partial class CSharpCommandLineArguments : CommandLineArguments
    {
        internal CSharpCommandLineArguments() { }

        public new CSharpCompilationOptions CompilationOptions { get { throw null; } }

        protected override CompilationOptions CompilationOptionsCore { get { throw null; } }

        public new CSharpParseOptions ParseOptions { get { throw null; } }

        protected override ParseOptions ParseOptionsCore { get { throw null; } }
    }

    public partial class CSharpCommandLineParser : CommandLineParser
    {
        internal CSharpCommandLineParser() { }

        public static CSharpCommandLineParser Default { get { throw null; } }

        protected override string RegularFileExtension { get { throw null; } }

        public static CSharpCommandLineParser Script { get { throw null; } }

        protected override string ScriptFileExtension { get { throw null; } }

        public new CSharpCommandLineArguments Parse(System.Collections.Generic.IEnumerable<string> args, string? baseDirectory, string? sdkDirectory, string? additionalReferenceDirectories = null) { throw null; }

        public static System.Collections.Generic.IEnumerable<string> ParseConditionalCompilationSymbols(string value, out System.Collections.Generic.IEnumerable<Diagnostic> diagnostics) { throw null; }
    }

    public sealed partial class CSharpCompilation : Compilation
    {
        internal CSharpCompilation() { }

        protected override IAssemblySymbol CommonAssembly { get { throw null; } }

        protected override ITypeSymbol CommonDynamicType { get { throw null; } }

        protected override INamespaceSymbol CommonGlobalNamespace { get { throw null; } }

        protected override INamedTypeSymbol CommonObjectType { get { throw null; } }

        protected override CompilationOptions CommonOptions { get { throw null; } }

        protected override INamedTypeSymbol? CommonScriptClass { get { throw null; } }

        protected override ITypeSymbol? CommonScriptGlobalsType { get { throw null; } }

        protected override IModuleSymbol CommonSourceModule { get { throw null; } }

        protected internal override System.Collections.Immutable.ImmutableArray<SyntaxTree> CommonSyntaxTrees { get { throw null; } }

        public override System.Collections.Immutable.ImmutableArray<MetadataReference> DirectiveReferences { get { throw null; } }

        public override bool IsCaseSensitive { get { throw null; } }

        public override string Language { get { throw null; } }

        public LanguageVersion LanguageVersion { get { throw null; } }

        public new CSharpCompilationOptions Options { get { throw null; } }

        public override System.Collections.Generic.IEnumerable<AssemblyIdentity> ReferencedAssemblyNames { get { throw null; } }

        public new CSharpScriptCompilationInfo? ScriptCompilationInfo { get { throw null; } }

        public new System.Collections.Immutable.ImmutableArray<SyntaxTree> SyntaxTrees { get { throw null; } }

        public new CSharpCompilation AddReferences(params MetadataReference[] references) { throw null; }

        public new CSharpCompilation AddReferences(System.Collections.Generic.IEnumerable<MetadataReference> references) { throw null; }

        public new CSharpCompilation AddSyntaxTrees(params SyntaxTree[] trees) { throw null; }

        public new CSharpCompilation AddSyntaxTrees(System.Collections.Generic.IEnumerable<SyntaxTree> trees) { throw null; }

        protected override void AppendDefaultVersionResource(System.IO.Stream resourceStream) { }

        public override Operations.CommonConversion ClassifyCommonConversion(ITypeSymbol source, ITypeSymbol destination) { throw null; }

        public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination) { throw null; }

        public new CSharpCompilation Clone() { throw null; }

        protected override Compilation CommonAddSyntaxTrees(System.Collections.Generic.IEnumerable<SyntaxTree> trees) { throw null; }

        protected override Compilation CommonClone() { throw null; }

        protected override bool CommonContainsSyntaxTree(SyntaxTree? syntaxTree) { throw null; }

        protected override INamedTypeSymbol CommonCreateAnonymousTypeSymbol(System.Collections.Immutable.ImmutableArray<ITypeSymbol> memberTypes, System.Collections.Immutable.ImmutableArray<string> memberNames, System.Collections.Immutable.ImmutableArray<Location> memberLocations, System.Collections.Immutable.ImmutableArray<bool> memberIsReadOnly, System.Collections.Immutable.ImmutableArray<NullableAnnotation> memberNullableAnnotations) { throw null; }

        protected override IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank, NullableAnnotation elementNullableAnnotation) { throw null; }

        protected override IMethodSymbol CommonCreateBuiltinOperator(string name, ITypeSymbol returnType, ITypeSymbol leftType, ITypeSymbol rightType) { throw null; }

        protected override IMethodSymbol CommonCreateBuiltinOperator(string name, ITypeSymbol returnType, ITypeSymbol operandType) { throw null; }

        protected override INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name) { throw null; }

        protected override INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol? container, string name, int arity) { throw null; }

        protected override IFunctionPointerTypeSymbol CommonCreateFunctionPointerTypeSymbol(ITypeSymbol returnType, RefKind returnRefKind, System.Collections.Immutable.ImmutableArray<ITypeSymbol> parameterTypes, System.Collections.Immutable.ImmutableArray<RefKind> parameterRefKinds, System.Reflection.Metadata.SignatureCallingConvention callingConvention, System.Collections.Immutable.ImmutableArray<INamedTypeSymbol> callingConventionTypes) { throw null; }

        protected override INamedTypeSymbol CommonCreateNativeIntegerTypeSymbol(bool signed) { throw null; }

        protected override IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType) { throw null; }

        protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, System.Collections.Immutable.ImmutableArray<string?> elementNames, System.Collections.Immutable.ImmutableArray<Location?> elementLocations, System.Collections.Immutable.ImmutableArray<NullableAnnotation> elementNullableAnnotations) { throw null; }

        protected override INamedTypeSymbol CommonCreateTupleTypeSymbol(System.Collections.Immutable.ImmutableArray<ITypeSymbol> elementTypes, System.Collections.Immutable.ImmutableArray<string?> elementNames, System.Collections.Immutable.ImmutableArray<Location?> elementLocations, System.Collections.Immutable.ImmutableArray<NullableAnnotation> elementNullableAnnotations) { throw null; }

        protected override ISymbol? CommonGetAssemblyOrModuleSymbol(MetadataReference reference) { throw null; }

        protected override INamespaceSymbol? CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol) { throw null; }

        protected override IMethodSymbol? CommonGetEntryPoint(System.Threading.CancellationToken cancellationToken) { throw null; }

        protected override SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }

        protected override INamedTypeSymbol? CommonGetTypeByMetadataName(string metadataName) { throw null; }

        protected override Compilation CommonRemoveAllSyntaxTrees() { throw null; }

        protected override Compilation CommonRemoveSyntaxTrees(System.Collections.Generic.IEnumerable<SyntaxTree> trees) { throw null; }

        protected override Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree? newTree) { throw null; }

        protected override Compilation CommonWithAssemblyName(string? assemblyName) { throw null; }

        protected override Compilation CommonWithOptions(CompilationOptions options) { throw null; }

        protected override Compilation CommonWithReferences(System.Collections.Generic.IEnumerable<MetadataReference> newReferences) { throw null; }

        protected override Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo? info) { throw null; }

        public override bool ContainsSymbolsWithName(System.Func<string, bool> predicate, SymbolFilter filter = SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override bool ContainsSymbolsWithName(string name, SymbolFilter filter = SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public new bool ContainsSyntaxTree(SyntaxTree? syntaxTree) { throw null; }

        public static CSharpCompilation Create(string? assemblyName, System.Collections.Generic.IEnumerable<SyntaxTree>? syntaxTrees = null, System.Collections.Generic.IEnumerable<MetadataReference>? references = null, CSharpCompilationOptions? options = null) { throw null; }

        public static CSharpCompilation CreateScriptCompilation(string assemblyName, SyntaxTree? syntaxTree = null, System.Collections.Generic.IEnumerable<MetadataReference>? references = null, CSharpCompilationOptions? options = null, CSharpCompilation? previousScriptCompilation = null, System.Type? returnType = null, System.Type? globalsType = null) { throw null; }

        public override System.Collections.Immutable.ImmutableArray<Diagnostic> GetDeclarationDiagnostics(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Immutable.ImmutableArray<Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public MetadataReference? GetDirectiveReference(Syntax.ReferenceDirectiveTriviaSyntax directive) { throw null; }

        public new MetadataReference? GetMetadataReference(IAssemblySymbol assemblySymbol) { throw null; }

        public override System.Collections.Immutable.ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Immutable.ImmutableArray<Diagnostic> GetParseDiagnostics(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public new SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility) { throw null; }

        public override System.Collections.Generic.IEnumerable<ISymbol> GetSymbolsWithName(System.Func<string, bool> predicate, SymbolFilter filter = SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Generic.IEnumerable<ISymbol> GetSymbolsWithName(string name, SymbolFilter filter = SymbolFilter.TypeAndMember, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Immutable.ImmutableArray<MetadataReference> GetUsedAssemblyReferences(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public new CSharpCompilation RemoveAllReferences() { throw null; }

        public new CSharpCompilation RemoveAllSyntaxTrees() { throw null; }

        public new CSharpCompilation RemoveReferences(params MetadataReference[] references) { throw null; }

        public new CSharpCompilation RemoveReferences(System.Collections.Generic.IEnumerable<MetadataReference> references) { throw null; }

        public new CSharpCompilation RemoveSyntaxTrees(params SyntaxTree[] trees) { throw null; }

        public new CSharpCompilation RemoveSyntaxTrees(System.Collections.Generic.IEnumerable<SyntaxTree> trees) { throw null; }

        public new CSharpCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference) { throw null; }

        public new CSharpCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree? newTree) { throw null; }

        public override CompilationReference ToMetadataReference(System.Collections.Immutable.ImmutableArray<string> aliases = default, bool embedInteropTypes = false) { throw null; }

        public new CSharpCompilation WithAssemblyName(string? assemblyName) { throw null; }

        public CSharpCompilation WithOptions(CSharpCompilationOptions options) { throw null; }

        public new CSharpCompilation WithReferences(params MetadataReference[] references) { throw null; }

        public new CSharpCompilation WithReferences(System.Collections.Generic.IEnumerable<MetadataReference>? references) { throw null; }

        public CSharpCompilation WithScriptCompilationInfo(CSharpScriptCompilationInfo? info) { throw null; }
    }

    public sealed partial class CSharpCompilationOptions : CompilationOptions, System.IEquatable<CSharpCompilationOptions>
    {
        public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string? moduleName = null, string? mainTypeName = null, string? scriptClassName = null, System.Collections.Generic.IEnumerable<string>? usings = null, OptimizationLevel optimizationLevel = OptimizationLevel.Debug, bool checkOverflow = false, bool allowUnsafe = false, string? cryptoKeyContainer = null, string? cryptoKeyFile = null, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey = default, bool? delaySign = null, Platform platform = Platform.AnyCpu, ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default, int warningLevel = 4, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver? xmlReferenceResolver = null, SourceReferenceResolver? sourceReferenceResolver = null, MetadataReferenceResolver? metadataReferenceResolver = null, AssemblyIdentityComparer? assemblyIdentityComparer = null, StrongNameProvider? strongNameProvider = null, bool publicSign = false, MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public, NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) { }

        public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver? xmlReferenceResolver, SourceReferenceResolver? sourceReferenceResolver, MetadataReferenceResolver? metadataReferenceResolver, AssemblyIdentityComparer? assemblyIdentityComparer, StrongNameProvider? strongNameProvider, bool publicSign, MetadataImportOptions metadataImportOptions) { }

        public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver? xmlReferenceResolver, SourceReferenceResolver? sourceReferenceResolver, MetadataReferenceResolver? metadataReferenceResolver, AssemblyIdentityComparer? assemblyIdentityComparer, StrongNameProvider? strongNameProvider, bool publicSign) { }

        public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver? xmlReferenceResolver, SourceReferenceResolver? sourceReferenceResolver, MetadataReferenceResolver? metadataReferenceResolver, AssemblyIdentityComparer? assemblyIdentityComparer, StrongNameProvider? strongNameProvider) { }

        public CSharpCompilationOptions(OutputKind outputKind, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver? xmlReferenceResolver, SourceReferenceResolver? sourceReferenceResolver, MetadataReferenceResolver? metadataReferenceResolver, AssemblyIdentityComparer? assemblyIdentityComparer, StrongNameProvider? strongNameProvider) { }

        public CSharpCompilationOptions(OutputKind outputKind, string? moduleName, string? mainTypeName, string? scriptClassName, System.Collections.Generic.IEnumerable<string>? usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string? cryptoKeyContainer, string? cryptoKeyFile, System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey, bool? delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver? xmlReferenceResolver, SourceReferenceResolver? sourceReferenceResolver, MetadataReferenceResolver? metadataReferenceResolver, AssemblyIdentityComparer? assemblyIdentityComparer, StrongNameProvider? strongNameProvider) { }

        public bool AllowUnsafe { get { throw null; } }

        public override string Language { get { throw null; } }

        public override NullableContextOptions NullableContextOptions { get { throw null; } protected set { } }

        public System.Collections.Immutable.ImmutableArray<string> Usings { get { throw null; } }

        protected override CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer? comparer) { throw null; }

        protected override CompilationOptions CommonWithCheckOverflow(bool checkOverflow) { throw null; }

        protected override CompilationOptions CommonWithConcurrentBuild(bool concurrent) { throw null; }

        protected override CompilationOptions CommonWithCryptoKeyContainer(string? cryptoKeyContainer) { throw null; }

        protected override CompilationOptions CommonWithCryptoKeyFile(string? cryptoKeyFile) { throw null; }

        protected override CompilationOptions CommonWithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> cryptoPublicKey) { throw null; }

        protected override CompilationOptions CommonWithDelaySign(bool? delaySign) { throw null; }

        protected override CompilationOptions CommonWithDeterministic(bool deterministic) { throw null; }

        [System.Obsolete]
        protected override CompilationOptions CommonWithFeatures(System.Collections.Immutable.ImmutableArray<string> features) { throw null; }

        protected override CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value) { throw null; }

        protected override CompilationOptions CommonWithMainTypeName(string? mainTypeName) { throw null; }

        protected override CompilationOptions CommonWithMetadataImportOptions(MetadataImportOptions value) { throw null; }

        protected override CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver? resolver) { throw null; }

        protected override CompilationOptions CommonWithModuleName(string? moduleName) { throw null; }

        protected override CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value) { throw null; }

        protected override CompilationOptions CommonWithOutputKind(OutputKind kind) { throw null; }

        protected override CompilationOptions CommonWithPlatform(Platform platform) { throw null; }

        protected override CompilationOptions CommonWithPublicSign(bool publicSign) { throw null; }

        protected override CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }

        protected override CompilationOptions CommonWithScriptClassName(string? scriptClassName) { throw null; }

        protected override CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver? resolver) { throw null; }

        protected override CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions) { throw null; }

        protected override CompilationOptions CommonWithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? specificDiagnosticOptions) { throw null; }

        protected override CompilationOptions CommonWithStrongNameProvider(StrongNameProvider? provider) { throw null; }

        protected override CompilationOptions CommonWithSyntaxTreeOptionsProvider(SyntaxTreeOptionsProvider? provider) { throw null; }

        protected override CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver? resolver) { throw null; }

        protected override int ComputeHashCode() { throw null; }

        public bool Equals(CSharpCompilationOptions? other) { throw null; }

        public override bool Equals(object? obj) { throw null; }

        public CSharpCompilationOptions WithAllowUnsafe(bool enabled) { throw null; }

        public new CSharpCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer? comparer) { throw null; }

        public new CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild) { throw null; }

        public new CSharpCompilationOptions WithCryptoKeyContainer(string? name) { throw null; }

        public new CSharpCompilationOptions WithCryptoKeyFile(string? path) { throw null; }

        public new CSharpCompilationOptions WithCryptoPublicKey(System.Collections.Immutable.ImmutableArray<byte> value) { throw null; }

        public new CSharpCompilationOptions WithDelaySign(bool? value) { throw null; }

        public new CSharpCompilationOptions WithDeterministic(bool deterministic) { throw null; }

        public new CSharpCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value) { throw null; }

        public new CSharpCompilationOptions WithMainTypeName(string? name) { throw null; }

        public new CSharpCompilationOptions WithMetadataImportOptions(MetadataImportOptions value) { throw null; }

        public new CSharpCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver? resolver) { throw null; }

        public new CSharpCompilationOptions WithModuleName(string? moduleName) { throw null; }

        public CSharpCompilationOptions WithNullableContextOptions(NullableContextOptions options) { throw null; }

        public new CSharpCompilationOptions WithOptimizationLevel(OptimizationLevel value) { throw null; }

        public new CSharpCompilationOptions WithOutputKind(OutputKind kind) { throw null; }

        public new CSharpCompilationOptions WithOverflowChecks(bool enabled) { throw null; }

        public new CSharpCompilationOptions WithPlatform(Platform platform) { throw null; }

        public new CSharpCompilationOptions WithPublicSign(bool publicSign) { throw null; }

        public new CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics) { throw null; }

        public new CSharpCompilationOptions WithScriptClassName(string? name) { throw null; }

        public new CSharpCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver? resolver) { throw null; }

        public new CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, ReportDiagnostic>>? values) { throw null; }

        public new CSharpCompilationOptions WithSpecificDiagnosticOptions(System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? values) { throw null; }

        public new CSharpCompilationOptions WithStrongNameProvider(StrongNameProvider? provider) { throw null; }

        public new CSharpCompilationOptions WithSyntaxTreeOptionsProvider(SyntaxTreeOptionsProvider? provider) { throw null; }

        public CSharpCompilationOptions WithUsings(System.Collections.Generic.IEnumerable<string>? usings) { throw null; }

        public CSharpCompilationOptions WithUsings(System.Collections.Immutable.ImmutableArray<string> usings) { throw null; }

        public CSharpCompilationOptions WithUsings(params string[]? usings) { throw null; }

        public CSharpCompilationOptions WithWarningLevel(int warningLevel) { throw null; }

        public new CSharpCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver? resolver) { throw null; }
    }

    public partial class CSharpDiagnosticFormatter : DiagnosticFormatter
    {
        internal CSharpDiagnosticFormatter() { }

        public static CSharpDiagnosticFormatter Instance { get { throw null; } }
    }

    public static partial class CSharpExtensions
    {
        public static ControlFlowAnalysis? AnalyzeControlFlow(this SemanticModel? semanticModel, Syntax.StatementSyntax firstStatement, Syntax.StatementSyntax lastStatement) { throw null; }

        public static ControlFlowAnalysis? AnalyzeControlFlow(this SemanticModel? semanticModel, Syntax.StatementSyntax statement) { throw null; }

        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, Syntax.ConstructorInitializerSyntax constructorInitializer) { throw null; }

        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression) { throw null; }

        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, Syntax.PrimaryConstructorBaseTypeSyntax primaryConstructorBaseType) { throw null; }

        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, Syntax.StatementSyntax firstStatement, Syntax.StatementSyntax lastStatement) { throw null; }

        public static DataFlowAnalysis? AnalyzeDataFlow(this SemanticModel? semanticModel, Syntax.StatementSyntax statement) { throw null; }

        public static Conversion ClassifyConversion(this Compilation? compilation, ITypeSymbol source, ITypeSymbol destination) { throw null; }

        public static Conversion ClassifyConversion(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false) { throw null; }

        public static Conversion ClassifyConversion(this SemanticModel? semanticModel, int position, Syntax.ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource = false) { throw null; }

        public static IAliasSymbol? GetAliasInfo(this SemanticModel? semanticModel, Syntax.IdentifierNameSyntax nameSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static AwaitExpressionInfo GetAwaitExpressionInfo(this SemanticModel? semanticModel, Syntax.AwaitExpressionSyntax awaitExpression) { throw null; }

        public static SymbolInfo GetCollectionInitializerSymbolInfo(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static Syntax.CompilationUnitSyntax GetCompilationUnitRoot(this SyntaxTree tree, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static Optional<object> GetConstantValue(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static Conversion GetConversion(this Operations.IConversionOperation conversionExpression) { throw null; }

        public static Conversion GetConversion(this SemanticModel? semanticModel, SyntaxNode expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IMethodSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.AccessorDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamedTypeSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.AnonymousObjectCreationExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IPropertySymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.ArgumentSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IMethodSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.BaseMethodDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.BasePropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamedTypeSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.BaseTypeDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ILocalSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.CatchDeclarationSyntax catchDeclaration, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IMethodSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.CompilationUnitSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamedTypeSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.DelegateDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IFieldSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.EnumMemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IEventSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.EventDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IAliasSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.ExternAliasDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamespaceSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.FileScopedNamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ILocalSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.ForEachStatementSyntax forEachStatement, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IPropertySymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.IndexerDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IRangeVariableSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.JoinIntoClauseSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ILabelSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.LabeledStatementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.MemberDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamespaceSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.NamespaceDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IParameterSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.ParameterSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IPropertySymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.PropertyDeclarationSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IRangeVariableSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.QueryClauseSyntax queryClause, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IRangeVariableSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.QueryContinuationSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.SingleVariableDesignationSyntax designationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ILabelSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.SwitchLabelSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.TupleElementSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static INamedTypeSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.TupleExpressionSyntax declaratorSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ITypeParameterSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.TypeParameterSyntax typeParameter, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IAliasSymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.UsingDirectiveSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static ISymbol? GetDeclaredSymbol(this SemanticModel? semanticModel, Syntax.VariableDeclaratorSyntax declarationSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static DeconstructionInfo GetDeconstructionInfo(this SemanticModel? semanticModel, Syntax.AssignmentExpressionSyntax assignment) { throw null; }

        public static DeconstructionInfo GetDeconstructionInfo(this SemanticModel? semanticModel, Syntax.ForEachVariableStatementSyntax @foreach) { throw null; }

        public static Syntax.DirectiveTriviaSyntax? GetFirstDirective(this SyntaxNode node, System.Func<Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel? semanticModel, Syntax.CommonForEachStatementSyntax forEachStatement) { throw null; }

        public static ForEachStatementInfo GetForEachStatementInfo(this SemanticModel? semanticModel, Syntax.ForEachStatementSyntax forEachStatement) { throw null; }

        public static Conversion GetInConversion(this Operations.ICompoundAssignmentOperation compoundAssignment) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<IPropertySymbol> GetIndexerGroup(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static Syntax.DirectiveTriviaSyntax? GetLastDirective(this SyntaxNode node, System.Func<Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel? semanticModel, Syntax.AttributeSyntax attribute, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel? semanticModel, Syntax.ConstructorInitializerSyntax initializer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static Conversion GetOutConversion(this Operations.ICompoundAssignmentOperation compoundAssignment) { throw null; }

        public static QueryClauseInfo GetQueryClauseInfo(this SemanticModel? semanticModel, Syntax.QueryClauseSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static IAliasSymbol? GetSpeculativeAliasInfo(this SemanticModel? semanticModel, int position, Syntax.IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption) { throw null; }

        public static Conversion GetSpeculativeConversion(this SemanticModel? semanticModel, int position, Syntax.ExpressionSyntax expression, SpeculativeBindingOption bindingOption) { throw null; }

        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, int position, Syntax.AttributeSyntax attribute) { throw null; }

        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, int position, Syntax.ConstructorInitializerSyntax constructorInitializer) { throw null; }

        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, int position, Syntax.CrefSyntax expression, SpeculativeBindingOption bindingOption) { throw null; }

        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, int position, Syntax.ExpressionSyntax expression, SpeculativeBindingOption bindingOption) { throw null; }

        public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel? semanticModel, int position, Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer) { throw null; }

        public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel? semanticModel, int position, Syntax.ExpressionSyntax expression, SpeculativeBindingOption bindingOption) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.CrefSyntax crefSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.OrderingSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SymbolInfo GetSymbolInfo(this SemanticModel? semanticModel, Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static TypeInfo GetTypeInfo(this SemanticModel? semanticModel, Syntax.AttributeSyntax attributeSyntax, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static TypeInfo GetTypeInfo(this SemanticModel? semanticModel, Syntax.ConstructorInitializerSyntax constructorInitializer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static TypeInfo GetTypeInfo(this SemanticModel? semanticModel, Syntax.ExpressionSyntax expression, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static TypeInfo GetTypeInfo(this SemanticModel? semanticModel, Syntax.SelectOrGroupClauseSyntax node, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SyntaxTokenList Insert(this SyntaxTokenList list, int index, params SyntaxToken[] items) { throw null; }

        public static bool IsContextualKeyword(this SyntaxToken token) { throw null; }

        public static bool IsKeyword(this SyntaxToken token) { throw null; }

        public static bool IsReservedKeyword(this SyntaxToken token) { throw null; }

        public static bool IsVerbatimIdentifier(this SyntaxToken token) { throw null; }

        public static bool IsVerbatimStringLiteral(this SyntaxToken token) { throw null; }

        public static SyntaxKind Kind(this SyntaxNode node) { throw null; }

        public static SyntaxKind Kind(this SyntaxNodeOrToken nodeOrToken) { throw null; }

        public static SyntaxKind Kind(this SyntaxToken token) { throw null; }

        public static SyntaxKind Kind(this SyntaxTrivia trivia) { throw null; }

        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia) { throw null; }

        public static SyntaxToken ReplaceTrivia(this SyntaxToken token, System.Collections.Generic.IEnumerable<SyntaxTrivia> trivia, System.Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.ArrowExpressionClauseSyntax expressionBody, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.AttributeSyntax attribute, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.ConstructorInitializerSyntax constructorInitializer, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.CrefSyntax crefSyntax, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.EqualsValueClauseSyntax initializer, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.PrimaryConstructorBaseTypeSyntax constructorInitializer, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.StatementSyntax statement, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModel(this SemanticModel? semanticModel, int position, Syntax.TypeSyntax type, out SemanticModel? speculativeModel, SpeculativeBindingOption bindingOption = SpeculativeBindingOption.BindAsExpression) { throw null; }

        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel? semanticModel, int position, Syntax.AccessorDeclarationSyntax accessor, out SemanticModel? speculativeModel) { throw null; }

        public static bool TryGetSpeculativeSemanticModelForMethodBody(this SemanticModel? semanticModel, int position, Syntax.BaseMethodDeclarationSyntax method, out SemanticModel? speculativeModel) { throw null; }

        public static VarianceKind VarianceKindFromToken(this SyntaxToken node) { throw null; }
    }

    public static partial class CSharpFileSystemExtensions
    {
        public static CodeAnalysis.Emit.EmitResult Emit(this CSharpCompilation compilation, string outputPath, string? pdbPath = null, string? xmlDocumentationPath = null, string? win32ResourcesPath = null, System.Collections.Generic.IEnumerable<ResourceDescription>? manifestResources = null, System.Threading.CancellationToken cancellationToken = default) { throw null; }
    }

    public sealed partial class CSharpGeneratorDriver : GeneratorDriver
    {
        internal CSharpGeneratorDriver() { }

        public static CSharpGeneratorDriver Create(params IIncrementalGenerator[] incrementalGenerators) { throw null; }

        public static CSharpGeneratorDriver Create(params ISourceGenerator[] generators) { throw null; }

        public static CSharpGeneratorDriver Create(System.Collections.Generic.IEnumerable<ISourceGenerator> generators, System.Collections.Generic.IEnumerable<AdditionalText>? additionalTexts = null, CSharpParseOptions? parseOptions = null, Diagnostics.AnalyzerConfigOptionsProvider? optionsProvider = null, GeneratorDriverOptions driverOptions = default) { throw null; }

        public static CSharpGeneratorDriver Create(System.Collections.Generic.IEnumerable<ISourceGenerator> generators, System.Collections.Generic.IEnumerable<AdditionalText>? additionalTexts, CSharpParseOptions? parseOptions, Diagnostics.AnalyzerConfigOptionsProvider? optionsProvider) { throw null; }
    }

    public sealed partial class CSharpParseOptions : ParseOptions, System.IEquatable<CSharpParseOptions>
    {
        public CSharpParseOptions(LanguageVersion languageVersion = LanguageVersion.Default, DocumentationMode documentationMode = DocumentationMode.Parse, SourceCodeKind kind = SourceCodeKind.Regular, System.Collections.Generic.IEnumerable<string>? preprocessorSymbols = null) { }

        public static CSharpParseOptions Default { get { throw null; } }

        public override System.Collections.Generic.IReadOnlyDictionary<string, string> Features { get { throw null; } }

        public override string Language { get { throw null; } }

        public LanguageVersion LanguageVersion { get { throw null; } }

        public override System.Collections.Generic.IEnumerable<string> PreprocessorSymbolNames { get { throw null; } }

        public LanguageVersion SpecifiedLanguageVersion { get { throw null; } }

        protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode) { throw null; }

        protected override ParseOptions CommonWithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>? features) { throw null; }

        public override ParseOptions CommonWithKind(SourceCodeKind kind) { throw null; }

        public bool Equals(CSharpParseOptions? other) { throw null; }

        public override bool Equals(object? obj) { throw null; }

        public override int GetHashCode() { throw null; }

        public new CSharpParseOptions WithDocumentationMode(DocumentationMode documentationMode) { throw null; }

        public new CSharpParseOptions WithFeatures(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>? features) { throw null; }

        public new CSharpParseOptions WithKind(SourceCodeKind kind) { throw null; }

        public CSharpParseOptions WithLanguageVersion(LanguageVersion version) { throw null; }

        public CSharpParseOptions WithPreprocessorSymbols(System.Collections.Generic.IEnumerable<string>? preprocessorSymbols) { throw null; }

        public CSharpParseOptions WithPreprocessorSymbols(System.Collections.Immutable.ImmutableArray<string> symbols) { throw null; }

        public CSharpParseOptions WithPreprocessorSymbols(params string[]? preprocessorSymbols) { throw null; }
    }

    public sealed partial class CSharpScriptCompilationInfo : ScriptCompilationInfo
    {
        internal CSharpScriptCompilationInfo() { }

        public new CSharpCompilation? PreviousScriptCompilation { get { throw null; } }

        public CSharpScriptCompilationInfo WithPreviousScriptCompilation(CSharpCompilation? compilation) { throw null; }
    }

    public abstract partial class CSharpSyntaxNode : SyntaxNode, System.IFormattable
    {
        internal CSharpSyntaxNode() { }

        public override string Language { get { throw null; } }

        protected override SyntaxTree SyntaxTreeCore { get { throw null; } }

        public abstract void Accept(CSharpSyntaxVisitor visitor);
        public abstract TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor);
        public static SyntaxNode DeserializeFrom(System.IO.Stream stream, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        protected override bool EquivalentToCore(SyntaxNode other) { throw null; }

        public new SyntaxToken FindToken(int position, bool findInsideTrivia = false) { throw null; }

        public new SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false) { throw null; }

        public new SyntaxTrivia FindTrivia(int position, System.Func<SyntaxTrivia, bool> stepInto) { throw null; }

        public new System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics() { throw null; }

        public Syntax.DirectiveTriviaSyntax? GetFirstDirective(System.Func<Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public new SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false) { throw null; }

        public Syntax.DirectiveTriviaSyntax? GetLastDirective(System.Func<Syntax.DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public new SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false) { throw null; }

        public new SyntaxTriviaList GetLeadingTrivia() { throw null; }

        public new Location GetLocation() { throw null; }

        public new SyntaxTriviaList GetTrailingTrivia() { throw null; }

        protected internal override SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, System.Collections.Generic.IEnumerable<SyntaxNode> nodesToInsert, bool insertBefore) { throw null; }

        protected internal override SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, System.Collections.Generic.IEnumerable<SyntaxToken> newTokens, bool insertBefore) { throw null; }

        protected internal override SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<SyntaxTrivia> newTrivia, bool insertBefore) { throw null; }

        protected override bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false) { throw null; }

        public SyntaxKind Kind() { throw null; }

        protected internal override SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia) { throw null; }

        protected internal override SyntaxNode? RemoveNodesCore(System.Collections.Generic.IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options) { throw null; }

        protected internal override SyntaxNode ReplaceCore<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes = null, System.Func<TNode, TNode, SyntaxNode>? computeReplacementNode = null, System.Collections.Generic.IEnumerable<SyntaxToken>? tokens = null, System.Func<SyntaxToken, SyntaxToken, SyntaxToken>? computeReplacementToken = null, System.Collections.Generic.IEnumerable<SyntaxTrivia>? trivia = null, System.Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia>? computeReplacementTrivia = null) { throw null; }

        protected internal override SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, System.Collections.Generic.IEnumerable<SyntaxNode> replacementNodes) { throw null; }

        protected internal override SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, System.Collections.Generic.IEnumerable<SyntaxToken> newTokens) { throw null; }

        protected internal override SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, System.Collections.Generic.IEnumerable<SyntaxTrivia> newTrivia) { throw null; }

        string System.IFormattable.ToString(string? format, System.IFormatProvider? formatProvider) { throw null; }
    }

    public abstract partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode?>
    {
        public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia = false) { }

        public virtual bool VisitIntoStructuredTrivia { get { throw null; } }

        public override SyntaxNode? Visit(SyntaxNode? node) { throw null; }

        public override SyntaxNode? VisitAccessorDeclaration(Syntax.AccessorDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitAccessorList(Syntax.AccessorListSyntax node) { throw null; }

        public override SyntaxNode? VisitAliasQualifiedName(Syntax.AliasQualifiedNameSyntax node) { throw null; }

        public override SyntaxNode? VisitAnonymousMethodExpression(Syntax.AnonymousMethodExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitAnonymousObjectCreationExpression(Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitAnonymousObjectMemberDeclarator(Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }

        public override SyntaxNode? VisitArgument(Syntax.ArgumentSyntax node) { throw null; }

        public override SyntaxNode? VisitArgumentList(Syntax.ArgumentListSyntax node) { throw null; }

        public override SyntaxNode? VisitArrayCreationExpression(Syntax.ArrayCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitArrayRankSpecifier(Syntax.ArrayRankSpecifierSyntax node) { throw null; }

        public override SyntaxNode? VisitArrayType(Syntax.ArrayTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitArrowExpressionClause(Syntax.ArrowExpressionClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitAssignmentExpression(Syntax.AssignmentExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitAttribute(Syntax.AttributeSyntax node) { throw null; }

        public override SyntaxNode? VisitAttributeArgument(Syntax.AttributeArgumentSyntax node) { throw null; }

        public override SyntaxNode? VisitAttributeArgumentList(Syntax.AttributeArgumentListSyntax node) { throw null; }

        public override SyntaxNode? VisitAttributeList(Syntax.AttributeListSyntax node) { throw null; }

        public override SyntaxNode? VisitAttributeTargetSpecifier(Syntax.AttributeTargetSpecifierSyntax node) { throw null; }

        public override SyntaxNode? VisitAwaitExpression(Syntax.AwaitExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitBadDirectiveTrivia(Syntax.BadDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitBaseExpression(Syntax.BaseExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitBaseList(Syntax.BaseListSyntax node) { throw null; }

        public override SyntaxNode? VisitBinaryExpression(Syntax.BinaryExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitBinaryPattern(Syntax.BinaryPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitBlock(Syntax.BlockSyntax node) { throw null; }

        public override SyntaxNode? VisitBracketedArgumentList(Syntax.BracketedArgumentListSyntax node) { throw null; }

        public override SyntaxNode? VisitBracketedParameterList(Syntax.BracketedParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitBreakStatement(Syntax.BreakStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitCasePatternSwitchLabel(Syntax.CasePatternSwitchLabelSyntax node) { throw null; }

        public override SyntaxNode? VisitCaseSwitchLabel(Syntax.CaseSwitchLabelSyntax node) { throw null; }

        public override SyntaxNode? VisitCastExpression(Syntax.CastExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitCatchClause(Syntax.CatchClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitCatchDeclaration(Syntax.CatchDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitCatchFilterClause(Syntax.CatchFilterClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitCheckedExpression(Syntax.CheckedExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitCheckedStatement(Syntax.CheckedStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitClassDeclaration(Syntax.ClassDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitClassOrStructConstraint(Syntax.ClassOrStructConstraintSyntax node) { throw null; }

        public override SyntaxNode? VisitCompilationUnit(Syntax.CompilationUnitSyntax node) { throw null; }

        public override SyntaxNode? VisitConditionalAccessExpression(Syntax.ConditionalAccessExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitConditionalExpression(Syntax.ConditionalExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitConstantPattern(Syntax.ConstantPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitConstructorConstraint(Syntax.ConstructorConstraintSyntax node) { throw null; }

        public override SyntaxNode? VisitConstructorDeclaration(Syntax.ConstructorDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitConstructorInitializer(Syntax.ConstructorInitializerSyntax node) { throw null; }

        public override SyntaxNode? VisitContinueStatement(Syntax.ContinueStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitConversionOperatorDeclaration(Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitConversionOperatorMemberCref(Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitCrefBracketedParameterList(Syntax.CrefBracketedParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitCrefParameter(Syntax.CrefParameterSyntax node) { throw null; }

        public override SyntaxNode? VisitCrefParameterList(Syntax.CrefParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitDeclarationExpression(Syntax.DeclarationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitDeclarationPattern(Syntax.DeclarationPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitDefaultConstraint(Syntax.DefaultConstraintSyntax node) { throw null; }

        public override SyntaxNode? VisitDefaultExpression(Syntax.DefaultExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitDefaultSwitchLabel(Syntax.DefaultSwitchLabelSyntax node) { throw null; }

        public override SyntaxNode? VisitDefineDirectiveTrivia(Syntax.DefineDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitDelegateDeclaration(Syntax.DelegateDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitDestructorDeclaration(Syntax.DestructorDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitDiscardDesignation(Syntax.DiscardDesignationSyntax node) { throw null; }

        public override SyntaxNode? VisitDiscardPattern(Syntax.DiscardPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitDocumentationCommentTrivia(Syntax.DocumentationCommentTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitDoStatement(Syntax.DoStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitElementAccessExpression(Syntax.ElementAccessExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitElementBindingExpression(Syntax.ElementBindingExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitElifDirectiveTrivia(Syntax.ElifDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitElseClause(Syntax.ElseClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitElseDirectiveTrivia(Syntax.ElseDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitEmptyStatement(Syntax.EmptyStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitEndIfDirectiveTrivia(Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitEndRegionDirectiveTrivia(Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitEnumDeclaration(Syntax.EnumDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitEnumMemberDeclaration(Syntax.EnumMemberDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitEqualsValueClause(Syntax.EqualsValueClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitErrorDirectiveTrivia(Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitEventDeclaration(Syntax.EventDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitEventFieldDeclaration(Syntax.EventFieldDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitExplicitInterfaceSpecifier(Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }

        public override SyntaxNode? VisitExpressionColon(Syntax.ExpressionColonSyntax node) { throw null; }

        public override SyntaxNode? VisitExpressionStatement(Syntax.ExpressionStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitExternAliasDirective(Syntax.ExternAliasDirectiveSyntax node) { throw null; }

        public override SyntaxNode? VisitFieldDeclaration(Syntax.FieldDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitFileScopedNamespaceDeclaration(Syntax.FileScopedNamespaceDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitFinallyClause(Syntax.FinallyClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitFixedStatement(Syntax.FixedStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitForEachStatement(Syntax.ForEachStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitForEachVariableStatement(Syntax.ForEachVariableStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitForStatement(Syntax.ForStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitFromClause(Syntax.FromClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerCallingConvention(Syntax.FunctionPointerCallingConventionSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerParameter(Syntax.FunctionPointerParameterSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerParameterList(Syntax.FunctionPointerParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerType(Syntax.FunctionPointerTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerUnmanagedCallingConvention(Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { throw null; }

        public override SyntaxNode? VisitFunctionPointerUnmanagedCallingConventionList(Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { throw null; }

        public override SyntaxNode? VisitGenericName(Syntax.GenericNameSyntax node) { throw null; }

        public override SyntaxNode? VisitGlobalStatement(Syntax.GlobalStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitGotoStatement(Syntax.GotoStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitGroupClause(Syntax.GroupClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitIdentifierName(Syntax.IdentifierNameSyntax node) { throw null; }

        public override SyntaxNode? VisitIfDirectiveTrivia(Syntax.IfDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitIfStatement(Syntax.IfStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitImplicitArrayCreationExpression(Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitImplicitElementAccess(Syntax.ImplicitElementAccessSyntax node) { throw null; }

        public override SyntaxNode? VisitImplicitObjectCreationExpression(Syntax.ImplicitObjectCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitImplicitStackAllocArrayCreationExpression(Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitIncompleteMember(Syntax.IncompleteMemberSyntax node) { throw null; }

        public override SyntaxNode? VisitIndexerDeclaration(Syntax.IndexerDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitIndexerMemberCref(Syntax.IndexerMemberCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitInitializerExpression(Syntax.InitializerExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitInterfaceDeclaration(Syntax.InterfaceDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitInterpolatedStringExpression(Syntax.InterpolatedStringExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitInterpolatedStringText(Syntax.InterpolatedStringTextSyntax node) { throw null; }

        public override SyntaxNode? VisitInterpolation(Syntax.InterpolationSyntax node) { throw null; }

        public override SyntaxNode? VisitInterpolationAlignmentClause(Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitInterpolationFormatClause(Syntax.InterpolationFormatClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitInvocationExpression(Syntax.InvocationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitIsPatternExpression(Syntax.IsPatternExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitJoinClause(Syntax.JoinClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitJoinIntoClause(Syntax.JoinIntoClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitLabeledStatement(Syntax.LabeledStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitLetClause(Syntax.LetClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitLineDirectivePosition(Syntax.LineDirectivePositionSyntax node) { throw null; }

        public override SyntaxNode? VisitLineDirectiveTrivia(Syntax.LineDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitLineSpanDirectiveTrivia(Syntax.LineSpanDirectiveTriviaSyntax node) { throw null; }

        public virtual SyntaxTokenList VisitList(SyntaxTokenList list) { throw null; }

        public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list) { throw null; }

        public virtual SeparatedSyntaxList<TNode> VisitList<TNode>(SeparatedSyntaxList<TNode> list)
            where TNode : SyntaxNode { throw null; }

        public virtual SyntaxList<TNode> VisitList<TNode>(SyntaxList<TNode> list)
            where TNode : SyntaxNode { throw null; }

        public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element) { throw null; }

        public virtual TNode? VisitListElement<TNode>(TNode? node)
            where TNode : SyntaxNode { throw null; }

        public override SyntaxNode? VisitListPattern(Syntax.ListPatternSyntax node) { throw null; }

        public virtual SyntaxToken VisitListSeparator(SyntaxToken separator) { throw null; }

        public override SyntaxNode? VisitLiteralExpression(Syntax.LiteralExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitLoadDirectiveTrivia(Syntax.LoadDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitLocalDeclarationStatement(Syntax.LocalDeclarationStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitLocalFunctionStatement(Syntax.LocalFunctionStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitLockStatement(Syntax.LockStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitMakeRefExpression(Syntax.MakeRefExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitMemberAccessExpression(Syntax.MemberAccessExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitMemberBindingExpression(Syntax.MemberBindingExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitMethodDeclaration(Syntax.MethodDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitNameColon(Syntax.NameColonSyntax node) { throw null; }

        public override SyntaxNode? VisitNameEquals(Syntax.NameEqualsSyntax node) { throw null; }

        public override SyntaxNode? VisitNameMemberCref(Syntax.NameMemberCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitNamespaceDeclaration(Syntax.NamespaceDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitNullableDirectiveTrivia(Syntax.NullableDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitNullableType(Syntax.NullableTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitObjectCreationExpression(Syntax.ObjectCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitOmittedArraySizeExpression(Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitOmittedTypeArgument(Syntax.OmittedTypeArgumentSyntax node) { throw null; }

        public override SyntaxNode? VisitOperatorDeclaration(Syntax.OperatorDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitOperatorMemberCref(Syntax.OperatorMemberCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitOrderByClause(Syntax.OrderByClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitOrdering(Syntax.OrderingSyntax node) { throw null; }

        public override SyntaxNode? VisitParameter(Syntax.ParameterSyntax node) { throw null; }

        public override SyntaxNode? VisitParameterList(Syntax.ParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitParenthesizedExpression(Syntax.ParenthesizedExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitParenthesizedLambdaExpression(Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitParenthesizedPattern(Syntax.ParenthesizedPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitParenthesizedVariableDesignation(Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }

        public override SyntaxNode? VisitPointerType(Syntax.PointerTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitPositionalPatternClause(Syntax.PositionalPatternClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitPostfixUnaryExpression(Syntax.PostfixUnaryExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitPragmaChecksumDirectiveTrivia(Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitPragmaWarningDirectiveTrivia(Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitPredefinedType(Syntax.PredefinedTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitPrefixUnaryExpression(Syntax.PrefixUnaryExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitPrimaryConstructorBaseType(Syntax.PrimaryConstructorBaseTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitPropertyDeclaration(Syntax.PropertyDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitPropertyPatternClause(Syntax.PropertyPatternClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitQualifiedCref(Syntax.QualifiedCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitQualifiedName(Syntax.QualifiedNameSyntax node) { throw null; }

        public override SyntaxNode? VisitQueryBody(Syntax.QueryBodySyntax node) { throw null; }

        public override SyntaxNode? VisitQueryContinuation(Syntax.QueryContinuationSyntax node) { throw null; }

        public override SyntaxNode? VisitQueryExpression(Syntax.QueryExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitRangeExpression(Syntax.RangeExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitRecordDeclaration(Syntax.RecordDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitRecursivePattern(Syntax.RecursivePatternSyntax node) { throw null; }

        public override SyntaxNode? VisitReferenceDirectiveTrivia(Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitRefExpression(Syntax.RefExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitRefType(Syntax.RefTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitRefTypeExpression(Syntax.RefTypeExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitRefValueExpression(Syntax.RefValueExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitRegionDirectiveTrivia(Syntax.RegionDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitRelationalPattern(Syntax.RelationalPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitReturnStatement(Syntax.ReturnStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitScopedType(Syntax.ScopedTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitSelectClause(Syntax.SelectClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitShebangDirectiveTrivia(Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitSimpleBaseType(Syntax.SimpleBaseTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitSimpleLambdaExpression(Syntax.SimpleLambdaExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitSingleVariableDesignation(Syntax.SingleVariableDesignationSyntax node) { throw null; }

        public override SyntaxNode? VisitSizeOfExpression(Syntax.SizeOfExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitSkippedTokensTrivia(Syntax.SkippedTokensTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitSlicePattern(Syntax.SlicePatternSyntax node) { throw null; }

        public override SyntaxNode? VisitStackAllocArrayCreationExpression(Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitStructDeclaration(Syntax.StructDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitSubpattern(Syntax.SubpatternSyntax node) { throw null; }

        public override SyntaxNode? VisitSwitchExpression(Syntax.SwitchExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitSwitchExpressionArm(Syntax.SwitchExpressionArmSyntax node) { throw null; }

        public override SyntaxNode? VisitSwitchSection(Syntax.SwitchSectionSyntax node) { throw null; }

        public override SyntaxNode? VisitSwitchStatement(Syntax.SwitchStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitThisExpression(Syntax.ThisExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitThrowExpression(Syntax.ThrowExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitThrowStatement(Syntax.ThrowStatementSyntax node) { throw null; }

        public virtual SyntaxToken VisitToken(SyntaxToken token) { throw null; }

        public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia) { throw null; }

        public override SyntaxNode? VisitTryStatement(Syntax.TryStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitTupleElement(Syntax.TupleElementSyntax node) { throw null; }

        public override SyntaxNode? VisitTupleExpression(Syntax.TupleExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitTupleType(Syntax.TupleTypeSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeArgumentList(Syntax.TypeArgumentListSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeConstraint(Syntax.TypeConstraintSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeCref(Syntax.TypeCrefSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeOfExpression(Syntax.TypeOfExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeParameter(Syntax.TypeParameterSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeParameterConstraintClause(Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitTypeParameterList(Syntax.TypeParameterListSyntax node) { throw null; }

        public override SyntaxNode? VisitTypePattern(Syntax.TypePatternSyntax node) { throw null; }

        public override SyntaxNode? VisitUnaryPattern(Syntax.UnaryPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitUndefDirectiveTrivia(Syntax.UndefDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitUnsafeStatement(Syntax.UnsafeStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitUsingDirective(Syntax.UsingDirectiveSyntax node) { throw null; }

        public override SyntaxNode? VisitUsingStatement(Syntax.UsingStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitVariableDeclaration(Syntax.VariableDeclarationSyntax node) { throw null; }

        public override SyntaxNode? VisitVariableDeclarator(Syntax.VariableDeclaratorSyntax node) { throw null; }

        public override SyntaxNode? VisitVarPattern(Syntax.VarPatternSyntax node) { throw null; }

        public override SyntaxNode? VisitWarningDirectiveTrivia(Syntax.WarningDirectiveTriviaSyntax node) { throw null; }

        public override SyntaxNode? VisitWhenClause(Syntax.WhenClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitWhereClause(Syntax.WhereClauseSyntax node) { throw null; }

        public override SyntaxNode? VisitWhileStatement(Syntax.WhileStatementSyntax node) { throw null; }

        public override SyntaxNode? VisitWithExpression(Syntax.WithExpressionSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlCDataSection(Syntax.XmlCDataSectionSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlComment(Syntax.XmlCommentSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlCrefAttribute(Syntax.XmlCrefAttributeSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlElement(Syntax.XmlElementSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlElementEndTag(Syntax.XmlElementEndTagSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlElementStartTag(Syntax.XmlElementStartTagSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlEmptyElement(Syntax.XmlEmptyElementSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlName(Syntax.XmlNameSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlNameAttribute(Syntax.XmlNameAttributeSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlPrefix(Syntax.XmlPrefixSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlProcessingInstruction(Syntax.XmlProcessingInstructionSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlText(Syntax.XmlTextSyntax node) { throw null; }

        public override SyntaxNode? VisitXmlTextAttribute(Syntax.XmlTextAttributeSyntax node) { throw null; }

        public override SyntaxNode? VisitYieldStatement(Syntax.YieldStatementSyntax node) { throw null; }
    }

    public abstract partial class CSharpSyntaxTree : SyntaxTree
    {
        public CSharpSyntaxTree() { }

        public abstract new CSharpParseOptions Options { get; }

        protected override ParseOptions OptionsCore { get { throw null; } }

        protected T CloneNodeAsRoot<T>(T node)
            where T : CSharpSyntaxNode { throw null; }

        [System.Obsolete("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions? options, string? path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode) { throw null; }

        [System.Obsolete("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions? options, string? path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions) { throw null; }

        public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions? options = null, string? path = "", System.Text.Encoding? encoding = null) { throw null; }

        public override System.Collections.Generic.IList<Text.TextSpan> GetChangedSpans(SyntaxTree oldTree) { throw null; }

        public override System.Collections.Generic.IList<Text.TextChange> GetChanges(SyntaxTree oldTree) { throw null; }

        public Syntax.CompilationUnitSyntax GetCompilationUnitRoot(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node) { throw null; }

        public override System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken) { throw null; }

        public override System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token) { throw null; }

        public override System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia) { throw null; }

        public override System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override System.Collections.Generic.IEnumerable<LineMapping> GetLineMappings(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override FileLinePositionSpan GetLineSpan(Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override LineVisibility GetLineVisibility(int position, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public override Location GetLocation(Text.TextSpan span) { throw null; }

        public override FileLinePositionSpan GetMappedLineSpan(Text.TextSpan span, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public abstract new CSharpSyntaxNode GetRoot(System.Threading.CancellationToken cancellationToken = default);
        public new virtual System.Threading.Tasks.Task<CSharpSyntaxNode> GetRootAsync(System.Threading.CancellationToken cancellationToken = default) { throw null; }

        protected override System.Threading.Tasks.Task<SyntaxNode> GetRootAsyncCore(System.Threading.CancellationToken cancellationToken) { throw null; }

        protected override SyntaxNode GetRootCore(System.Threading.CancellationToken cancellationToken) { throw null; }

        public override bool HasHiddenRegions() { throw null; }

        public override bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false) { throw null; }

        [System.Obsolete("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseText(Text.SourceText text, CSharpParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }

        [System.Obsolete("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseText(Text.SourceText text, CSharpParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }

        public static SyntaxTree ParseText(Text.SourceText text, CSharpParseOptions? options = null, string path = "", System.Threading.CancellationToken cancellationToken = default) { throw null; }

        [System.Obsolete("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseText(string text, CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }

        [System.Obsolete("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseText(string text, CSharpParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }

        public static SyntaxTree ParseText(string text, CSharpParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public abstract bool TryGetRoot(out CSharpSyntaxNode? root);
        protected override bool TryGetRootCore(out SyntaxNode? root) { throw null; }

        public override SyntaxTree WithChangedText(Text.SourceText newText) { throw null; }
    }

    public abstract partial class CSharpSyntaxVisitor
    {
        public virtual void DefaultVisit(SyntaxNode node) { }

        public virtual void Visit(SyntaxNode? node) { }

        public virtual void VisitAccessorDeclaration(Syntax.AccessorDeclarationSyntax node) { }

        public virtual void VisitAccessorList(Syntax.AccessorListSyntax node) { }

        public virtual void VisitAliasQualifiedName(Syntax.AliasQualifiedNameSyntax node) { }

        public virtual void VisitAnonymousMethodExpression(Syntax.AnonymousMethodExpressionSyntax node) { }

        public virtual void VisitAnonymousObjectCreationExpression(Syntax.AnonymousObjectCreationExpressionSyntax node) { }

        public virtual void VisitAnonymousObjectMemberDeclarator(Syntax.AnonymousObjectMemberDeclaratorSyntax node) { }

        public virtual void VisitArgument(Syntax.ArgumentSyntax node) { }

        public virtual void VisitArgumentList(Syntax.ArgumentListSyntax node) { }

        public virtual void VisitArrayCreationExpression(Syntax.ArrayCreationExpressionSyntax node) { }

        public virtual void VisitArrayRankSpecifier(Syntax.ArrayRankSpecifierSyntax node) { }

        public virtual void VisitArrayType(Syntax.ArrayTypeSyntax node) { }

        public virtual void VisitArrowExpressionClause(Syntax.ArrowExpressionClauseSyntax node) { }

        public virtual void VisitAssignmentExpression(Syntax.AssignmentExpressionSyntax node) { }

        public virtual void VisitAttribute(Syntax.AttributeSyntax node) { }

        public virtual void VisitAttributeArgument(Syntax.AttributeArgumentSyntax node) { }

        public virtual void VisitAttributeArgumentList(Syntax.AttributeArgumentListSyntax node) { }

        public virtual void VisitAttributeList(Syntax.AttributeListSyntax node) { }

        public virtual void VisitAttributeTargetSpecifier(Syntax.AttributeTargetSpecifierSyntax node) { }

        public virtual void VisitAwaitExpression(Syntax.AwaitExpressionSyntax node) { }

        public virtual void VisitBadDirectiveTrivia(Syntax.BadDirectiveTriviaSyntax node) { }

        public virtual void VisitBaseExpression(Syntax.BaseExpressionSyntax node) { }

        public virtual void VisitBaseList(Syntax.BaseListSyntax node) { }

        public virtual void VisitBinaryExpression(Syntax.BinaryExpressionSyntax node) { }

        public virtual void VisitBinaryPattern(Syntax.BinaryPatternSyntax node) { }

        public virtual void VisitBlock(Syntax.BlockSyntax node) { }

        public virtual void VisitBracketedArgumentList(Syntax.BracketedArgumentListSyntax node) { }

        public virtual void VisitBracketedParameterList(Syntax.BracketedParameterListSyntax node) { }

        public virtual void VisitBreakStatement(Syntax.BreakStatementSyntax node) { }

        public virtual void VisitCasePatternSwitchLabel(Syntax.CasePatternSwitchLabelSyntax node) { }

        public virtual void VisitCaseSwitchLabel(Syntax.CaseSwitchLabelSyntax node) { }

        public virtual void VisitCastExpression(Syntax.CastExpressionSyntax node) { }

        public virtual void VisitCatchClause(Syntax.CatchClauseSyntax node) { }

        public virtual void VisitCatchDeclaration(Syntax.CatchDeclarationSyntax node) { }

        public virtual void VisitCatchFilterClause(Syntax.CatchFilterClauseSyntax node) { }

        public virtual void VisitCheckedExpression(Syntax.CheckedExpressionSyntax node) { }

        public virtual void VisitCheckedStatement(Syntax.CheckedStatementSyntax node) { }

        public virtual void VisitClassDeclaration(Syntax.ClassDeclarationSyntax node) { }

        public virtual void VisitClassOrStructConstraint(Syntax.ClassOrStructConstraintSyntax node) { }

        public virtual void VisitCompilationUnit(Syntax.CompilationUnitSyntax node) { }

        public virtual void VisitConditionalAccessExpression(Syntax.ConditionalAccessExpressionSyntax node) { }

        public virtual void VisitConditionalExpression(Syntax.ConditionalExpressionSyntax node) { }

        public virtual void VisitConstantPattern(Syntax.ConstantPatternSyntax node) { }

        public virtual void VisitConstructorConstraint(Syntax.ConstructorConstraintSyntax node) { }

        public virtual void VisitConstructorDeclaration(Syntax.ConstructorDeclarationSyntax node) { }

        public virtual void VisitConstructorInitializer(Syntax.ConstructorInitializerSyntax node) { }

        public virtual void VisitContinueStatement(Syntax.ContinueStatementSyntax node) { }

        public virtual void VisitConversionOperatorDeclaration(Syntax.ConversionOperatorDeclarationSyntax node) { }

        public virtual void VisitConversionOperatorMemberCref(Syntax.ConversionOperatorMemberCrefSyntax node) { }

        public virtual void VisitCrefBracketedParameterList(Syntax.CrefBracketedParameterListSyntax node) { }

        public virtual void VisitCrefParameter(Syntax.CrefParameterSyntax node) { }

        public virtual void VisitCrefParameterList(Syntax.CrefParameterListSyntax node) { }

        public virtual void VisitDeclarationExpression(Syntax.DeclarationExpressionSyntax node) { }

        public virtual void VisitDeclarationPattern(Syntax.DeclarationPatternSyntax node) { }

        public virtual void VisitDefaultConstraint(Syntax.DefaultConstraintSyntax node) { }

        public virtual void VisitDefaultExpression(Syntax.DefaultExpressionSyntax node) { }

        public virtual void VisitDefaultSwitchLabel(Syntax.DefaultSwitchLabelSyntax node) { }

        public virtual void VisitDefineDirectiveTrivia(Syntax.DefineDirectiveTriviaSyntax node) { }

        public virtual void VisitDelegateDeclaration(Syntax.DelegateDeclarationSyntax node) { }

        public virtual void VisitDestructorDeclaration(Syntax.DestructorDeclarationSyntax node) { }

        public virtual void VisitDiscardDesignation(Syntax.DiscardDesignationSyntax node) { }

        public virtual void VisitDiscardPattern(Syntax.DiscardPatternSyntax node) { }

        public virtual void VisitDocumentationCommentTrivia(Syntax.DocumentationCommentTriviaSyntax node) { }

        public virtual void VisitDoStatement(Syntax.DoStatementSyntax node) { }

        public virtual void VisitElementAccessExpression(Syntax.ElementAccessExpressionSyntax node) { }

        public virtual void VisitElementBindingExpression(Syntax.ElementBindingExpressionSyntax node) { }

        public virtual void VisitElifDirectiveTrivia(Syntax.ElifDirectiveTriviaSyntax node) { }

        public virtual void VisitElseClause(Syntax.ElseClauseSyntax node) { }

        public virtual void VisitElseDirectiveTrivia(Syntax.ElseDirectiveTriviaSyntax node) { }

        public virtual void VisitEmptyStatement(Syntax.EmptyStatementSyntax node) { }

        public virtual void VisitEndIfDirectiveTrivia(Syntax.EndIfDirectiveTriviaSyntax node) { }

        public virtual void VisitEndRegionDirectiveTrivia(Syntax.EndRegionDirectiveTriviaSyntax node) { }

        public virtual void VisitEnumDeclaration(Syntax.EnumDeclarationSyntax node) { }

        public virtual void VisitEnumMemberDeclaration(Syntax.EnumMemberDeclarationSyntax node) { }

        public virtual void VisitEqualsValueClause(Syntax.EqualsValueClauseSyntax node) { }

        public virtual void VisitErrorDirectiveTrivia(Syntax.ErrorDirectiveTriviaSyntax node) { }

        public virtual void VisitEventDeclaration(Syntax.EventDeclarationSyntax node) { }

        public virtual void VisitEventFieldDeclaration(Syntax.EventFieldDeclarationSyntax node) { }

        public virtual void VisitExplicitInterfaceSpecifier(Syntax.ExplicitInterfaceSpecifierSyntax node) { }

        public virtual void VisitExpressionColon(Syntax.ExpressionColonSyntax node) { }

        public virtual void VisitExpressionStatement(Syntax.ExpressionStatementSyntax node) { }

        public virtual void VisitExternAliasDirective(Syntax.ExternAliasDirectiveSyntax node) { }

        public virtual void VisitFieldDeclaration(Syntax.FieldDeclarationSyntax node) { }

        public virtual void VisitFileScopedNamespaceDeclaration(Syntax.FileScopedNamespaceDeclarationSyntax node) { }

        public virtual void VisitFinallyClause(Syntax.FinallyClauseSyntax node) { }

        public virtual void VisitFixedStatement(Syntax.FixedStatementSyntax node) { }

        public virtual void VisitForEachStatement(Syntax.ForEachStatementSyntax node) { }

        public virtual void VisitForEachVariableStatement(Syntax.ForEachVariableStatementSyntax node) { }

        public virtual void VisitForStatement(Syntax.ForStatementSyntax node) { }

        public virtual void VisitFromClause(Syntax.FromClauseSyntax node) { }

        public virtual void VisitFunctionPointerCallingConvention(Syntax.FunctionPointerCallingConventionSyntax node) { }

        public virtual void VisitFunctionPointerParameter(Syntax.FunctionPointerParameterSyntax node) { }

        public virtual void VisitFunctionPointerParameterList(Syntax.FunctionPointerParameterListSyntax node) { }

        public virtual void VisitFunctionPointerType(Syntax.FunctionPointerTypeSyntax node) { }

        public virtual void VisitFunctionPointerUnmanagedCallingConvention(Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { }

        public virtual void VisitFunctionPointerUnmanagedCallingConventionList(Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { }

        public virtual void VisitGenericName(Syntax.GenericNameSyntax node) { }

        public virtual void VisitGlobalStatement(Syntax.GlobalStatementSyntax node) { }

        public virtual void VisitGotoStatement(Syntax.GotoStatementSyntax node) { }

        public virtual void VisitGroupClause(Syntax.GroupClauseSyntax node) { }

        public virtual void VisitIdentifierName(Syntax.IdentifierNameSyntax node) { }

        public virtual void VisitIfDirectiveTrivia(Syntax.IfDirectiveTriviaSyntax node) { }

        public virtual void VisitIfStatement(Syntax.IfStatementSyntax node) { }

        public virtual void VisitImplicitArrayCreationExpression(Syntax.ImplicitArrayCreationExpressionSyntax node) { }

        public virtual void VisitImplicitElementAccess(Syntax.ImplicitElementAccessSyntax node) { }

        public virtual void VisitImplicitObjectCreationExpression(Syntax.ImplicitObjectCreationExpressionSyntax node) { }

        public virtual void VisitImplicitStackAllocArrayCreationExpression(Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { }

        public virtual void VisitIncompleteMember(Syntax.IncompleteMemberSyntax node) { }

        public virtual void VisitIndexerDeclaration(Syntax.IndexerDeclarationSyntax node) { }

        public virtual void VisitIndexerMemberCref(Syntax.IndexerMemberCrefSyntax node) { }

        public virtual void VisitInitializerExpression(Syntax.InitializerExpressionSyntax node) { }

        public virtual void VisitInterfaceDeclaration(Syntax.InterfaceDeclarationSyntax node) { }

        public virtual void VisitInterpolatedStringExpression(Syntax.InterpolatedStringExpressionSyntax node) { }

        public virtual void VisitInterpolatedStringText(Syntax.InterpolatedStringTextSyntax node) { }

        public virtual void VisitInterpolation(Syntax.InterpolationSyntax node) { }

        public virtual void VisitInterpolationAlignmentClause(Syntax.InterpolationAlignmentClauseSyntax node) { }

        public virtual void VisitInterpolationFormatClause(Syntax.InterpolationFormatClauseSyntax node) { }

        public virtual void VisitInvocationExpression(Syntax.InvocationExpressionSyntax node) { }

        public virtual void VisitIsPatternExpression(Syntax.IsPatternExpressionSyntax node) { }

        public virtual void VisitJoinClause(Syntax.JoinClauseSyntax node) { }

        public virtual void VisitJoinIntoClause(Syntax.JoinIntoClauseSyntax node) { }

        public virtual void VisitLabeledStatement(Syntax.LabeledStatementSyntax node) { }

        public virtual void VisitLetClause(Syntax.LetClauseSyntax node) { }

        public virtual void VisitLineDirectivePosition(Syntax.LineDirectivePositionSyntax node) { }

        public virtual void VisitLineDirectiveTrivia(Syntax.LineDirectiveTriviaSyntax node) { }

        public virtual void VisitLineSpanDirectiveTrivia(Syntax.LineSpanDirectiveTriviaSyntax node) { }

        public virtual void VisitListPattern(Syntax.ListPatternSyntax node) { }

        public virtual void VisitLiteralExpression(Syntax.LiteralExpressionSyntax node) { }

        public virtual void VisitLoadDirectiveTrivia(Syntax.LoadDirectiveTriviaSyntax node) { }

        public virtual void VisitLocalDeclarationStatement(Syntax.LocalDeclarationStatementSyntax node) { }

        public virtual void VisitLocalFunctionStatement(Syntax.LocalFunctionStatementSyntax node) { }

        public virtual void VisitLockStatement(Syntax.LockStatementSyntax node) { }

        public virtual void VisitMakeRefExpression(Syntax.MakeRefExpressionSyntax node) { }

        public virtual void VisitMemberAccessExpression(Syntax.MemberAccessExpressionSyntax node) { }

        public virtual void VisitMemberBindingExpression(Syntax.MemberBindingExpressionSyntax node) { }

        public virtual void VisitMethodDeclaration(Syntax.MethodDeclarationSyntax node) { }

        public virtual void VisitNameColon(Syntax.NameColonSyntax node) { }

        public virtual void VisitNameEquals(Syntax.NameEqualsSyntax node) { }

        public virtual void VisitNameMemberCref(Syntax.NameMemberCrefSyntax node) { }

        public virtual void VisitNamespaceDeclaration(Syntax.NamespaceDeclarationSyntax node) { }

        public virtual void VisitNullableDirectiveTrivia(Syntax.NullableDirectiveTriviaSyntax node) { }

        public virtual void VisitNullableType(Syntax.NullableTypeSyntax node) { }

        public virtual void VisitObjectCreationExpression(Syntax.ObjectCreationExpressionSyntax node) { }

        public virtual void VisitOmittedArraySizeExpression(Syntax.OmittedArraySizeExpressionSyntax node) { }

        public virtual void VisitOmittedTypeArgument(Syntax.OmittedTypeArgumentSyntax node) { }

        public virtual void VisitOperatorDeclaration(Syntax.OperatorDeclarationSyntax node) { }

        public virtual void VisitOperatorMemberCref(Syntax.OperatorMemberCrefSyntax node) { }

        public virtual void VisitOrderByClause(Syntax.OrderByClauseSyntax node) { }

        public virtual void VisitOrdering(Syntax.OrderingSyntax node) { }

        public virtual void VisitParameter(Syntax.ParameterSyntax node) { }

        public virtual void VisitParameterList(Syntax.ParameterListSyntax node) { }

        public virtual void VisitParenthesizedExpression(Syntax.ParenthesizedExpressionSyntax node) { }

        public virtual void VisitParenthesizedLambdaExpression(Syntax.ParenthesizedLambdaExpressionSyntax node) { }

        public virtual void VisitParenthesizedPattern(Syntax.ParenthesizedPatternSyntax node) { }

        public virtual void VisitParenthesizedVariableDesignation(Syntax.ParenthesizedVariableDesignationSyntax node) { }

        public virtual void VisitPointerType(Syntax.PointerTypeSyntax node) { }

        public virtual void VisitPositionalPatternClause(Syntax.PositionalPatternClauseSyntax node) { }

        public virtual void VisitPostfixUnaryExpression(Syntax.PostfixUnaryExpressionSyntax node) { }

        public virtual void VisitPragmaChecksumDirectiveTrivia(Syntax.PragmaChecksumDirectiveTriviaSyntax node) { }

        public virtual void VisitPragmaWarningDirectiveTrivia(Syntax.PragmaWarningDirectiveTriviaSyntax node) { }

        public virtual void VisitPredefinedType(Syntax.PredefinedTypeSyntax node) { }

        public virtual void VisitPrefixUnaryExpression(Syntax.PrefixUnaryExpressionSyntax node) { }

        public virtual void VisitPrimaryConstructorBaseType(Syntax.PrimaryConstructorBaseTypeSyntax node) { }

        public virtual void VisitPropertyDeclaration(Syntax.PropertyDeclarationSyntax node) { }

        public virtual void VisitPropertyPatternClause(Syntax.PropertyPatternClauseSyntax node) { }

        public virtual void VisitQualifiedCref(Syntax.QualifiedCrefSyntax node) { }

        public virtual void VisitQualifiedName(Syntax.QualifiedNameSyntax node) { }

        public virtual void VisitQueryBody(Syntax.QueryBodySyntax node) { }

        public virtual void VisitQueryContinuation(Syntax.QueryContinuationSyntax node) { }

        public virtual void VisitQueryExpression(Syntax.QueryExpressionSyntax node) { }

        public virtual void VisitRangeExpression(Syntax.RangeExpressionSyntax node) { }

        public virtual void VisitRecordDeclaration(Syntax.RecordDeclarationSyntax node) { }

        public virtual void VisitRecursivePattern(Syntax.RecursivePatternSyntax node) { }

        public virtual void VisitReferenceDirectiveTrivia(Syntax.ReferenceDirectiveTriviaSyntax node) { }

        public virtual void VisitRefExpression(Syntax.RefExpressionSyntax node) { }

        public virtual void VisitRefType(Syntax.RefTypeSyntax node) { }

        public virtual void VisitRefTypeExpression(Syntax.RefTypeExpressionSyntax node) { }

        public virtual void VisitRefValueExpression(Syntax.RefValueExpressionSyntax node) { }

        public virtual void VisitRegionDirectiveTrivia(Syntax.RegionDirectiveTriviaSyntax node) { }

        public virtual void VisitRelationalPattern(Syntax.RelationalPatternSyntax node) { }

        public virtual void VisitReturnStatement(Syntax.ReturnStatementSyntax node) { }

        public virtual void VisitScopedType(Syntax.ScopedTypeSyntax node) { }

        public virtual void VisitSelectClause(Syntax.SelectClauseSyntax node) { }

        public virtual void VisitShebangDirectiveTrivia(Syntax.ShebangDirectiveTriviaSyntax node) { }

        public virtual void VisitSimpleBaseType(Syntax.SimpleBaseTypeSyntax node) { }

        public virtual void VisitSimpleLambdaExpression(Syntax.SimpleLambdaExpressionSyntax node) { }

        public virtual void VisitSingleVariableDesignation(Syntax.SingleVariableDesignationSyntax node) { }

        public virtual void VisitSizeOfExpression(Syntax.SizeOfExpressionSyntax node) { }

        public virtual void VisitSkippedTokensTrivia(Syntax.SkippedTokensTriviaSyntax node) { }

        public virtual void VisitSlicePattern(Syntax.SlicePatternSyntax node) { }

        public virtual void VisitStackAllocArrayCreationExpression(Syntax.StackAllocArrayCreationExpressionSyntax node) { }

        public virtual void VisitStructDeclaration(Syntax.StructDeclarationSyntax node) { }

        public virtual void VisitSubpattern(Syntax.SubpatternSyntax node) { }

        public virtual void VisitSwitchExpression(Syntax.SwitchExpressionSyntax node) { }

        public virtual void VisitSwitchExpressionArm(Syntax.SwitchExpressionArmSyntax node) { }

        public virtual void VisitSwitchSection(Syntax.SwitchSectionSyntax node) { }

        public virtual void VisitSwitchStatement(Syntax.SwitchStatementSyntax node) { }

        public virtual void VisitThisExpression(Syntax.ThisExpressionSyntax node) { }

        public virtual void VisitThrowExpression(Syntax.ThrowExpressionSyntax node) { }

        public virtual void VisitThrowStatement(Syntax.ThrowStatementSyntax node) { }

        public virtual void VisitTryStatement(Syntax.TryStatementSyntax node) { }

        public virtual void VisitTupleElement(Syntax.TupleElementSyntax node) { }

        public virtual void VisitTupleExpression(Syntax.TupleExpressionSyntax node) { }

        public virtual void VisitTupleType(Syntax.TupleTypeSyntax node) { }

        public virtual void VisitTypeArgumentList(Syntax.TypeArgumentListSyntax node) { }

        public virtual void VisitTypeConstraint(Syntax.TypeConstraintSyntax node) { }

        public virtual void VisitTypeCref(Syntax.TypeCrefSyntax node) { }

        public virtual void VisitTypeOfExpression(Syntax.TypeOfExpressionSyntax node) { }

        public virtual void VisitTypeParameter(Syntax.TypeParameterSyntax node) { }

        public virtual void VisitTypeParameterConstraintClause(Syntax.TypeParameterConstraintClauseSyntax node) { }

        public virtual void VisitTypeParameterList(Syntax.TypeParameterListSyntax node) { }

        public virtual void VisitTypePattern(Syntax.TypePatternSyntax node) { }

        public virtual void VisitUnaryPattern(Syntax.UnaryPatternSyntax node) { }

        public virtual void VisitUndefDirectiveTrivia(Syntax.UndefDirectiveTriviaSyntax node) { }

        public virtual void VisitUnsafeStatement(Syntax.UnsafeStatementSyntax node) { }

        public virtual void VisitUsingDirective(Syntax.UsingDirectiveSyntax node) { }

        public virtual void VisitUsingStatement(Syntax.UsingStatementSyntax node) { }

        public virtual void VisitVariableDeclaration(Syntax.VariableDeclarationSyntax node) { }

        public virtual void VisitVariableDeclarator(Syntax.VariableDeclaratorSyntax node) { }

        public virtual void VisitVarPattern(Syntax.VarPatternSyntax node) { }

        public virtual void VisitWarningDirectiveTrivia(Syntax.WarningDirectiveTriviaSyntax node) { }

        public virtual void VisitWhenClause(Syntax.WhenClauseSyntax node) { }

        public virtual void VisitWhereClause(Syntax.WhereClauseSyntax node) { }

        public virtual void VisitWhileStatement(Syntax.WhileStatementSyntax node) { }

        public virtual void VisitWithExpression(Syntax.WithExpressionSyntax node) { }

        public virtual void VisitXmlCDataSection(Syntax.XmlCDataSectionSyntax node) { }

        public virtual void VisitXmlComment(Syntax.XmlCommentSyntax node) { }

        public virtual void VisitXmlCrefAttribute(Syntax.XmlCrefAttributeSyntax node) { }

        public virtual void VisitXmlElement(Syntax.XmlElementSyntax node) { }

        public virtual void VisitXmlElementEndTag(Syntax.XmlElementEndTagSyntax node) { }

        public virtual void VisitXmlElementStartTag(Syntax.XmlElementStartTagSyntax node) { }

        public virtual void VisitXmlEmptyElement(Syntax.XmlEmptyElementSyntax node) { }

        public virtual void VisitXmlName(Syntax.XmlNameSyntax node) { }

        public virtual void VisitXmlNameAttribute(Syntax.XmlNameAttributeSyntax node) { }

        public virtual void VisitXmlPrefix(Syntax.XmlPrefixSyntax node) { }

        public virtual void VisitXmlProcessingInstruction(Syntax.XmlProcessingInstructionSyntax node) { }

        public virtual void VisitXmlText(Syntax.XmlTextSyntax node) { }

        public virtual void VisitXmlTextAttribute(Syntax.XmlTextAttributeSyntax node) { }

        public virtual void VisitYieldStatement(Syntax.YieldStatementSyntax node) { }
    }

    public abstract partial class CSharpSyntaxVisitor<TResult>
    {
        public virtual TResult? DefaultVisit(SyntaxNode node) { throw null; }

        public virtual TResult? Visit(SyntaxNode? node) { throw null; }

        public virtual TResult? VisitAccessorDeclaration(Syntax.AccessorDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitAccessorList(Syntax.AccessorListSyntax node) { throw null; }

        public virtual TResult? VisitAliasQualifiedName(Syntax.AliasQualifiedNameSyntax node) { throw null; }

        public virtual TResult? VisitAnonymousMethodExpression(Syntax.AnonymousMethodExpressionSyntax node) { throw null; }

        public virtual TResult? VisitAnonymousObjectCreationExpression(Syntax.AnonymousObjectCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitAnonymousObjectMemberDeclarator(Syntax.AnonymousObjectMemberDeclaratorSyntax node) { throw null; }

        public virtual TResult? VisitArgument(Syntax.ArgumentSyntax node) { throw null; }

        public virtual TResult? VisitArgumentList(Syntax.ArgumentListSyntax node) { throw null; }

        public virtual TResult? VisitArrayCreationExpression(Syntax.ArrayCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitArrayRankSpecifier(Syntax.ArrayRankSpecifierSyntax node) { throw null; }

        public virtual TResult? VisitArrayType(Syntax.ArrayTypeSyntax node) { throw null; }

        public virtual TResult? VisitArrowExpressionClause(Syntax.ArrowExpressionClauseSyntax node) { throw null; }

        public virtual TResult? VisitAssignmentExpression(Syntax.AssignmentExpressionSyntax node) { throw null; }

        public virtual TResult? VisitAttribute(Syntax.AttributeSyntax node) { throw null; }

        public virtual TResult? VisitAttributeArgument(Syntax.AttributeArgumentSyntax node) { throw null; }

        public virtual TResult? VisitAttributeArgumentList(Syntax.AttributeArgumentListSyntax node) { throw null; }

        public virtual TResult? VisitAttributeList(Syntax.AttributeListSyntax node) { throw null; }

        public virtual TResult? VisitAttributeTargetSpecifier(Syntax.AttributeTargetSpecifierSyntax node) { throw null; }

        public virtual TResult? VisitAwaitExpression(Syntax.AwaitExpressionSyntax node) { throw null; }

        public virtual TResult? VisitBadDirectiveTrivia(Syntax.BadDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitBaseExpression(Syntax.BaseExpressionSyntax node) { throw null; }

        public virtual TResult? VisitBaseList(Syntax.BaseListSyntax node) { throw null; }

        public virtual TResult? VisitBinaryExpression(Syntax.BinaryExpressionSyntax node) { throw null; }

        public virtual TResult? VisitBinaryPattern(Syntax.BinaryPatternSyntax node) { throw null; }

        public virtual TResult? VisitBlock(Syntax.BlockSyntax node) { throw null; }

        public virtual TResult? VisitBracketedArgumentList(Syntax.BracketedArgumentListSyntax node) { throw null; }

        public virtual TResult? VisitBracketedParameterList(Syntax.BracketedParameterListSyntax node) { throw null; }

        public virtual TResult? VisitBreakStatement(Syntax.BreakStatementSyntax node) { throw null; }

        public virtual TResult? VisitCasePatternSwitchLabel(Syntax.CasePatternSwitchLabelSyntax node) { throw null; }

        public virtual TResult? VisitCaseSwitchLabel(Syntax.CaseSwitchLabelSyntax node) { throw null; }

        public virtual TResult? VisitCastExpression(Syntax.CastExpressionSyntax node) { throw null; }

        public virtual TResult? VisitCatchClause(Syntax.CatchClauseSyntax node) { throw null; }

        public virtual TResult? VisitCatchDeclaration(Syntax.CatchDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitCatchFilterClause(Syntax.CatchFilterClauseSyntax node) { throw null; }

        public virtual TResult? VisitCheckedExpression(Syntax.CheckedExpressionSyntax node) { throw null; }

        public virtual TResult? VisitCheckedStatement(Syntax.CheckedStatementSyntax node) { throw null; }

        public virtual TResult? VisitClassDeclaration(Syntax.ClassDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitClassOrStructConstraint(Syntax.ClassOrStructConstraintSyntax node) { throw null; }

        public virtual TResult? VisitCompilationUnit(Syntax.CompilationUnitSyntax node) { throw null; }

        public virtual TResult? VisitConditionalAccessExpression(Syntax.ConditionalAccessExpressionSyntax node) { throw null; }

        public virtual TResult? VisitConditionalExpression(Syntax.ConditionalExpressionSyntax node) { throw null; }

        public virtual TResult? VisitConstantPattern(Syntax.ConstantPatternSyntax node) { throw null; }

        public virtual TResult? VisitConstructorConstraint(Syntax.ConstructorConstraintSyntax node) { throw null; }

        public virtual TResult? VisitConstructorDeclaration(Syntax.ConstructorDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitConstructorInitializer(Syntax.ConstructorInitializerSyntax node) { throw null; }

        public virtual TResult? VisitContinueStatement(Syntax.ContinueStatementSyntax node) { throw null; }

        public virtual TResult? VisitConversionOperatorDeclaration(Syntax.ConversionOperatorDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitConversionOperatorMemberCref(Syntax.ConversionOperatorMemberCrefSyntax node) { throw null; }

        public virtual TResult? VisitCrefBracketedParameterList(Syntax.CrefBracketedParameterListSyntax node) { throw null; }

        public virtual TResult? VisitCrefParameter(Syntax.CrefParameterSyntax node) { throw null; }

        public virtual TResult? VisitCrefParameterList(Syntax.CrefParameterListSyntax node) { throw null; }

        public virtual TResult? VisitDeclarationExpression(Syntax.DeclarationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitDeclarationPattern(Syntax.DeclarationPatternSyntax node) { throw null; }

        public virtual TResult? VisitDefaultConstraint(Syntax.DefaultConstraintSyntax node) { throw null; }

        public virtual TResult? VisitDefaultExpression(Syntax.DefaultExpressionSyntax node) { throw null; }

        public virtual TResult? VisitDefaultSwitchLabel(Syntax.DefaultSwitchLabelSyntax node) { throw null; }

        public virtual TResult? VisitDefineDirectiveTrivia(Syntax.DefineDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitDelegateDeclaration(Syntax.DelegateDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitDestructorDeclaration(Syntax.DestructorDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitDiscardDesignation(Syntax.DiscardDesignationSyntax node) { throw null; }

        public virtual TResult? VisitDiscardPattern(Syntax.DiscardPatternSyntax node) { throw null; }

        public virtual TResult? VisitDocumentationCommentTrivia(Syntax.DocumentationCommentTriviaSyntax node) { throw null; }

        public virtual TResult? VisitDoStatement(Syntax.DoStatementSyntax node) { throw null; }

        public virtual TResult? VisitElementAccessExpression(Syntax.ElementAccessExpressionSyntax node) { throw null; }

        public virtual TResult? VisitElementBindingExpression(Syntax.ElementBindingExpressionSyntax node) { throw null; }

        public virtual TResult? VisitElifDirectiveTrivia(Syntax.ElifDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitElseClause(Syntax.ElseClauseSyntax node) { throw null; }

        public virtual TResult? VisitElseDirectiveTrivia(Syntax.ElseDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitEmptyStatement(Syntax.EmptyStatementSyntax node) { throw null; }

        public virtual TResult? VisitEndIfDirectiveTrivia(Syntax.EndIfDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitEndRegionDirectiveTrivia(Syntax.EndRegionDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitEnumDeclaration(Syntax.EnumDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitEnumMemberDeclaration(Syntax.EnumMemberDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitEqualsValueClause(Syntax.EqualsValueClauseSyntax node) { throw null; }

        public virtual TResult? VisitErrorDirectiveTrivia(Syntax.ErrorDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitEventDeclaration(Syntax.EventDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitEventFieldDeclaration(Syntax.EventFieldDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitExplicitInterfaceSpecifier(Syntax.ExplicitInterfaceSpecifierSyntax node) { throw null; }

        public virtual TResult? VisitExpressionColon(Syntax.ExpressionColonSyntax node) { throw null; }

        public virtual TResult? VisitExpressionStatement(Syntax.ExpressionStatementSyntax node) { throw null; }

        public virtual TResult? VisitExternAliasDirective(Syntax.ExternAliasDirectiveSyntax node) { throw null; }

        public virtual TResult? VisitFieldDeclaration(Syntax.FieldDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitFileScopedNamespaceDeclaration(Syntax.FileScopedNamespaceDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitFinallyClause(Syntax.FinallyClauseSyntax node) { throw null; }

        public virtual TResult? VisitFixedStatement(Syntax.FixedStatementSyntax node) { throw null; }

        public virtual TResult? VisitForEachStatement(Syntax.ForEachStatementSyntax node) { throw null; }

        public virtual TResult? VisitForEachVariableStatement(Syntax.ForEachVariableStatementSyntax node) { throw null; }

        public virtual TResult? VisitForStatement(Syntax.ForStatementSyntax node) { throw null; }

        public virtual TResult? VisitFromClause(Syntax.FromClauseSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerCallingConvention(Syntax.FunctionPointerCallingConventionSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerParameter(Syntax.FunctionPointerParameterSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerParameterList(Syntax.FunctionPointerParameterListSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerType(Syntax.FunctionPointerTypeSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerUnmanagedCallingConvention(Syntax.FunctionPointerUnmanagedCallingConventionSyntax node) { throw null; }

        public virtual TResult? VisitFunctionPointerUnmanagedCallingConventionList(Syntax.FunctionPointerUnmanagedCallingConventionListSyntax node) { throw null; }

        public virtual TResult? VisitGenericName(Syntax.GenericNameSyntax node) { throw null; }

        public virtual TResult? VisitGlobalStatement(Syntax.GlobalStatementSyntax node) { throw null; }

        public virtual TResult? VisitGotoStatement(Syntax.GotoStatementSyntax node) { throw null; }

        public virtual TResult? VisitGroupClause(Syntax.GroupClauseSyntax node) { throw null; }

        public virtual TResult? VisitIdentifierName(Syntax.IdentifierNameSyntax node) { throw null; }

        public virtual TResult? VisitIfDirectiveTrivia(Syntax.IfDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitIfStatement(Syntax.IfStatementSyntax node) { throw null; }

        public virtual TResult? VisitImplicitArrayCreationExpression(Syntax.ImplicitArrayCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitImplicitElementAccess(Syntax.ImplicitElementAccessSyntax node) { throw null; }

        public virtual TResult? VisitImplicitObjectCreationExpression(Syntax.ImplicitObjectCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitImplicitStackAllocArrayCreationExpression(Syntax.ImplicitStackAllocArrayCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitIncompleteMember(Syntax.IncompleteMemberSyntax node) { throw null; }

        public virtual TResult? VisitIndexerDeclaration(Syntax.IndexerDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitIndexerMemberCref(Syntax.IndexerMemberCrefSyntax node) { throw null; }

        public virtual TResult? VisitInitializerExpression(Syntax.InitializerExpressionSyntax node) { throw null; }

        public virtual TResult? VisitInterfaceDeclaration(Syntax.InterfaceDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitInterpolatedStringExpression(Syntax.InterpolatedStringExpressionSyntax node) { throw null; }

        public virtual TResult? VisitInterpolatedStringText(Syntax.InterpolatedStringTextSyntax node) { throw null; }

        public virtual TResult? VisitInterpolation(Syntax.InterpolationSyntax node) { throw null; }

        public virtual TResult? VisitInterpolationAlignmentClause(Syntax.InterpolationAlignmentClauseSyntax node) { throw null; }

        public virtual TResult? VisitInterpolationFormatClause(Syntax.InterpolationFormatClauseSyntax node) { throw null; }

        public virtual TResult? VisitInvocationExpression(Syntax.InvocationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitIsPatternExpression(Syntax.IsPatternExpressionSyntax node) { throw null; }

        public virtual TResult? VisitJoinClause(Syntax.JoinClauseSyntax node) { throw null; }

        public virtual TResult? VisitJoinIntoClause(Syntax.JoinIntoClauseSyntax node) { throw null; }

        public virtual TResult? VisitLabeledStatement(Syntax.LabeledStatementSyntax node) { throw null; }

        public virtual TResult? VisitLetClause(Syntax.LetClauseSyntax node) { throw null; }

        public virtual TResult? VisitLineDirectivePosition(Syntax.LineDirectivePositionSyntax node) { throw null; }

        public virtual TResult? VisitLineDirectiveTrivia(Syntax.LineDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitLineSpanDirectiveTrivia(Syntax.LineSpanDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitListPattern(Syntax.ListPatternSyntax node) { throw null; }

        public virtual TResult? VisitLiteralExpression(Syntax.LiteralExpressionSyntax node) { throw null; }

        public virtual TResult? VisitLoadDirectiveTrivia(Syntax.LoadDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitLocalDeclarationStatement(Syntax.LocalDeclarationStatementSyntax node) { throw null; }

        public virtual TResult? VisitLocalFunctionStatement(Syntax.LocalFunctionStatementSyntax node) { throw null; }

        public virtual TResult? VisitLockStatement(Syntax.LockStatementSyntax node) { throw null; }

        public virtual TResult? VisitMakeRefExpression(Syntax.MakeRefExpressionSyntax node) { throw null; }

        public virtual TResult? VisitMemberAccessExpression(Syntax.MemberAccessExpressionSyntax node) { throw null; }

        public virtual TResult? VisitMemberBindingExpression(Syntax.MemberBindingExpressionSyntax node) { throw null; }

        public virtual TResult? VisitMethodDeclaration(Syntax.MethodDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitNameColon(Syntax.NameColonSyntax node) { throw null; }

        public virtual TResult? VisitNameEquals(Syntax.NameEqualsSyntax node) { throw null; }

        public virtual TResult? VisitNameMemberCref(Syntax.NameMemberCrefSyntax node) { throw null; }

        public virtual TResult? VisitNamespaceDeclaration(Syntax.NamespaceDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitNullableDirectiveTrivia(Syntax.NullableDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitNullableType(Syntax.NullableTypeSyntax node) { throw null; }

        public virtual TResult? VisitObjectCreationExpression(Syntax.ObjectCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitOmittedArraySizeExpression(Syntax.OmittedArraySizeExpressionSyntax node) { throw null; }

        public virtual TResult? VisitOmittedTypeArgument(Syntax.OmittedTypeArgumentSyntax node) { throw null; }

        public virtual TResult? VisitOperatorDeclaration(Syntax.OperatorDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitOperatorMemberCref(Syntax.OperatorMemberCrefSyntax node) { throw null; }

        public virtual TResult? VisitOrderByClause(Syntax.OrderByClauseSyntax node) { throw null; }

        public virtual TResult? VisitOrdering(Syntax.OrderingSyntax node) { throw null; }

        public virtual TResult? VisitParameter(Syntax.ParameterSyntax node) { throw null; }

        public virtual TResult? VisitParameterList(Syntax.ParameterListSyntax node) { throw null; }

        public virtual TResult? VisitParenthesizedExpression(Syntax.ParenthesizedExpressionSyntax node) { throw null; }

        public virtual TResult? VisitParenthesizedLambdaExpression(Syntax.ParenthesizedLambdaExpressionSyntax node) { throw null; }

        public virtual TResult? VisitParenthesizedPattern(Syntax.ParenthesizedPatternSyntax node) { throw null; }

        public virtual TResult? VisitParenthesizedVariableDesignation(Syntax.ParenthesizedVariableDesignationSyntax node) { throw null; }

        public virtual TResult? VisitPointerType(Syntax.PointerTypeSyntax node) { throw null; }

        public virtual TResult? VisitPositionalPatternClause(Syntax.PositionalPatternClauseSyntax node) { throw null; }

        public virtual TResult? VisitPostfixUnaryExpression(Syntax.PostfixUnaryExpressionSyntax node) { throw null; }

        public virtual TResult? VisitPragmaChecksumDirectiveTrivia(Syntax.PragmaChecksumDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitPragmaWarningDirectiveTrivia(Syntax.PragmaWarningDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitPredefinedType(Syntax.PredefinedTypeSyntax node) { throw null; }

        public virtual TResult? VisitPrefixUnaryExpression(Syntax.PrefixUnaryExpressionSyntax node) { throw null; }

        public virtual TResult? VisitPrimaryConstructorBaseType(Syntax.PrimaryConstructorBaseTypeSyntax node) { throw null; }

        public virtual TResult? VisitPropertyDeclaration(Syntax.PropertyDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitPropertyPatternClause(Syntax.PropertyPatternClauseSyntax node) { throw null; }

        public virtual TResult? VisitQualifiedCref(Syntax.QualifiedCrefSyntax node) { throw null; }

        public virtual TResult? VisitQualifiedName(Syntax.QualifiedNameSyntax node) { throw null; }

        public virtual TResult? VisitQueryBody(Syntax.QueryBodySyntax node) { throw null; }

        public virtual TResult? VisitQueryContinuation(Syntax.QueryContinuationSyntax node) { throw null; }

        public virtual TResult? VisitQueryExpression(Syntax.QueryExpressionSyntax node) { throw null; }

        public virtual TResult? VisitRangeExpression(Syntax.RangeExpressionSyntax node) { throw null; }

        public virtual TResult? VisitRecordDeclaration(Syntax.RecordDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitRecursivePattern(Syntax.RecursivePatternSyntax node) { throw null; }

        public virtual TResult? VisitReferenceDirectiveTrivia(Syntax.ReferenceDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitRefExpression(Syntax.RefExpressionSyntax node) { throw null; }

        public virtual TResult? VisitRefType(Syntax.RefTypeSyntax node) { throw null; }

        public virtual TResult? VisitRefTypeExpression(Syntax.RefTypeExpressionSyntax node) { throw null; }

        public virtual TResult? VisitRefValueExpression(Syntax.RefValueExpressionSyntax node) { throw null; }

        public virtual TResult? VisitRegionDirectiveTrivia(Syntax.RegionDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitRelationalPattern(Syntax.RelationalPatternSyntax node) { throw null; }

        public virtual TResult? VisitReturnStatement(Syntax.ReturnStatementSyntax node) { throw null; }

        public virtual TResult? VisitScopedType(Syntax.ScopedTypeSyntax node) { throw null; }

        public virtual TResult? VisitSelectClause(Syntax.SelectClauseSyntax node) { throw null; }

        public virtual TResult? VisitShebangDirectiveTrivia(Syntax.ShebangDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitSimpleBaseType(Syntax.SimpleBaseTypeSyntax node) { throw null; }

        public virtual TResult? VisitSimpleLambdaExpression(Syntax.SimpleLambdaExpressionSyntax node) { throw null; }

        public virtual TResult? VisitSingleVariableDesignation(Syntax.SingleVariableDesignationSyntax node) { throw null; }

        public virtual TResult? VisitSizeOfExpression(Syntax.SizeOfExpressionSyntax node) { throw null; }

        public virtual TResult? VisitSkippedTokensTrivia(Syntax.SkippedTokensTriviaSyntax node) { throw null; }

        public virtual TResult? VisitSlicePattern(Syntax.SlicePatternSyntax node) { throw null; }

        public virtual TResult? VisitStackAllocArrayCreationExpression(Syntax.StackAllocArrayCreationExpressionSyntax node) { throw null; }

        public virtual TResult? VisitStructDeclaration(Syntax.StructDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitSubpattern(Syntax.SubpatternSyntax node) { throw null; }

        public virtual TResult? VisitSwitchExpression(Syntax.SwitchExpressionSyntax node) { throw null; }

        public virtual TResult? VisitSwitchExpressionArm(Syntax.SwitchExpressionArmSyntax node) { throw null; }

        public virtual TResult? VisitSwitchSection(Syntax.SwitchSectionSyntax node) { throw null; }

        public virtual TResult? VisitSwitchStatement(Syntax.SwitchStatementSyntax node) { throw null; }

        public virtual TResult? VisitThisExpression(Syntax.ThisExpressionSyntax node) { throw null; }

        public virtual TResult? VisitThrowExpression(Syntax.ThrowExpressionSyntax node) { throw null; }

        public virtual TResult? VisitThrowStatement(Syntax.ThrowStatementSyntax node) { throw null; }

        public virtual TResult? VisitTryStatement(Syntax.TryStatementSyntax node) { throw null; }

        public virtual TResult? VisitTupleElement(Syntax.TupleElementSyntax node) { throw null; }

        public virtual TResult? VisitTupleExpression(Syntax.TupleExpressionSyntax node) { throw null; }

        public virtual TResult? VisitTupleType(Syntax.TupleTypeSyntax node) { throw null; }

        public virtual TResult? VisitTypeArgumentList(Syntax.TypeArgumentListSyntax node) { throw null; }

        public virtual TResult? VisitTypeConstraint(Syntax.TypeConstraintSyntax node) { throw null; }

        public virtual TResult? VisitTypeCref(Syntax.TypeCrefSyntax node) { throw null; }

        public virtual TResult? VisitTypeOfExpression(Syntax.TypeOfExpressionSyntax node) { throw null; }

        public virtual TResult? VisitTypeParameter(Syntax.TypeParameterSyntax node) { throw null; }

        public virtual TResult? VisitTypeParameterConstraintClause(Syntax.TypeParameterConstraintClauseSyntax node) { throw null; }

        public virtual TResult? VisitTypeParameterList(Syntax.TypeParameterListSyntax node) { throw null; }

        public virtual TResult? VisitTypePattern(Syntax.TypePatternSyntax node) { throw null; }

        public virtual TResult? VisitUnaryPattern(Syntax.UnaryPatternSyntax node) { throw null; }

        public virtual TResult? VisitUndefDirectiveTrivia(Syntax.UndefDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitUnsafeStatement(Syntax.UnsafeStatementSyntax node) { throw null; }

        public virtual TResult? VisitUsingDirective(Syntax.UsingDirectiveSyntax node) { throw null; }

        public virtual TResult? VisitUsingStatement(Syntax.UsingStatementSyntax node) { throw null; }

        public virtual TResult? VisitVariableDeclaration(Syntax.VariableDeclarationSyntax node) { throw null; }

        public virtual TResult? VisitVariableDeclarator(Syntax.VariableDeclaratorSyntax node) { throw null; }

        public virtual TResult? VisitVarPattern(Syntax.VarPatternSyntax node) { throw null; }

        public virtual TResult? VisitWarningDirectiveTrivia(Syntax.WarningDirectiveTriviaSyntax node) { throw null; }

        public virtual TResult? VisitWhenClause(Syntax.WhenClauseSyntax node) { throw null; }

        public virtual TResult? VisitWhereClause(Syntax.WhereClauseSyntax node) { throw null; }

        public virtual TResult? VisitWhileStatement(Syntax.WhileStatementSyntax node) { throw null; }

        public virtual TResult? VisitWithExpression(Syntax.WithExpressionSyntax node) { throw null; }

        public virtual TResult? VisitXmlCDataSection(Syntax.XmlCDataSectionSyntax node) { throw null; }

        public virtual TResult? VisitXmlComment(Syntax.XmlCommentSyntax node) { throw null; }

        public virtual TResult? VisitXmlCrefAttribute(Syntax.XmlCrefAttributeSyntax node) { throw null; }

        public virtual TResult? VisitXmlElement(Syntax.XmlElementSyntax node) { throw null; }

        public virtual TResult? VisitXmlElementEndTag(Syntax.XmlElementEndTagSyntax node) { throw null; }

        public virtual TResult? VisitXmlElementStartTag(Syntax.XmlElementStartTagSyntax node) { throw null; }

        public virtual TResult? VisitXmlEmptyElement(Syntax.XmlEmptyElementSyntax node) { throw null; }

        public virtual TResult? VisitXmlName(Syntax.XmlNameSyntax node) { throw null; }

        public virtual TResult? VisitXmlNameAttribute(Syntax.XmlNameAttributeSyntax node) { throw null; }

        public virtual TResult? VisitXmlPrefix(Syntax.XmlPrefixSyntax node) { throw null; }

        public virtual TResult? VisitXmlProcessingInstruction(Syntax.XmlProcessingInstructionSyntax node) { throw null; }

        public virtual TResult? VisitXmlText(Syntax.XmlTextSyntax node) { throw null; }

        public virtual TResult? VisitXmlTextAttribute(Syntax.XmlTextAttributeSyntax node) { throw null; }

        public virtual TResult? VisitYieldStatement(Syntax.YieldStatementSyntax node) { throw null; }
    }

    public abstract partial class CSharpSyntaxWalker : CSharpSyntaxVisitor
    {
        protected CSharpSyntaxWalker(SyntaxWalkerDepth depth = SyntaxWalkerDepth.Node) { }

        protected SyntaxWalkerDepth Depth { get { throw null; } }

        public override void DefaultVisit(SyntaxNode node) { }

        public override void Visit(SyntaxNode? node) { }

        public virtual void VisitLeadingTrivia(SyntaxToken token) { }

        public virtual void VisitToken(SyntaxToken token) { }

        public virtual void VisitTrailingTrivia(SyntaxToken token) { }

        public virtual void VisitTrivia(SyntaxTrivia trivia) { }
    }

    public readonly partial struct DeconstructionInfo
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Conversion? Conversion { get { throw null; } }

        public IMethodSymbol? Method { get { throw null; } }

        public System.Collections.Immutable.ImmutableArray<DeconstructionInfo> Nested { get { throw null; } }
    }

    public readonly partial struct ForEachStatementInfo : System.IEquatable<ForEachStatementInfo>
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public Conversion CurrentConversion { get { throw null; } }

        public IPropertySymbol? CurrentProperty { get { throw null; } }

        public IMethodSymbol? DisposeMethod { get { throw null; } }

        public Conversion ElementConversion { get { throw null; } }

        public ITypeSymbol? ElementType { get { throw null; } }

        public IMethodSymbol? GetEnumeratorMethod { get { throw null; } }

        public bool IsAsynchronous { get { throw null; } }

        public IMethodSymbol? MoveNextMethod { get { throw null; } }

        public readonly bool Equals(ForEachStatementInfo other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }
    }

    public enum LanguageVersion
    {
        Default = 0,
        CSharp1 = 1,
        CSharp2 = 2,
        CSharp3 = 3,
        CSharp4 = 4,
        CSharp5 = 5,
        CSharp6 = 6,
        CSharp7 = 7,
        CSharp7_1 = 701,
        CSharp7_2 = 702,
        CSharp7_3 = 703,
        CSharp8 = 800,
        CSharp9 = 900,
        CSharp10 = 1000,
        CSharp11 = 1100,
        LatestMajor = 2147483645,
        Preview = 2147483646,
        Latest = int.MaxValue
    }

    public static partial class LanguageVersionFacts
    {
        public static LanguageVersion MapSpecifiedToEffectiveVersion(this LanguageVersion version) { throw null; }

        public static string ToDisplayString(this LanguageVersion version) { throw null; }

        public static bool TryParse(string? version, out LanguageVersion result) { throw null; }
    }

    public readonly partial struct QueryClauseInfo : System.IEquatable<QueryClauseInfo>
    {
        public SymbolInfo CastInfo { get { throw null; } }

        public SymbolInfo OperationInfo { get { throw null; } }

        public readonly bool Equals(QueryClauseInfo other) { throw null; }

        public override readonly bool Equals(object? obj) { throw null; }

        public override readonly int GetHashCode() { throw null; }
    }

    public static partial class SymbolDisplay
    {
        public static string FormatLiteral(char c, bool quote) { throw null; }

        public static string FormatLiteral(string value, bool quote) { throw null; }

        public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SymbolDisplayFormat? format = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToDisplayParts(ITypeSymbol symbol, NullableAnnotation nullableAnnotation, SymbolDisplayFormat? format = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToDisplayParts(ITypeSymbol symbol, NullableFlowState nullableFlowState, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToDisplayString(ITypeSymbol symbol, NullableAnnotation nullableAnnotation, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToDisplayString(ITypeSymbol symbol, NullableFlowState nullableFlowState, SymbolDisplayFormat? format = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(ITypeSymbol symbol, NullableAnnotation nullableAnnotation, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }

        public static System.Collections.Immutable.ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(ITypeSymbol symbol, NullableFlowState nullableFlowState, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToMinimalDisplayString(ITypeSymbol symbol, NullableAnnotation nullableAnnotation, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }

        public static string ToMinimalDisplayString(ITypeSymbol symbol, NullableFlowState nullableFlowState, SemanticModel semanticModel, int position, SymbolDisplayFormat? format = null) { throw null; }
    }

    public static partial class SyntaxExtensions
    {
        public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation, bool elasticTrivia) { throw null; }

        public static SyntaxToken NormalizeWhitespace(this SyntaxToken token, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false) { throw null; }

        public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation, bool elasticTrivia) { throw null; }

        public static SyntaxTriviaList NormalizeWhitespace(this SyntaxTriviaList list, string indentation = "    ", string eol = "\r\n", bool elasticTrivia = false) { throw null; }

        public static SyntaxTriviaList ToSyntaxTriviaList(this System.Collections.Generic.IEnumerable<SyntaxTrivia> sequence) { throw null; }

        public static Syntax.IndexerDeclarationSyntax Update(this Syntax.IndexerDeclarationSyntax syntax, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, Syntax.BracketedParameterListSyntax parameterList, Syntax.AccessorListSyntax accessorList) { throw null; }

        public static Syntax.MethodDeclarationSyntax Update(this Syntax.MethodDeclarationSyntax syntax, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.TypeParameterListSyntax typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax block, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax Update(this Syntax.OperatorDeclarationSyntax syntax, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax block, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.SimpleNameSyntax WithIdentifier(this Syntax.SimpleNameSyntax simpleName, SyntaxToken identifier) { throw null; }
    }

    public static partial class SyntaxFactory
    {
        public static SyntaxTrivia CarriageReturn { get { throw null; } }

        public static SyntaxTrivia CarriageReturnLineFeed { get { throw null; } }

        public static SyntaxTrivia ElasticCarriageReturn { get { throw null; } }

        public static SyntaxTrivia ElasticCarriageReturnLineFeed { get { throw null; } }

        public static SyntaxTrivia ElasticLineFeed { get { throw null; } }

        public static SyntaxTrivia ElasticMarker { get { throw null; } }

        public static SyntaxTrivia ElasticSpace { get { throw null; } }

        public static SyntaxTrivia ElasticTab { get { throw null; } }

        public static SyntaxTrivia LineFeed { get { throw null; } }

        public static SyntaxTrivia Space { get { throw null; } }

        public static SyntaxTrivia Tab { get { throw null; } }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Syntax.BlockSyntax? body) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.BlockSyntax body) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, Syntax.ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, Syntax.BlockSyntax body, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind) { throw null; }

        public static Syntax.AccessorListSyntax AccessorList(SyntaxList<Syntax.AccessorDeclarationSyntax> accessors = default) { throw null; }

        public static Syntax.AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<Syntax.AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Syntax.IdentifierNameSyntax alias, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.AliasQualifiedNameSyntax AliasQualifiedName(Syntax.IdentifierNameSyntax alias, SyntaxToken colonColonToken, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.AliasQualifiedNameSyntax AliasQualifiedName(string alias, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression() { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body) { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(Syntax.ParameterListSyntax? parameterList, CSharpSyntaxNode body) { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, Syntax.ParameterListSyntax parameterList, CSharpSyntaxNode body) { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax block, Syntax.ExpressionSyntax expressionBody) { throw null; }

        public static Syntax.AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxTokenList modifiers, SyntaxToken delegateKeyword, Syntax.ParameterListSyntax? parameterList, Syntax.BlockSyntax block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers = default) { throw null; }

        public static Syntax.AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<Syntax.AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(Syntax.NameEqualsSyntax? nameEquals, Syntax.ExpressionSyntax expression) { throw null; }

        public static bool AreEquivalent(SyntaxNode? oldNode, SyntaxNode? newNode, bool topLevel) { throw null; }

        public static bool AreEquivalent(SyntaxNode? oldNode, SyntaxNode? newNode, System.Func<SyntaxKind, bool>? ignoreChildNode = null) { throw null; }

        public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken) { throw null; }

        public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList) { throw null; }

        public static bool AreEquivalent(SyntaxTree? oldTree, SyntaxTree? newTree, bool topLevel) { throw null; }

        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, bool topLevel)
            where TNode : SyntaxNode { throw null; }

        public static bool AreEquivalent<TNode>(SeparatedSyntaxList<TNode> oldList, SeparatedSyntaxList<TNode> newList, System.Func<SyntaxKind, bool>? ignoreChildNode = null)
            where TNode : SyntaxNode { throw null; }

        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, bool topLevel)
            where TNode : CSharpSyntaxNode { throw null; }

        public static bool AreEquivalent<TNode>(SyntaxList<TNode> oldList, SyntaxList<TNode> newList, System.Func<SyntaxKind, bool>? ignoreChildNode = null)
            where TNode : SyntaxNode { throw null; }

        public static Syntax.ArgumentSyntax Argument(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ArgumentSyntax Argument(Syntax.NameColonSyntax? nameColon, SyntaxToken refKindKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ArgumentListSyntax ArgumentList(SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments = default) { throw null; }

        public static Syntax.ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Syntax.ArrayTypeSyntax type, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(Syntax.ArrayTypeSyntax type) { throw null; }

        public static Syntax.ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, Syntax.ArrayTypeSyntax type, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<Syntax.ExpressionSyntax> sizes = default) { throw null; }

        public static Syntax.ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.ExpressionSyntax> sizes, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.ArrayTypeSyntax ArrayType(Syntax.TypeSyntax elementType, SyntaxList<Syntax.ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }

        public static Syntax.ArrayTypeSyntax ArrayType(Syntax.TypeSyntax elementType) { throw null; }

        public static Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, Syntax.ExpressionSyntax left, Syntax.ExpressionSyntax right) { throw null; }

        public static Syntax.AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Syntax.ExpressionSyntax right) { throw null; }

        public static Syntax.AttributeSyntax Attribute(Syntax.NameSyntax name, Syntax.AttributeArgumentListSyntax? argumentList) { throw null; }

        public static Syntax.AttributeSyntax Attribute(Syntax.NameSyntax name) { throw null; }

        public static Syntax.AttributeArgumentSyntax AttributeArgument(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.AttributeArgumentSyntax AttributeArgument(Syntax.NameEqualsSyntax? nameEquals, Syntax.NameColonSyntax? nameColon, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<Syntax.AttributeArgumentSyntax> arguments = default) { throw null; }

        public static Syntax.AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.AttributeListSyntax AttributeList(Syntax.AttributeTargetSpecifierSyntax? target, SeparatedSyntaxList<Syntax.AttributeSyntax> attributes) { throw null; }

        public static Syntax.AttributeListSyntax AttributeList(SeparatedSyntaxList<Syntax.AttributeSyntax> attributes = default) { throw null; }

        public static Syntax.AttributeListSyntax AttributeList(SyntaxToken openBracketToken, Syntax.AttributeTargetSpecifierSyntax? target, SeparatedSyntaxList<Syntax.AttributeSyntax> attributes, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken) { throw null; }

        public static Syntax.AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier) { throw null; }

        public static Syntax.AwaitExpressionSyntax AwaitExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive) { throw null; }

        public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing) { throw null; }

        public static Syntax.BaseExpressionSyntax BaseExpression() { throw null; }

        public static Syntax.BaseExpressionSyntax BaseExpression(SyntaxToken token) { throw null; }

        public static Syntax.BaseListSyntax BaseList(SeparatedSyntaxList<Syntax.BaseTypeSyntax> types = default) { throw null; }

        public static Syntax.BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<Syntax.BaseTypeSyntax> types) { throw null; }

        public static Syntax.BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, Syntax.ExpressionSyntax left, Syntax.ExpressionSyntax right) { throw null; }

        public static Syntax.BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, Syntax.ExpressionSyntax left, SyntaxToken operatorToken, Syntax.ExpressionSyntax right) { throw null; }

        public static Syntax.BinaryPatternSyntax BinaryPattern(SyntaxKind kind, Syntax.PatternSyntax left, Syntax.PatternSyntax right) { throw null; }

        public static Syntax.BinaryPatternSyntax BinaryPattern(SyntaxKind kind, Syntax.PatternSyntax left, SyntaxToken operatorToken, Syntax.PatternSyntax right) { throw null; }

        public static Syntax.BlockSyntax Block(params Syntax.StatementSyntax[] statements) { throw null; }

        public static Syntax.BlockSyntax Block(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxList<Syntax.StatementSyntax> statements) { throw null; }

        public static Syntax.BlockSyntax Block(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken openBraceToken, SyntaxList<Syntax.StatementSyntax> statements, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.BlockSyntax Block(SyntaxList<Syntax.StatementSyntax> statements = default) { throw null; }

        public static Syntax.BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<Syntax.StatementSyntax> statements, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.BlockSyntax Block(System.Collections.Generic.IEnumerable<Syntax.StatementSyntax> statements) { throw null; }

        public static Syntax.BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments = default) { throw null; }

        public static Syntax.BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<Syntax.ParameterSyntax> parameters = default) { throw null; }

        public static Syntax.BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.ParameterSyntax> parameters, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.BreakStatementSyntax BreakStatement() { throw null; }

        public static Syntax.BreakStatementSyntax BreakStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.BreakStatementSyntax BreakStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists) { throw null; }

        public static Syntax.BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Syntax.PatternSyntax pattern, Syntax.WhenClauseSyntax? whenClause, SyntaxToken colonToken) { throw null; }

        public static Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(Syntax.PatternSyntax pattern, SyntaxToken colonToken) { throw null; }

        public static Syntax.CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, Syntax.PatternSyntax pattern, Syntax.WhenClauseSyntax? whenClause, SyntaxToken colonToken) { throw null; }

        public static Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Syntax.ExpressionSyntax value, SyntaxToken colonToken) { throw null; }

        public static Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(Syntax.ExpressionSyntax value) { throw null; }

        public static Syntax.CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, Syntax.ExpressionSyntax value, SyntaxToken colonToken) { throw null; }

        public static Syntax.CastExpressionSyntax CastExpression(Syntax.TypeSyntax type, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.CastExpressionSyntax CastExpression(SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken closeParenToken, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.CatchClauseSyntax CatchClause() { throw null; }

        public static Syntax.CatchClauseSyntax CatchClause(Syntax.CatchDeclarationSyntax? declaration, Syntax.CatchFilterClauseSyntax? filter, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, Syntax.CatchDeclarationSyntax? declaration, Syntax.CatchFilterClauseSyntax? filter, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.CatchDeclarationSyntax CatchDeclaration(Syntax.TypeSyntax type, SyntaxToken identifier) { throw null; }

        public static Syntax.CatchDeclarationSyntax CatchDeclaration(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.CatchFilterClauseSyntax CatchFilterClause(Syntax.ExpressionSyntax filterExpression) { throw null; }

        public static Syntax.CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax filterExpression, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.CheckedStatementSyntax CheckedStatement(SyntaxKind kind, Syntax.BlockSyntax? block = null) { throw null; }

        public static Syntax.CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken keyword, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.ClassDeclarationSyntax ClassDeclaration(string identifier) { throw null; }

        public static Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken) { throw null; }

        public static Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword) { throw null; }

        public static Syntax.ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind) { throw null; }

        public static SyntaxTrivia Comment(string text) { throw null; }

        public static Syntax.CompilationUnitSyntax CompilationUnit() { throw null; }

        public static Syntax.CompilationUnitSyntax CompilationUnit(SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken endOfFileToken) { throw null; }

        public static Syntax.CompilationUnitSyntax CompilationUnit(SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Syntax.ExpressionSyntax expression, Syntax.ExpressionSyntax whenNotNull) { throw null; }

        public static Syntax.ConditionalAccessExpressionSyntax ConditionalAccessExpression(Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Syntax.ExpressionSyntax whenNotNull) { throw null; }

        public static Syntax.ConditionalExpressionSyntax ConditionalExpression(Syntax.ExpressionSyntax condition, Syntax.ExpressionSyntax whenTrue, Syntax.ExpressionSyntax whenFalse) { throw null; }

        public static Syntax.ConditionalExpressionSyntax ConditionalExpression(Syntax.ExpressionSyntax condition, SyntaxToken questionToken, Syntax.ExpressionSyntax whenTrue, SyntaxToken colonToken, Syntax.ExpressionSyntax whenFalse) { throw null; }

        public static Syntax.ConstantPatternSyntax ConstantPattern(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ConstructorConstraintSyntax ConstructorConstraint() { throw null; }

        public static Syntax.ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax initializer, Syntax.ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax initializer, Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax? initializer, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax? initializer, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax? initializer, Syntax.BlockSyntax? body, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ConstructorInitializerSyntax? initializer, Syntax.BlockSyntax body) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.ConstructorDeclarationSyntax ConstructorDeclaration(string identifier) { throw null; }

        public static Syntax.ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, Syntax.ArgumentListSyntax? argumentList = null) { throw null; }

        public static Syntax.ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, Syntax.ArgumentListSyntax argumentList) { throw null; }

        public static Syntax.ContinueStatementSyntax ContinueStatement() { throw null; }

        public static Syntax.ContinueStatementSyntax ContinueStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ContinueStatementSyntax ContinueStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists) { throw null; }

        public static Syntax.ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, Syntax.TypeSyntax type, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, Syntax.TypeSyntax type, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, Syntax.TypeSyntax type, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, Syntax.TypeSyntax type, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList<Syntax.CrefParameterSyntax> parameters = default) { throw null; }

        public static Syntax.CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.CrefParameterSyntax> parameters, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.CrefParameterSyntax CrefParameter(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList<Syntax.CrefParameterSyntax> parameters = default) { throw null; }

        public static Syntax.CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.CrefParameterSyntax> parameters, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.DeclarationExpressionSyntax DeclarationExpression(Syntax.TypeSyntax type, Syntax.VariableDesignationSyntax designation) { throw null; }

        public static Syntax.DeclarationPatternSyntax DeclarationPattern(Syntax.TypeSyntax type, Syntax.VariableDesignationSyntax designation) { throw null; }

        public static Syntax.DefaultConstraintSyntax DefaultConstraint() { throw null; }

        public static Syntax.DefaultConstraintSyntax DefaultConstraint(SyntaxToken defaultKeyword) { throw null; }

        public static Syntax.DefaultExpressionSyntax DefaultExpression(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel() { throw null; }

        public static Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken) { throw null; }

        public static Syntax.DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken) { throw null; }

        public static Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive) { throw null; }

        public static Syntax.DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive) { throw null; }

        public static Syntax.DelegateDeclarationSyntax DelegateDeclaration(Syntax.TypeSyntax returnType, SyntaxToken identifier) { throw null; }

        public static Syntax.DelegateDeclarationSyntax DelegateDeclaration(Syntax.TypeSyntax returnType, string identifier) { throw null; }

        public static Syntax.DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public static Syntax.DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ArrowExpressionClauseSyntax expressionBody) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax body) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.DestructorDeclarationSyntax DestructorDeclaration(string identifier) { throw null; }

        public static SyntaxTrivia DisabledText(string text) { throw null; }

        public static Syntax.DiscardDesignationSyntax DiscardDesignation() { throw null; }

        public static Syntax.DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken) { throw null; }

        public static Syntax.DiscardPatternSyntax DiscardPattern() { throw null; }

        public static Syntax.DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken) { throw null; }

        public static Syntax.DocumentationCommentTriviaSyntax DocumentationComment(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static SyntaxTrivia DocumentationCommentExterior(string text) { throw null; }

        public static Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<Syntax.XmlNodeSyntax> content, SyntaxToken endOfComment) { throw null; }

        public static Syntax.DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<Syntax.XmlNodeSyntax> content = default) { throw null; }

        public static Syntax.DoStatementSyntax DoStatement(Syntax.StatementSyntax statement, Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.DoStatementSyntax DoStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.StatementSyntax statement, Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.DoStatementSyntax DoStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken doKeyword, Syntax.StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.DoStatementSyntax DoStatement(SyntaxToken doKeyword, Syntax.StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken) { throw null; }

        public static SyntaxTrivia ElasticEndOfLine(string text) { throw null; }

        public static SyntaxTrivia ElasticWhitespace(string text) { throw null; }

        public static Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Syntax.ExpressionSyntax expression, Syntax.BracketedArgumentListSyntax argumentList) { throw null; }

        public static Syntax.ElementAccessExpressionSyntax ElementAccessExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ElementBindingExpressionSyntax ElementBindingExpression() { throw null; }

        public static Syntax.ElementBindingExpressionSyntax ElementBindingExpression(Syntax.BracketedArgumentListSyntax argumentList) { throw null; }

        public static Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public static Syntax.ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, Syntax.ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public static Syntax.ElseClauseSyntax ElseClause(Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }

        public static Syntax.ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken) { throw null; }

        public static Syntax.EmptyStatementSyntax EmptyStatement() { throw null; }

        public static Syntax.EmptyStatementSyntax EmptyStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.EmptyStatementSyntax EmptyStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists) { throw null; }

        public static Syntax.EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken) { throw null; }

        public static Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive) { throw null; }

        [System.Obsolete("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
        public static SyntaxTrivia EndOfLine(string text, bool elastic) { throw null; }

        public static SyntaxTrivia EndOfLine(string text) { throw null; }

        public static Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive) { throw null; }

        public static Syntax.EnumDeclarationSyntax EnumDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.BaseListSyntax? baseList, SeparatedSyntaxList<Syntax.EnumMemberDeclarationSyntax> members) { throw null; }

        public static Syntax.EnumDeclarationSyntax EnumDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, Syntax.BaseListSyntax? baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<Syntax.EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.EnumDeclarationSyntax EnumDeclaration(string identifier) { throw null; }

        public static Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken identifier, Syntax.EqualsValueClauseSyntax? equalsValue) { throw null; }

        public static Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.EqualsValueClauseSyntax? equalsValue) { throw null; }

        public static Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier) { throw null; }

        public static Syntax.EqualsValueClauseSyntax EqualsValueClause(Syntax.ExpressionSyntax value) { throw null; }

        public static Syntax.EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, Syntax.ExpressionSyntax value) { throw null; }

        public static Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(Syntax.TypeSyntax type, SyntaxToken identifier) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(Syntax.TypeSyntax type, string identifier) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax? accessorList) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax? accessorList, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax accessorList) { throw null; }

        public static Syntax.EventDeclarationSyntax EventDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, Syntax.VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Syntax.NameSyntax name, SyntaxToken dotToken) { throw null; }

        public static Syntax.ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(Syntax.NameSyntax name) { throw null; }

        public static Syntax.ExpressionColonSyntax ExpressionColon(Syntax.ExpressionSyntax expression, SyntaxToken colonToken) { throw null; }

        public static Syntax.ExpressionStatementSyntax ExpressionStatement(Syntax.ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ExpressionStatementSyntax ExpressionStatement(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ExpressionStatementSyntax ExpressionStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ExpressionStatementSyntax ExpressionStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier) { throw null; }

        public static Syntax.ExternAliasDirectiveSyntax ExternAliasDirective(string identifier) { throw null; }

        public static Syntax.FieldDeclarationSyntax FieldDeclaration(Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.FieldDeclarationSyntax FieldDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.FieldDeclarationSyntax FieldDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(Syntax.NameSyntax name) { throw null; }

        public static Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.NameSyntax name, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.FileScopedNamespaceDeclarationSyntax FileScopedNamespaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken namespaceKeyword, Syntax.NameSyntax name, SyntaxToken semicolonToken, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.FinallyClauseSyntax FinallyClause(Syntax.BlockSyntax? block = null) { throw null; }

        public static Syntax.FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.FixedStatementSyntax FixedStatement(Syntax.VariableDeclarationSyntax declaration, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.FixedStatementSyntax FixedStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.VariableDeclarationSyntax declaration, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.FixedStatementSyntax FixedStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(Syntax.TypeSyntax type, SyntaxToken identifier, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(Syntax.TypeSyntax type, string identifier, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.TypeSyntax type, SyntaxToken identifier, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(Syntax.ExpressionSyntax variable, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax variable, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax variable, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax variable, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax variable, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForStatementSyntax ForStatement(Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForStatementSyntax ForStatement(Syntax.VariableDeclarationSyntax? declaration, SeparatedSyntaxList<Syntax.ExpressionSyntax> initializers, Syntax.ExpressionSyntax? condition, SeparatedSyntaxList<Syntax.ExpressionSyntax> incrementors, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForStatementSyntax ForStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.VariableDeclarationSyntax? declaration, SeparatedSyntaxList<Syntax.ExpressionSyntax> initializers, Syntax.ExpressionSyntax? condition, SeparatedSyntaxList<Syntax.ExpressionSyntax> incrementors, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForStatementSyntax ForStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax? declaration, SeparatedSyntaxList<Syntax.ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, Syntax.ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<Syntax.ExpressionSyntax> incrementors, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax? declaration, SeparatedSyntaxList<Syntax.ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, Syntax.ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<Syntax.ExpressionSyntax> incrementors, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.FromClauseSyntax FromClause(Syntax.TypeSyntax? type, SyntaxToken identifier, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.FromClauseSyntax FromClause(SyntaxToken identifier, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.FromClauseSyntax FromClause(SyntaxToken fromKeyword, Syntax.TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.FromClauseSyntax FromClause(string identifier, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(SyntaxToken managedOrUnmanagedKeyword, Syntax.FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }

        public static Syntax.FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(SyntaxToken managedOrUnmanagedKeyword) { throw null; }

        public static Syntax.FunctionPointerParameterSyntax FunctionPointerParameter(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.FunctionPointerParameterSyntax FunctionPointerParameter(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.FunctionPointerParameterListSyntax FunctionPointerParameterList(SeparatedSyntaxList<Syntax.FunctionPointerParameterSyntax> parameters = default) { throw null; }

        public static Syntax.FunctionPointerParameterListSyntax FunctionPointerParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<Syntax.FunctionPointerParameterSyntax> parameters, SyntaxToken greaterThanToken) { throw null; }

        public static Syntax.FunctionPointerTypeSyntax FunctionPointerType() { throw null; }

        public static Syntax.FunctionPointerTypeSyntax FunctionPointerType(Syntax.FunctionPointerCallingConventionSyntax? callingConvention, Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }

        public static Syntax.FunctionPointerTypeSyntax FunctionPointerType(SyntaxToken delegateKeyword, SyntaxToken asteriskToken, Syntax.FunctionPointerCallingConventionSyntax? callingConvention, Syntax.FunctionPointerParameterListSyntax parameterList) { throw null; }

        public static Syntax.FunctionPointerUnmanagedCallingConventionSyntax FunctionPointerUnmanagedCallingConvention(SyntaxToken name) { throw null; }

        public static Syntax.FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(SeparatedSyntaxList<Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions = default) { throw null; }

        public static Syntax.FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, SyntaxToken closeBracketToken) { throw null; }

        public static Syntax.GenericNameSyntax GenericName(SyntaxToken identifier, Syntax.TypeArgumentListSyntax typeArgumentList) { throw null; }

        public static Syntax.GenericNameSyntax GenericName(SyntaxToken identifier) { throw null; }

        public static Syntax.GenericNameSyntax GenericName(string identifier) { throw null; }

        public static Syntax.ExpressionSyntax? GetNonGenericExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ExpressionSyntax GetStandaloneExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.GlobalStatementSyntax GlobalStatement(Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.GlobalStatementSyntax GlobalStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.GotoStatementSyntax GotoStatement(SyntaxKind kind, Syntax.ExpressionSyntax? expression = null) { throw null; }

        public static Syntax.GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken caseOrDefaultKeyword, Syntax.ExpressionSyntax? expression) { throw null; }

        public static Syntax.GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, Syntax.ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, Syntax.ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.GroupClauseSyntax GroupClause(Syntax.ExpressionSyntax groupExpression, Syntax.ExpressionSyntax byExpression) { throw null; }

        public static Syntax.GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, Syntax.ExpressionSyntax groupExpression, SyntaxToken byKeyword, Syntax.ExpressionSyntax byExpression) { throw null; }

        public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Identifier(string text) { throw null; }

        public static Syntax.IdentifierNameSyntax IdentifierName(SyntaxToken identifier) { throw null; }

        public static Syntax.IdentifierNameSyntax IdentifierName(string name) { throw null; }

        public static Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(Syntax.ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public static Syntax.IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, Syntax.ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public static Syntax.IfStatementSyntax IfStatement(Syntax.ExpressionSyntax condition, Syntax.StatementSyntax statement, Syntax.ElseClauseSyntax? @else) { throw null; }

        public static Syntax.IfStatementSyntax IfStatement(Syntax.ExpressionSyntax condition, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.IfStatementSyntax IfStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax condition, Syntax.StatementSyntax statement, Syntax.ElseClauseSyntax? @else) { throw null; }

        public static Syntax.IfStatementSyntax IfStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, Syntax.StatementSyntax statement, Syntax.ElseClauseSyntax? @else) { throw null; }

        public static Syntax.IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, Syntax.StatementSyntax statement, Syntax.ElseClauseSyntax? @else) { throw null; }

        public static Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.ImplicitElementAccessSyntax ImplicitElementAccess() { throw null; }

        public static Syntax.ImplicitElementAccessSyntax ImplicitElementAccess(Syntax.BracketedArgumentListSyntax argumentList) { throw null; }

        public static Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression() { throw null; }

        public static Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(Syntax.ArgumentListSyntax argumentList, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(SyntaxToken newKeyword, Syntax.ArgumentListSyntax argumentList, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.IncompleteMemberSyntax IncompleteMember(Syntax.TypeSyntax? type = null) { throw null; }

        public static Syntax.IncompleteMemberSyntax IncompleteMember(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax? type) { throw null; }

        public static Syntax.IndexerDeclarationSyntax IndexerDeclaration(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Syntax.BracketedParameterListSyntax parameterList, Syntax.AccessorListSyntax? accessorList, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, Syntax.BracketedParameterListSyntax parameterList, Syntax.AccessorListSyntax? accessorList) { throw null; }

        public static Syntax.IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, Syntax.BracketedParameterListSyntax parameterList, Syntax.AccessorListSyntax? accessorList, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.IndexerMemberCrefSyntax IndexerMemberCref(Syntax.CrefBracketedParameterListSyntax? parameters = null) { throw null; }

        public static Syntax.IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, Syntax.CrefBracketedParameterListSyntax? parameters) { throw null; }

        public static Syntax.InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<Syntax.ExpressionSyntax> expressions = default) { throw null; }

        public static Syntax.InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<Syntax.ExpressionSyntax> expressions, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.InterfaceDeclarationSyntax InterfaceDeclaration(string identifier) { throw null; }

        public static Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<Syntax.InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken) { throw null; }

        public static Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<Syntax.InterpolatedStringContentSyntax> contents) { throw null; }

        public static Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxToken stringEndToken) { throw null; }

        public static Syntax.InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken) { throw null; }

        public static Syntax.InterpolatedStringTextSyntax InterpolatedStringText() { throw null; }

        public static Syntax.InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken) { throw null; }

        public static Syntax.InterpolationSyntax Interpolation(Syntax.ExpressionSyntax expression, Syntax.InterpolationAlignmentClauseSyntax? alignmentClause, Syntax.InterpolationFormatClauseSyntax? formatClause) { throw null; }

        public static Syntax.InterpolationSyntax Interpolation(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.InterpolationSyntax Interpolation(SyntaxToken openBraceToken, Syntax.ExpressionSyntax expression, Syntax.InterpolationAlignmentClauseSyntax? alignmentClause, Syntax.InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, Syntax.ExpressionSyntax value) { throw null; }

        public static Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken) { throw null; }

        public static Syntax.InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken) { throw null; }

        public static Syntax.InvocationExpressionSyntax InvocationExpression(Syntax.ExpressionSyntax expression, Syntax.ArgumentListSyntax argumentList) { throw null; }

        public static Syntax.InvocationExpressionSyntax InvocationExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static bool IsCompleteSubmission(SyntaxTree tree) { throw null; }

        public static Syntax.IsPatternExpressionSyntax IsPatternExpression(Syntax.ExpressionSyntax expression, Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.IsPatternExpressionSyntax IsPatternExpression(Syntax.ExpressionSyntax expression, SyntaxToken isKeyword, Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.JoinClauseSyntax JoinClause(Syntax.TypeSyntax? type, SyntaxToken identifier, Syntax.ExpressionSyntax inExpression, Syntax.ExpressionSyntax leftExpression, Syntax.ExpressionSyntax rightExpression, Syntax.JoinIntoClauseSyntax? into) { throw null; }

        public static Syntax.JoinClauseSyntax JoinClause(SyntaxToken identifier, Syntax.ExpressionSyntax inExpression, Syntax.ExpressionSyntax leftExpression, Syntax.ExpressionSyntax rightExpression) { throw null; }

        public static Syntax.JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, Syntax.TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, Syntax.ExpressionSyntax inExpression, SyntaxToken onKeyword, Syntax.ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, Syntax.ExpressionSyntax rightExpression, Syntax.JoinIntoClauseSyntax? into) { throw null; }

        public static Syntax.JoinClauseSyntax JoinClause(string identifier, Syntax.ExpressionSyntax inExpression, Syntax.ExpressionSyntax leftExpression, Syntax.ExpressionSyntax rightExpression) { throw null; }

        public static Syntax.JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier) { throw null; }

        public static Syntax.JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier) { throw null; }

        public static Syntax.JoinIntoClauseSyntax JoinIntoClause(string identifier) { throw null; }

        public static Syntax.LabeledStatementSyntax LabeledStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken identifier, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LabeledStatementSyntax LabeledStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LabeledStatementSyntax LabeledStatement(string identifier, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LetClauseSyntax LetClause(SyntaxToken identifier, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.LetClauseSyntax LetClause(string identifier, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.LineDirectivePositionSyntax LineDirectivePosition(SyntaxToken openParenToken, SyntaxToken line, SyntaxToken commaToken, SyntaxToken character, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.LineDirectivePositionSyntax LineDirectivePosition(SyntaxToken line, SyntaxToken character) { throw null; }

        public static Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive) { throw null; }

        public static Syntax.LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive) { throw null; }

        public static Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(Syntax.LineDirectivePositionSyntax start, Syntax.LineDirectivePositionSyntax end, SyntaxToken characterOffset, SyntaxToken file, bool isActive) { throw null; }

        public static Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(Syntax.LineDirectivePositionSyntax start, Syntax.LineDirectivePositionSyntax end, SyntaxToken file, bool isActive) { throw null; }

        public static Syntax.LineSpanDirectiveTriviaSyntax LineSpanDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, Syntax.LineDirectivePositionSyntax start, SyntaxToken minusToken, Syntax.LineDirectivePositionSyntax end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static SyntaxList<TNode> List<TNode>()
            where TNode : SyntaxNode { throw null; }

        public static SyntaxList<TNode> List<TNode>(System.Collections.Generic.IEnumerable<TNode> nodes)
            where TNode : SyntaxNode { throw null; }

        public static Syntax.ListPatternSyntax ListPattern(SeparatedSyntaxList<Syntax.PatternSyntax> patterns, Syntax.VariableDesignationSyntax? designation) { throw null; }

        public static Syntax.ListPatternSyntax ListPattern(SeparatedSyntaxList<Syntax.PatternSyntax> patterns = default) { throw null; }

        public static Syntax.ListPatternSyntax ListPattern(SyntaxToken openBracketToken, SeparatedSyntaxList<Syntax.PatternSyntax> patterns, SyntaxToken closeBracketToken, Syntax.VariableDesignationSyntax? designation) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, uint value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Literal(char value) { throw null; }

        public static SyntaxToken Literal(decimal value) { throw null; }

        public static SyntaxToken Literal(double value) { throw null; }

        public static SyntaxToken Literal(int value) { throw null; }

        public static SyntaxToken Literal(long value) { throw null; }

        public static SyntaxToken Literal(float value) { throw null; }

        public static SyntaxToken Literal(string text, char value) { throw null; }

        public static SyntaxToken Literal(string text, decimal value) { throw null; }

        public static SyntaxToken Literal(string text, double value) { throw null; }

        public static SyntaxToken Literal(string text, int value) { throw null; }

        public static SyntaxToken Literal(string text, long value) { throw null; }

        public static SyntaxToken Literal(string text, float value) { throw null; }

        public static SyntaxToken Literal(string text, string value) { throw null; }

        public static SyntaxToken Literal(string text, uint value) { throw null; }

        public static SyntaxToken Literal(string text, ulong value) { throw null; }

        public static SyntaxToken Literal(string value) { throw null; }

        public static SyntaxToken Literal(uint value) { throw null; }

        public static SyntaxToken Literal(ulong value) { throw null; }

        public static Syntax.LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token) { throw null; }

        public static Syntax.LiteralExpressionSyntax LiteralExpression(SyntaxKind kind) { throw null; }

        public static Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, Syntax.VariableDeclarationSyntax declaration) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Syntax.TypeSyntax returnType, SyntaxToken identifier) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(Syntax.TypeSyntax returnType, string identifier) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.LockStatementSyntax LockStatement(Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LockStatementSyntax LockStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LockStatementSyntax LockStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.MakeRefExpressionSyntax MakeRefExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, Syntax.ExpressionSyntax expression, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, Syntax.ExpressionSyntax expression, SyntaxToken operatorToken, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.MemberBindingExpressionSyntax MemberBindingExpression(Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, Syntax.SimpleNameSyntax name) { throw null; }

        public static Syntax.MethodDeclarationSyntax MethodDeclaration(Syntax.TypeSyntax returnType, SyntaxToken identifier) { throw null; }

        public static Syntax.MethodDeclarationSyntax MethodDeclaration(Syntax.TypeSyntax returnType, string identifier) { throw null; }

        public static Syntax.MethodDeclarationSyntax MethodDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.MethodDeclarationSyntax MethodDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.MethodDeclarationSyntax MethodDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.TypeParameterListSyntax typeParameterList, Syntax.ParameterListSyntax parameterList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, Syntax.BlockSyntax body, SyntaxToken semicolonToken) { throw null; }

        public static SyntaxToken MissingToken(SyntaxKind kind) { throw null; }

        public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing) { throw null; }

        public static Syntax.NameColonSyntax NameColon(Syntax.IdentifierNameSyntax name, SyntaxToken colonToken) { throw null; }

        public static Syntax.NameColonSyntax NameColon(Syntax.IdentifierNameSyntax name) { throw null; }

        public static Syntax.NameColonSyntax NameColon(string name) { throw null; }

        public static Syntax.NameEqualsSyntax NameEquals(Syntax.IdentifierNameSyntax name, SyntaxToken equalsToken) { throw null; }

        public static Syntax.NameEqualsSyntax NameEquals(Syntax.IdentifierNameSyntax name) { throw null; }

        public static Syntax.NameEqualsSyntax NameEquals(string name) { throw null; }

        public static Syntax.NameMemberCrefSyntax NameMemberCref(Syntax.TypeSyntax name, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.NameMemberCrefSyntax NameMemberCref(Syntax.TypeSyntax name) { throw null; }

        public static Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Syntax.NameSyntax name, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(Syntax.NameSyntax name) { throw null; }

        public static Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.NameSyntax name, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken namespaceKeyword, Syntax.NameSyntax name, SyntaxToken openBraceToken, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, Syntax.NameSyntax name, SyntaxToken openBraceToken, SyntaxList<Syntax.ExternAliasDirectiveSyntax> externs, SyntaxList<Syntax.UsingDirectiveSyntax> usings, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static SyntaxNodeOrTokenList NodeOrTokenList() { throw null; }

        public static SyntaxNodeOrTokenList NodeOrTokenList(params SyntaxNodeOrToken[] nodesAndTokens) { throw null; }

        public static SyntaxNodeOrTokenList NodeOrTokenList(System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> nodesAndTokens) { throw null; }

        public static Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken settingToken, SyntaxToken targetToken, bool isActive) { throw null; }

        public static Syntax.NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken settingToken, bool isActive) { throw null; }

        public static Syntax.NullableTypeSyntax NullableType(Syntax.TypeSyntax elementType, SyntaxToken questionToken) { throw null; }

        public static Syntax.NullableTypeSyntax NullableType(Syntax.TypeSyntax elementType) { throw null; }

        public static Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Syntax.TypeSyntax type, Syntax.ArgumentListSyntax? argumentList, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, Syntax.TypeSyntax type, Syntax.ArgumentListSyntax? argumentList, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression() { throw null; }

        public static Syntax.OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken) { throw null; }

        public static Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument() { throw null; }

        public static Syntax.OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(Syntax.TypeSyntax returnType, SyntaxToken operatorToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, Syntax.ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? body, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, SyntaxToken operatorToken, Syntax.CrefParameterListSyntax? parameters) { throw null; }

        public static Syntax.OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken) { throw null; }

        public static Syntax.OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<Syntax.OrderingSyntax> orderings = default) { throw null; }

        public static Syntax.OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<Syntax.OrderingSyntax> orderings) { throw null; }

        public static Syntax.OrderingSyntax Ordering(SyntaxKind kind, Syntax.ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword) { throw null; }

        public static Syntax.OrderingSyntax Ordering(SyntaxKind kind, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ParameterSyntax Parameter(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax? type, SyntaxToken identifier, Syntax.EqualsValueClauseSyntax? @default) { throw null; }

        public static Syntax.ParameterSyntax Parameter(SyntaxToken identifier) { throw null; }

        public static Syntax.ParameterListSyntax ParameterList(SeparatedSyntaxList<Syntax.ParameterSyntax> parameters = default) { throw null; }

        public static Syntax.ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.ParameterSyntax> parameters, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression() { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Syntax.ParameterListSyntax parameterList, CSharpSyntaxNode body) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax? returnType, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax? returnType, Syntax.ParameterListSyntax parameterList, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, Syntax.ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, Syntax.ParameterListSyntax parameterList, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxTokenList modifiers, Syntax.ParameterListSyntax parameterList, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxTokenList modifiers, Syntax.ParameterListSyntax parameterList, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.ParenthesizedPatternSyntax ParenthesizedPattern(Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.ParenthesizedPatternSyntax ParenthesizedPattern(SyntaxToken openParenToken, Syntax.PatternSyntax pattern, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SeparatedSyntaxList<Syntax.VariableDesignationSyntax> variables = default) { throw null; }

        public static Syntax.ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.VariableDesignationSyntax> variables, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.ArgumentListSyntax ParseArgumentList(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.AttributeArgumentListSyntax? ParseAttributeArgumentList(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.CompilationUnitSyntax ParseCompilationUnit(string text, int offset = 0, CSharpParseOptions? options = null) { throw null; }

        public static Syntax.ExpressionSyntax ParseExpression(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset = 0) { throw null; }

        public static Syntax.MemberDeclarationSyntax? ParseMemberDeclaration(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.NameSyntax ParseName(string text, int offset = 0, bool consumeFullText = true) { throw null; }

        public static Syntax.ParameterListSyntax ParseParameterList(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.StatementSyntax ParseStatement(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        [System.Obsolete("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseSyntaxTree(Text.SourceText text, ParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }

        [System.Obsolete("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseSyntaxTree(Text.SourceText text, ParseOptions? options, string path, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }

        public static SyntaxTree ParseSyntaxTree(Text.SourceText text, ParseOptions? options = null, string path = "", System.Threading.CancellationToken cancellationToken = default) { throw null; }

        [System.Obsolete("The diagnosticOptions and isGeneratedCode parameters are obsolete due to performance problems, if you are using them use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseSyntaxTree(string text, ParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, bool? isGeneratedCode, System.Threading.CancellationToken cancellationToken) { throw null; }

        [System.Obsolete("The diagnosticOptions parameter is obsolete due to performance problems, if you are passing non-null use CompilationOptions.SyntaxTreeOptionsProvider instead", false)]
        public static SyntaxTree ParseSyntaxTree(string text, ParseOptions? options, string path, System.Text.Encoding? encoding, System.Collections.Immutable.ImmutableDictionary<string, ReportDiagnostic>? diagnosticOptions, System.Threading.CancellationToken cancellationToken) { throw null; }

        public static SyntaxTree ParseSyntaxTree(string text, ParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null, System.Threading.CancellationToken cancellationToken = default) { throw null; }

        public static SyntaxToken ParseToken(string text, int offset = 0) { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxToken> ParseTokens(string text, int offset = 0, int initialTokenPosition = 0, CSharpParseOptions? options = null) { throw null; }

        public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset = 0) { throw null; }

        public static Syntax.TypeSyntax ParseTypeName(string text, int offset = 0, ParseOptions? options = null, bool consumeFullText = true) { throw null; }

        public static Syntax.TypeSyntax ParseTypeName(string text, int offset, bool consumeFullText) { throw null; }

        public static Syntax.PointerTypeSyntax PointerType(Syntax.TypeSyntax elementType, SyntaxToken asteriskToken) { throw null; }

        public static Syntax.PointerTypeSyntax PointerType(Syntax.TypeSyntax elementType) { throw null; }

        public static Syntax.PositionalPatternClauseSyntax PositionalPatternClause(SeparatedSyntaxList<Syntax.SubpatternSyntax> subpatterns = default) { throw null; }

        public static Syntax.PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.SubpatternSyntax> subpatterns, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, Syntax.ExpressionSyntax operand, SyntaxToken operatorToken) { throw null; }

        public static Syntax.PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, Syntax.ExpressionSyntax operand) { throw null; }

        public static Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive) { throw null; }

        public static Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<Syntax.ExpressionSyntax> errorCodes, bool isActive) { throw null; }

        public static Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<Syntax.ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive) { throw null; }

        public static Syntax.PredefinedTypeSyntax PredefinedType(SyntaxToken keyword) { throw null; }

        public static Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, Syntax.ExpressionSyntax operand) { throw null; }

        public static Syntax.PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, Syntax.ExpressionSyntax operand) { throw null; }

        public static SyntaxTrivia PreprocessingMessage(string text) { throw null; }

        public static Syntax.PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(Syntax.TypeSyntax type, Syntax.ArgumentListSyntax argumentList) { throw null; }

        public static Syntax.PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.PropertyDeclarationSyntax PropertyDeclaration(Syntax.TypeSyntax type, SyntaxToken identifier) { throw null; }

        public static Syntax.PropertyDeclarationSyntax PropertyDeclaration(Syntax.TypeSyntax type, string identifier) { throw null; }

        public static Syntax.PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax? accessorList, Syntax.ArrowExpressionClauseSyntax? expressionBody, Syntax.EqualsValueClauseSyntax? initializer, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax? accessorList, Syntax.ArrowExpressionClauseSyntax? expressionBody, Syntax.EqualsValueClauseSyntax? initializer) { throw null; }

        public static Syntax.PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.TypeSyntax type, Syntax.ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, Syntax.AccessorListSyntax accessorList) { throw null; }

        public static Syntax.PropertyPatternClauseSyntax PropertyPatternClause(SeparatedSyntaxList<Syntax.SubpatternSyntax> subpatterns = default) { throw null; }

        public static Syntax.PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxList<Syntax.SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.QualifiedCrefSyntax QualifiedCref(Syntax.TypeSyntax container, Syntax.MemberCrefSyntax member) { throw null; }

        public static Syntax.QualifiedCrefSyntax QualifiedCref(Syntax.TypeSyntax container, SyntaxToken dotToken, Syntax.MemberCrefSyntax member) { throw null; }

        public static Syntax.QualifiedNameSyntax QualifiedName(Syntax.NameSyntax left, Syntax.SimpleNameSyntax right) { throw null; }

        public static Syntax.QualifiedNameSyntax QualifiedName(Syntax.NameSyntax left, SyntaxToken dotToken, Syntax.SimpleNameSyntax right) { throw null; }

        public static Syntax.QueryBodySyntax QueryBody(Syntax.SelectOrGroupClauseSyntax selectOrGroup) { throw null; }

        public static Syntax.QueryBodySyntax QueryBody(SyntaxList<Syntax.QueryClauseSyntax> clauses, Syntax.SelectOrGroupClauseSyntax selectOrGroup, Syntax.QueryContinuationSyntax? continuation) { throw null; }

        public static Syntax.QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, Syntax.QueryBodySyntax body) { throw null; }

        public static Syntax.QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, Syntax.QueryBodySyntax body) { throw null; }

        public static Syntax.QueryContinuationSyntax QueryContinuation(string identifier, Syntax.QueryBodySyntax body) { throw null; }

        public static Syntax.QueryExpressionSyntax QueryExpression(Syntax.FromClauseSyntax fromClause, Syntax.QueryBodySyntax body) { throw null; }

        public static Syntax.RangeExpressionSyntax RangeExpression() { throw null; }

        public static Syntax.RangeExpressionSyntax RangeExpression(Syntax.ExpressionSyntax? leftOperand, Syntax.ExpressionSyntax? rightOperand) { throw null; }

        public static Syntax.RangeExpressionSyntax RangeExpression(Syntax.ExpressionSyntax? leftOperand, SyntaxToken operatorToken, Syntax.ExpressionSyntax? rightOperand) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken classOrStructKeyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxKind kind, SyntaxToken keyword, SyntaxToken identifier) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxKind kind, SyntaxToken keyword, string identifier) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxToken keyword, SyntaxToken identifier) { throw null; }

        public static Syntax.RecordDeclarationSyntax RecordDeclaration(SyntaxToken keyword, string identifier) { throw null; }

        public static Syntax.RecursivePatternSyntax RecursivePattern() { throw null; }

        public static Syntax.RecursivePatternSyntax RecursivePattern(Syntax.TypeSyntax? type, Syntax.PositionalPatternClauseSyntax? positionalPatternClause, Syntax.PropertyPatternClauseSyntax? propertyPatternClause, Syntax.VariableDesignationSyntax? designation) { throw null; }

        public static Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive) { throw null; }

        public static Syntax.RefExpressionSyntax RefExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.RefExpressionSyntax RefExpression(SyntaxToken refKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.RefTypeSyntax RefType(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.RefTypeSyntax RefType(SyntaxToken refKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.RefTypeExpressionSyntax RefTypeExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.RefValueExpressionSyntax RefValueExpression(Syntax.ExpressionSyntax expression, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken comma, Syntax.TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive) { throw null; }

        public static Syntax.RelationalPatternSyntax RelationalPattern(SyntaxToken operatorToken, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ReturnStatementSyntax ReturnStatement(Syntax.ExpressionSyntax? expression = null) { throw null; }

        public static Syntax.ReturnStatementSyntax ReturnStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax? expression) { throw null; }

        public static Syntax.ReturnStatementSyntax ReturnStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken returnKeyword, Syntax.ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, Syntax.ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ScopedTypeSyntax ScopedType(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.ScopedTypeSyntax ScopedType(SyntaxToken scopedKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.SelectClauseSyntax SelectClause(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>()
            where TNode : SyntaxNode { throw null; }

        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(SyntaxNodeOrTokenList nodesAndTokens)
            where TNode : SyntaxNode { throw null; }

        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes, System.Collections.Generic.IEnumerable<SyntaxToken>? separators)
            where TNode : SyntaxNode { throw null; }

        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<TNode>? nodes)
            where TNode : SyntaxNode { throw null; }

        public static SeparatedSyntaxList<TNode> SeparatedList<TNode>(System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> nodesAndTokens)
            where TNode : SyntaxNode { throw null; }

        public static Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive) { throw null; }

        public static Syntax.SimpleBaseTypeSyntax SimpleBaseType(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Syntax.ParameterSyntax parameter, CSharpSyntaxNode body) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Syntax.ParameterSyntax parameter, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(Syntax.ParameterSyntax parameter) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.ParameterSyntax parameter, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, Syntax.ParameterSyntax parameter, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, Syntax.ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, Syntax.ParameterSyntax parameter, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxTokenList modifiers, Syntax.ParameterSyntax parameter, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static Syntax.SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxTokenList modifiers, Syntax.ParameterSyntax parameter, SyntaxToken arrowToken, Syntax.BlockSyntax? block, Syntax.ExpressionSyntax? expressionBody) { throw null; }

        public static SyntaxList<TNode> SingletonList<TNode>(TNode node)
            where TNode : SyntaxNode { throw null; }

        public static SeparatedSyntaxList<TNode> SingletonSeparatedList<TNode>(TNode node)
            where TNode : SyntaxNode { throw null; }

        public static Syntax.SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier) { throw null; }

        public static Syntax.SizeOfExpressionSyntax SizeOfExpression(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia() { throw null; }

        public static Syntax.SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens) { throw null; }

        public static Syntax.SlicePatternSyntax SlicePattern(Syntax.PatternSyntax? pattern = null) { throw null; }

        public static Syntax.SlicePatternSyntax SlicePattern(SyntaxToken dotDotToken, Syntax.PatternSyntax? pattern) { throw null; }

        public static Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Syntax.TypeSyntax type, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, Syntax.TypeSyntax type, Syntax.InitializerExpressionSyntax? initializer) { throw null; }

        public static Syntax.StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, Syntax.TypeSyntax type) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<Syntax.MemberDeclarationSyntax> members) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.ParameterListSyntax? parameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(SyntaxToken identifier) { throw null; }

        public static Syntax.StructDeclarationSyntax StructDeclaration(string identifier) { throw null; }

        public static Syntax.SubpatternSyntax Subpattern(Syntax.BaseExpressionColonSyntax? expressionColon, Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.SubpatternSyntax Subpattern(Syntax.NameColonSyntax? nameColon, Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.SubpatternSyntax Subpattern(Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.SwitchExpressionSyntax SwitchExpression(Syntax.ExpressionSyntax governingExpression, SeparatedSyntaxList<Syntax.SwitchExpressionArmSyntax> arms) { throw null; }

        public static Syntax.SwitchExpressionSyntax SwitchExpression(Syntax.ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<Syntax.SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.SwitchExpressionSyntax SwitchExpression(Syntax.ExpressionSyntax governingExpression) { throw null; }

        public static Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Syntax.PatternSyntax pattern, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Syntax.PatternSyntax pattern, Syntax.WhenClauseSyntax? whenClause, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.SwitchExpressionArmSyntax SwitchExpressionArm(Syntax.PatternSyntax pattern, Syntax.WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.SwitchSectionSyntax SwitchSection() { throw null; }

        public static Syntax.SwitchSectionSyntax SwitchSection(SyntaxList<Syntax.SwitchLabelSyntax> labels, SyntaxList<Syntax.StatementSyntax> statements) { throw null; }

        public static Syntax.SwitchStatementSyntax SwitchStatement(Syntax.ExpressionSyntax expression, SyntaxList<Syntax.SwitchSectionSyntax> sections) { throw null; }

        public static Syntax.SwitchStatementSyntax SwitchStatement(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.SwitchStatementSyntax SwitchStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken switchKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<Syntax.SwitchSectionSyntax> sections, SyntaxToken closeBraceToken) { throw null; }

        public static Syntax.SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<Syntax.SwitchSectionSyntax> sections, SyntaxToken closeBraceToken) { throw null; }

        public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions? options = null, string path = "", System.Text.Encoding? encoding = null) { throw null; }

        public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text) { throw null; }

        public static Syntax.ThisExpressionSyntax ThisExpression() { throw null; }

        public static Syntax.ThisExpressionSyntax ThisExpression(SyntaxToken token) { throw null; }

        public static Syntax.ThrowExpressionSyntax ThrowExpression(Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, Syntax.ExpressionSyntax expression) { throw null; }

        public static Syntax.ThrowStatementSyntax ThrowStatement(Syntax.ExpressionSyntax? expression = null) { throw null; }

        public static Syntax.ThrowStatementSyntax ThrowStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax? expression) { throw null; }

        public static Syntax.ThrowStatementSyntax ThrowStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken throwKeyword, Syntax.ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, Syntax.ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public static SyntaxToken Token(SyntaxKind kind) { throw null; }

        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxTokenList TokenList() { throw null; }

        public static SyntaxTokenList TokenList(SyntaxToken token) { throw null; }

        public static SyntaxTokenList TokenList(params SyntaxToken[] tokens) { throw null; }

        public static SyntaxTokenList TokenList(System.Collections.Generic.IEnumerable<SyntaxToken> tokens) { throw null; }

        public static SyntaxTrivia Trivia(Syntax.StructuredTriviaSyntax node) { throw null; }

        public static SyntaxTriviaList TriviaList() { throw null; }

        public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia) { throw null; }

        public static SyntaxTriviaList TriviaList(params SyntaxTrivia[] trivias) { throw null; }

        public static SyntaxTriviaList TriviaList(System.Collections.Generic.IEnumerable<SyntaxTrivia> trivias) { throw null; }

        public static Syntax.TryStatementSyntax TryStatement(Syntax.BlockSyntax block, SyntaxList<Syntax.CatchClauseSyntax> catches, Syntax.FinallyClauseSyntax? @finally) { throw null; }

        public static Syntax.TryStatementSyntax TryStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.BlockSyntax block, SyntaxList<Syntax.CatchClauseSyntax> catches, Syntax.FinallyClauseSyntax? @finally) { throw null; }

        public static Syntax.TryStatementSyntax TryStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken tryKeyword, Syntax.BlockSyntax block, SyntaxList<Syntax.CatchClauseSyntax> catches, Syntax.FinallyClauseSyntax? @finally) { throw null; }

        public static Syntax.TryStatementSyntax TryStatement(SyntaxList<Syntax.CatchClauseSyntax> catches = default) { throw null; }

        public static Syntax.TryStatementSyntax TryStatement(SyntaxToken tryKeyword, Syntax.BlockSyntax block, SyntaxList<Syntax.CatchClauseSyntax> catches, Syntax.FinallyClauseSyntax? @finally) { throw null; }

        public static Syntax.TupleElementSyntax TupleElement(Syntax.TypeSyntax type, SyntaxToken identifier) { throw null; }

        public static Syntax.TupleElementSyntax TupleElement(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments = default) { throw null; }

        public static Syntax.TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.ArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.TupleTypeSyntax TupleType(SeparatedSyntaxList<Syntax.TupleElementSyntax> elements = default) { throw null; }

        public static Syntax.TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<Syntax.TupleElementSyntax> elements, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<Syntax.TypeSyntax> arguments = default) { throw null; }

        public static Syntax.TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<Syntax.TypeSyntax> arguments, SyntaxToken greaterThanToken) { throw null; }

        public static Syntax.TypeConstraintSyntax TypeConstraint(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.TypeCrefSyntax TypeCref(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, Syntax.TypeParameterListSyntax? typeParameterList, Syntax.BaseListSyntax? baseList, SyntaxList<Syntax.TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<Syntax.MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxToken identifier) { throw null; }

        public static Syntax.TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, string identifier) { throw null; }

        public static Syntax.TypeOfExpressionSyntax TypeOfExpression(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, Syntax.TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public static Syntax.TypeParameterSyntax TypeParameter(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier) { throw null; }

        public static Syntax.TypeParameterSyntax TypeParameter(SyntaxToken identifier) { throw null; }

        public static Syntax.TypeParameterSyntax TypeParameter(string identifier) { throw null; }

        public static Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Syntax.IdentifierNameSyntax name, SeparatedSyntaxList<Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }

        public static Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(Syntax.IdentifierNameSyntax name) { throw null; }

        public static Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, Syntax.IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<Syntax.TypeParameterConstraintSyntax> constraints) { throw null; }

        public static Syntax.TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name) { throw null; }

        public static Syntax.TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<Syntax.TypeParameterSyntax> parameters = default) { throw null; }

        public static Syntax.TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<Syntax.TypeParameterSyntax> parameters, SyntaxToken greaterThanToken) { throw null; }

        public static Syntax.TypePatternSyntax TypePattern(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.UnaryPatternSyntax UnaryPattern(Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.UnaryPatternSyntax UnaryPattern(SyntaxToken operatorToken, Syntax.PatternSyntax pattern) { throw null; }

        public static Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive) { throw null; }

        public static Syntax.UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive) { throw null; }

        public static Syntax.UnsafeStatementSyntax UnsafeStatement(Syntax.BlockSyntax? block = null) { throw null; }

        public static Syntax.UnsafeStatementSyntax UnsafeStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.UnsafeStatementSyntax UnsafeStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken unsafeKeyword, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, Syntax.BlockSyntax block) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(Syntax.NameEqualsSyntax alias, Syntax.NameSyntax name) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(Syntax.NameEqualsSyntax? alias, Syntax.TypeSyntax namespaceOrType) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(Syntax.NameSyntax name) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(Syntax.TypeSyntax namespaceOrType) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, Syntax.NameEqualsSyntax? alias, Syntax.NameSyntax name) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, Syntax.NameEqualsSyntax? alias, Syntax.NameSyntax name, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(SyntaxToken globalKeyword, SyntaxToken usingKeyword, SyntaxToken staticKeyword, Syntax.NameEqualsSyntax? alias, Syntax.NameSyntax name, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.UsingDirectiveSyntax UsingDirective(SyntaxToken globalKeyword, SyntaxToken usingKeyword, SyntaxToken staticKeyword, SyntaxToken unsafeKeyword, Syntax.NameEqualsSyntax? alias, Syntax.TypeSyntax namespaceOrType, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(Syntax.VariableDeclarationSyntax? declaration, Syntax.ExpressionSyntax? expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.VariableDeclarationSyntax? declaration, Syntax.ExpressionSyntax? expression, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax? declaration, Syntax.ExpressionSyntax? expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax? declaration, Syntax.ExpressionSyntax? expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, Syntax.VariableDeclarationSyntax? declaration, Syntax.ExpressionSyntax? expression, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.VariableDeclarationSyntax VariableDeclaration(Syntax.TypeSyntax type, SeparatedSyntaxList<Syntax.VariableDeclaratorSyntax> variables) { throw null; }

        public static Syntax.VariableDeclarationSyntax VariableDeclaration(Syntax.TypeSyntax type) { throw null; }

        public static Syntax.VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, Syntax.BracketedArgumentListSyntax? argumentList, Syntax.EqualsValueClauseSyntax? initializer) { throw null; }

        public static Syntax.VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier) { throw null; }

        public static Syntax.VariableDeclaratorSyntax VariableDeclarator(string identifier) { throw null; }

        public static Syntax.VarPatternSyntax VarPattern(Syntax.VariableDesignationSyntax designation) { throw null; }

        public static Syntax.VarPatternSyntax VarPattern(SyntaxToken varKeyword, Syntax.VariableDesignationSyntax designation) { throw null; }

        public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing) { throw null; }

        public static Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public static Syntax.WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive) { throw null; }

        public static Syntax.WhenClauseSyntax WhenClause(Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.WhereClauseSyntax WhereClause(Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, Syntax.ExpressionSyntax condition) { throw null; }

        public static Syntax.WhileStatementSyntax WhileStatement(Syntax.ExpressionSyntax condition, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.WhileStatementSyntax WhileStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax condition, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.WhileStatementSyntax WhileStatement(SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        public static Syntax.WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, Syntax.ExpressionSyntax condition, SyntaxToken closeParenToken, Syntax.StatementSyntax statement) { throw null; }

        [System.Obsolete("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
        public static SyntaxTrivia Whitespace(string text, bool elastic) { throw null; }

        public static SyntaxTrivia Whitespace(string text) { throw null; }

        public static Syntax.WithExpressionSyntax WithExpression(Syntax.ExpressionSyntax expression, Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.WithExpressionSyntax WithExpression(Syntax.ExpressionSyntax expression, SyntaxToken withKeyword, Syntax.InitializerExpressionSyntax initializer) { throw null; }

        public static Syntax.XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken) { throw null; }

        public static Syntax.XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default) { throw null; }

        public static Syntax.XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken) { throw null; }

        public static Syntax.XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default) { throw null; }

        public static Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Syntax.CrefSyntax cref, SyntaxKind quoteKind) { throw null; }

        public static Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Syntax.CrefSyntax cref) { throw null; }

        public static Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, Syntax.CrefSyntax cref, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlCrefAttributeSyntax XmlCrefAttribute(Syntax.XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Syntax.CrefSyntax cref, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlElementSyntax XmlElement(Syntax.XmlElementStartTagSyntax startTag, Syntax.XmlElementEndTagSyntax endTag) { throw null; }

        public static Syntax.XmlElementSyntax XmlElement(Syntax.XmlElementStartTagSyntax startTag, SyntaxList<Syntax.XmlNodeSyntax> content, Syntax.XmlElementEndTagSyntax endTag) { throw null; }

        public static Syntax.XmlElementSyntax XmlElement(Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlElement(string localName, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementEndTagSyntax XmlElementEndTag(Syntax.XmlNameSyntax name) { throw null; }

        public static Syntax.XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, Syntax.XmlNameSyntax name, SyntaxToken greaterThanToken) { throw null; }

        public static Syntax.XmlElementStartTagSyntax XmlElementStartTag(Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlAttributeSyntax> attributes) { throw null; }

        public static Syntax.XmlElementStartTagSyntax XmlElementStartTag(Syntax.XmlNameSyntax name) { throw null; }

        public static Syntax.XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlEmptyElement(Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlAttributeSyntax> attributes) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlEmptyElement(Syntax.XmlNameSyntax name) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlEmptyElement(string localName) { throw null; }

        public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing) { throw null; }

        public static Syntax.XmlElementSyntax XmlExampleElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlExampleElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlExceptionElement(Syntax.CrefSyntax cref, params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlExceptionElement(Syntax.CrefSyntax cref, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlMultiLineElement(Syntax.XmlNameSyntax name, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlNameSyntax XmlName(Syntax.XmlPrefixSyntax? prefix, SyntaxToken localName) { throw null; }

        public static Syntax.XmlNameSyntax XmlName(SyntaxToken localName) { throw null; }

        public static Syntax.XmlNameSyntax XmlName(string localName) { throw null; }

        public static Syntax.XmlNameAttributeSyntax XmlNameAttribute(Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, Syntax.IdentifierNameSyntax identifier, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlNameAttributeSyntax XmlNameAttribute(Syntax.XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Syntax.IdentifierNameSyntax identifier, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlNameAttributeSyntax XmlNameAttribute(Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlNameAttributeSyntax XmlNameAttribute(string parameterName) { throw null; }

        public static Syntax.XmlTextSyntax XmlNewLine(string text) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlNullKeywordElement() { throw null; }

        public static Syntax.XmlElementSyntax XmlParaElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlParaElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlParamElement(string parameterName, params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlParamElement(string parameterName, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlParamRefElement(string parameterName) { throw null; }

        public static Syntax.XmlElementSyntax XmlPermissionElement(Syntax.CrefSyntax cref, params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlPermissionElement(Syntax.CrefSyntax cref, SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlPlaceholderElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlPlaceholderElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken) { throw null; }

        public static Syntax.XmlPrefixSyntax XmlPrefix(SyntaxToken prefix) { throw null; }

        public static Syntax.XmlPrefixSyntax XmlPrefix(string prefix) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlPreliminaryElement() { throw null; }

        public static Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Syntax.XmlNameSyntax name, SyntaxTokenList textTokens) { throw null; }

        public static Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(Syntax.XmlNameSyntax name) { throw null; }

        public static Syntax.XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, Syntax.XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken) { throw null; }

        public static Syntax.XmlElementSyntax XmlRemarksElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlRemarksElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlElementSyntax XmlReturnsElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlReturnsElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlSeeAlsoElement(Syntax.CrefSyntax cref) { throw null; }

        public static Syntax.XmlElementSyntax XmlSeeAlsoElement(System.Uri linkAddress, SyntaxList<Syntax.XmlNodeSyntax> linkText) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlSeeElement(Syntax.CrefSyntax cref) { throw null; }

        public static Syntax.XmlElementSyntax XmlSummaryElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlSummaryElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.XmlTextSyntax XmlText() { throw null; }

        public static Syntax.XmlTextSyntax XmlText(params SyntaxToken[] textTokens) { throw null; }

        public static Syntax.XmlTextSyntax XmlText(SyntaxTokenList textTokens) { throw null; }

        public static Syntax.XmlTextSyntax XmlText(string value) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(Syntax.XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(Syntax.XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(Syntax.XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, params SyntaxToken[] textTokens) { throw null; }

        public static Syntax.XmlTextAttributeSyntax XmlTextAttribute(string name, string value) { throw null; }

        public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken XmlTextLiteral(string text, string value) { throw null; }

        public static SyntaxToken XmlTextLiteral(string value) { throw null; }

        public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing) { throw null; }

        public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment) { throw null; }

        public static SyntaxToken XmlTextNewLine(string text) { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement() { throw null; }

        public static Syntax.XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance) { throw null; }

        public static Syntax.XmlElementSyntax XmlValueElement(params Syntax.XmlNodeSyntax[] content) { throw null; }

        public static Syntax.XmlElementSyntax XmlValueElement(SyntaxList<Syntax.XmlNodeSyntax> content) { throw null; }

        public static Syntax.YieldStatementSyntax YieldStatement(SyntaxKind kind, Syntax.ExpressionSyntax? expression = null) { throw null; }

        public static Syntax.YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, Syntax.ExpressionSyntax? expression) { throw null; }

        public static Syntax.YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxList<Syntax.AttributeListSyntax> attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, Syntax.ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public static Syntax.YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, Syntax.ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }
    }

    public static partial class SyntaxFacts
    {
        public static System.Collections.Generic.IEqualityComparer<SyntaxKind> EqualityComparer { get { throw null; } }

        public static SyntaxKind GetAccessorDeclarationKind(SyntaxKind keyword) { throw null; }

        public static SyntaxKind GetAssignmentExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetBaseTypeDeclarationKind(SyntaxKind kind) { throw null; }

        public static SyntaxKind GetBinaryExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetCheckStatement(SyntaxKind keyword) { throw null; }

        public static SyntaxKind GetContextualKeywordKind(string text) { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxKind> GetContextualKeywordKinds() { throw null; }

        public static SyntaxKind GetInstanceExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetKeywordKind(string text) { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxKind> GetKeywordKinds() { throw null; }

        public static SyntaxKind GetLiteralExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetOperatorKind(string operatorMetadataName) { throw null; }

        public static SyntaxKind GetPostfixUnaryExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetPrefixUnaryExpression(SyntaxKind token) { throw null; }

        public static SyntaxKind GetPreprocessorKeywordKind(string text) { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxKind> GetPreprocessorKeywordKinds() { throw null; }

        public static SyntaxKind GetPrimaryFunction(SyntaxKind keyword) { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxKind> GetPunctuationKinds() { throw null; }

        public static System.Collections.Generic.IEnumerable<SyntaxKind> GetReservedKeywordKinds() { throw null; }

        public static SyntaxKind GetSwitchLabelKind(SyntaxKind keyword) { throw null; }

        public static string GetText(Accessibility accessibility) { throw null; }

        public static string GetText(SyntaxKind kind) { throw null; }

        public static SyntaxKind GetTypeDeclarationKind(SyntaxKind kind) { throw null; }

        public static bool IsAccessibilityModifier(SyntaxKind kind) { throw null; }

        public static bool IsAccessorDeclaration(SyntaxKind kind) { throw null; }

        public static bool IsAccessorDeclarationKeyword(SyntaxKind keyword) { throw null; }

        public static bool IsAliasQualifier(SyntaxNode node) { throw null; }

        public static bool IsAnyOverloadableOperator(SyntaxKind kind) { throw null; }

        public static bool IsAnyToken(SyntaxKind kind) { throw null; }

        public static bool IsAnyUnaryExpression(SyntaxKind token) { throw null; }

        public static bool IsAssignmentExpression(SyntaxKind kind) { throw null; }

        public static bool IsAssignmentExpressionOperatorToken(SyntaxKind token) { throw null; }

        public static bool IsAttributeName(SyntaxNode node) { throw null; }

        public static bool IsAttributeTargetSpecifier(SyntaxKind kind) { throw null; }

        public static bool IsBinaryExpression(SyntaxKind token) { throw null; }

        public static bool IsBinaryExpressionOperatorToken(SyntaxKind token) { throw null; }

        public static bool IsCheckedOperator(string operatorMetadataName) { throw null; }

        public static bool IsContextualKeyword(SyntaxKind kind) { throw null; }

        public static bool IsDocumentationCommentTrivia(SyntaxKind kind) { throw null; }

        public static bool IsFixedStatementExpression(SyntaxNode node) { throw null; }

        public static bool IsGlobalMemberDeclaration(SyntaxKind kind) { throw null; }

        public static bool IsIdentifierPartCharacter(char ch) { throw null; }

        public static bool IsIdentifierStartCharacter(char ch) { throw null; }

        public static bool IsIndexed(Syntax.ExpressionSyntax node) { throw null; }

        public static bool IsInNamespaceOrTypeContext(Syntax.ExpressionSyntax? node) { throw null; }

        public static bool IsInstanceExpression(SyntaxKind token) { throw null; }

        public static bool IsInTypeOnlyContext(Syntax.ExpressionSyntax node) { throw null; }

        public static bool IsInvoked(Syntax.ExpressionSyntax node) { throw null; }

        public static bool IsKeywordKind(SyntaxKind kind) { throw null; }

        [System.Obsolete("IsLambdaBody API is obsolete", true)]
        public static bool IsLambdaBody(SyntaxNode node) { throw null; }

        public static bool IsLanguagePunctuation(SyntaxKind kind) { throw null; }

        public static bool IsLiteralExpression(SyntaxKind token) { throw null; }

        public static bool IsName(SyntaxKind kind) { throw null; }

        public static bool IsNamedArgumentName(SyntaxNode node) { throw null; }

        public static bool IsNamespaceAliasQualifier(Syntax.ExpressionSyntax node) { throw null; }

        public static bool IsNamespaceMemberDeclaration(SyntaxKind kind) { throw null; }

        public static bool IsNewLine(char ch) { throw null; }

        public static bool IsOverloadableBinaryOperator(SyntaxKind kind) { throw null; }

        public static bool IsOverloadableUnaryOperator(SyntaxKind kind) { throw null; }

        public static bool IsPostfixUnaryExpression(SyntaxKind token) { throw null; }

        public static bool IsPostfixUnaryExpressionToken(SyntaxKind token) { throw null; }

        public static bool IsPredefinedType(SyntaxKind kind) { throw null; }

        public static bool IsPrefixUnaryExpression(SyntaxKind token) { throw null; }

        public static bool IsPrefixUnaryExpressionOperatorToken(SyntaxKind token) { throw null; }

        public static bool IsPreprocessorDirective(SyntaxKind kind) { throw null; }

        public static bool IsPreprocessorKeyword(SyntaxKind kind) { throw null; }

        public static bool IsPreprocessorPunctuation(SyntaxKind kind) { throw null; }

        public static bool IsPrimaryFunction(SyntaxKind keyword) { throw null; }

        public static bool IsPunctuation(SyntaxKind kind) { throw null; }

        public static bool IsPunctuationOrKeyword(SyntaxKind kind) { throw null; }

        public static bool IsQueryContextualKeyword(SyntaxKind kind) { throw null; }

        public static bool IsReservedKeyword(SyntaxKind kind) { throw null; }

        public static bool IsReservedTupleElementName(string elementName) { throw null; }

        public static bool IsTrivia(SyntaxKind kind) { throw null; }

        public static bool IsTypeDeclaration(SyntaxKind kind) { throw null; }

        public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind) { throw null; }

        public static bool IsTypeSyntax(SyntaxKind kind) { throw null; }

        public static bool IsUnaryOperatorDeclarationToken(SyntaxKind token) { throw null; }

        public static bool IsValidIdentifier(string? name) { throw null; }

        public static bool IsWhitespace(char ch) { throw null; }

        public static string? TryGetInferredMemberName(this SyntaxNode syntax) { throw null; }
    }

    public enum SyntaxKind : ushort
    {
        None = 0,
        List = 1,
        TildeToken = 8193,
        ExclamationToken = 8194,
        DollarToken = 8195,
        PercentToken = 8196,
        CaretToken = 8197,
        AmpersandToken = 8198,
        AsteriskToken = 8199,
        OpenParenToken = 8200,
        CloseParenToken = 8201,
        MinusToken = 8202,
        PlusToken = 8203,
        EqualsToken = 8204,
        OpenBraceToken = 8205,
        CloseBraceToken = 8206,
        OpenBracketToken = 8207,
        CloseBracketToken = 8208,
        BarToken = 8209,
        BackslashToken = 8210,
        ColonToken = 8211,
        SemicolonToken = 8212,
        DoubleQuoteToken = 8213,
        SingleQuoteToken = 8214,
        LessThanToken = 8215,
        CommaToken = 8216,
        GreaterThanToken = 8217,
        DotToken = 8218,
        QuestionToken = 8219,
        HashToken = 8220,
        SlashToken = 8221,
        DotDotToken = 8222,
        SlashGreaterThanToken = 8232,
        LessThanSlashToken = 8233,
        XmlCommentStartToken = 8234,
        XmlCommentEndToken = 8235,
        XmlCDataStartToken = 8236,
        XmlCDataEndToken = 8237,
        XmlProcessingInstructionStartToken = 8238,
        XmlProcessingInstructionEndToken = 8239,
        BarBarToken = 8260,
        AmpersandAmpersandToken = 8261,
        MinusMinusToken = 8262,
        PlusPlusToken = 8263,
        ColonColonToken = 8264,
        QuestionQuestionToken = 8265,
        MinusGreaterThanToken = 8266,
        ExclamationEqualsToken = 8267,
        EqualsEqualsToken = 8268,
        EqualsGreaterThanToken = 8269,
        LessThanEqualsToken = 8270,
        LessThanLessThanToken = 8271,
        LessThanLessThanEqualsToken = 8272,
        GreaterThanEqualsToken = 8273,
        GreaterThanGreaterThanToken = 8274,
        GreaterThanGreaterThanEqualsToken = 8275,
        SlashEqualsToken = 8276,
        AsteriskEqualsToken = 8277,
        BarEqualsToken = 8278,
        AmpersandEqualsToken = 8279,
        PlusEqualsToken = 8280,
        MinusEqualsToken = 8281,
        CaretEqualsToken = 8282,
        PercentEqualsToken = 8283,
        QuestionQuestionEqualsToken = 8284,
        GreaterThanGreaterThanGreaterThanToken = 8286,
        GreaterThanGreaterThanGreaterThanEqualsToken = 8287,
        BoolKeyword = 8304,
        ByteKeyword = 8305,
        SByteKeyword = 8306,
        ShortKeyword = 8307,
        UShortKeyword = 8308,
        IntKeyword = 8309,
        UIntKeyword = 8310,
        LongKeyword = 8311,
        ULongKeyword = 8312,
        DoubleKeyword = 8313,
        FloatKeyword = 8314,
        DecimalKeyword = 8315,
        StringKeyword = 8316,
        CharKeyword = 8317,
        VoidKeyword = 8318,
        ObjectKeyword = 8319,
        TypeOfKeyword = 8320,
        SizeOfKeyword = 8321,
        NullKeyword = 8322,
        TrueKeyword = 8323,
        FalseKeyword = 8324,
        IfKeyword = 8325,
        ElseKeyword = 8326,
        WhileKeyword = 8327,
        ForKeyword = 8328,
        ForEachKeyword = 8329,
        DoKeyword = 8330,
        SwitchKeyword = 8331,
        CaseKeyword = 8332,
        DefaultKeyword = 8333,
        TryKeyword = 8334,
        CatchKeyword = 8335,
        FinallyKeyword = 8336,
        LockKeyword = 8337,
        GotoKeyword = 8338,
        BreakKeyword = 8339,
        ContinueKeyword = 8340,
        ReturnKeyword = 8341,
        ThrowKeyword = 8342,
        PublicKeyword = 8343,
        PrivateKeyword = 8344,
        InternalKeyword = 8345,
        ProtectedKeyword = 8346,
        StaticKeyword = 8347,
        ReadOnlyKeyword = 8348,
        SealedKeyword = 8349,
        ConstKeyword = 8350,
        FixedKeyword = 8351,
        StackAllocKeyword = 8352,
        VolatileKeyword = 8353,
        NewKeyword = 8354,
        OverrideKeyword = 8355,
        AbstractKeyword = 8356,
        VirtualKeyword = 8357,
        EventKeyword = 8358,
        ExternKeyword = 8359,
        RefKeyword = 8360,
        OutKeyword = 8361,
        InKeyword = 8362,
        IsKeyword = 8363,
        AsKeyword = 8364,
        ParamsKeyword = 8365,
        ArgListKeyword = 8366,
        MakeRefKeyword = 8367,
        RefTypeKeyword = 8368,
        RefValueKeyword = 8369,
        ThisKeyword = 8370,
        BaseKeyword = 8371,
        NamespaceKeyword = 8372,
        UsingKeyword = 8373,
        ClassKeyword = 8374,
        StructKeyword = 8375,
        InterfaceKeyword = 8376,
        EnumKeyword = 8377,
        DelegateKeyword = 8378,
        CheckedKeyword = 8379,
        UncheckedKeyword = 8380,
        UnsafeKeyword = 8381,
        OperatorKeyword = 8382,
        ExplicitKeyword = 8383,
        ImplicitKeyword = 8384,
        YieldKeyword = 8405,
        PartialKeyword = 8406,
        AliasKeyword = 8407,
        GlobalKeyword = 8408,
        AssemblyKeyword = 8409,
        ModuleKeyword = 8410,
        TypeKeyword = 8411,
        FieldKeyword = 8412,
        MethodKeyword = 8413,
        ParamKeyword = 8414,
        PropertyKeyword = 8415,
        TypeVarKeyword = 8416,
        GetKeyword = 8417,
        SetKeyword = 8418,
        AddKeyword = 8419,
        RemoveKeyword = 8420,
        WhereKeyword = 8421,
        FromKeyword = 8422,
        GroupKeyword = 8423,
        JoinKeyword = 8424,
        IntoKeyword = 8425,
        LetKeyword = 8426,
        ByKeyword = 8427,
        SelectKeyword = 8428,
        OrderByKeyword = 8429,
        OnKeyword = 8430,
        EqualsKeyword = 8431,
        AscendingKeyword = 8432,
        DescendingKeyword = 8433,
        NameOfKeyword = 8434,
        AsyncKeyword = 8435,
        AwaitKeyword = 8436,
        WhenKeyword = 8437,
        OrKeyword = 8438,
        AndKeyword = 8439,
        NotKeyword = 8440,
        WithKeyword = 8442,
        InitKeyword = 8443,
        RecordKeyword = 8444,
        ManagedKeyword = 8445,
        UnmanagedKeyword = 8446,
        RequiredKeyword = 8447,
        ScopedKeyword = 8448,
        FileKeyword = 8449,
        ElifKeyword = 8467,
        EndIfKeyword = 8468,
        RegionKeyword = 8469,
        EndRegionKeyword = 8470,
        DefineKeyword = 8471,
        UndefKeyword = 8472,
        WarningKeyword = 8473,
        ErrorKeyword = 8474,
        LineKeyword = 8475,
        PragmaKeyword = 8476,
        HiddenKeyword = 8477,
        ChecksumKeyword = 8478,
        DisableKeyword = 8479,
        RestoreKeyword = 8480,
        ReferenceKeyword = 8481,
        InterpolatedStringStartToken = 8482,
        InterpolatedStringEndToken = 8483,
        InterpolatedVerbatimStringStartToken = 8484,
        LoadKeyword = 8485,
        NullableKeyword = 8486,
        EnableKeyword = 8487,
        WarningsKeyword = 8488,
        AnnotationsKeyword = 8489,
        VarKeyword = 8490,
        UnderscoreToken = 8491,
        OmittedTypeArgumentToken = 8492,
        OmittedArraySizeExpressionToken = 8493,
        EndOfDirectiveToken = 8494,
        EndOfDocumentationCommentToken = 8495,
        EndOfFileToken = 8496,
        BadToken = 8507,
        IdentifierToken = 8508,
        NumericLiteralToken = 8509,
        CharacterLiteralToken = 8510,
        StringLiteralToken = 8511,
        XmlEntityLiteralToken = 8512,
        XmlTextLiteralToken = 8513,
        XmlTextLiteralNewLineToken = 8514,
        InterpolatedStringToken = 8515,
        InterpolatedStringTextToken = 8517,
        SingleLineRawStringLiteralToken = 8518,
        MultiLineRawStringLiteralToken = 8519,
        Utf8StringLiteralToken = 8520,
        Utf8SingleLineRawStringLiteralToken = 8521,
        Utf8MultiLineRawStringLiteralToken = 8522,
        EndOfLineTrivia = 8539,
        WhitespaceTrivia = 8540,
        SingleLineCommentTrivia = 8541,
        MultiLineCommentTrivia = 8542,
        DocumentationCommentExteriorTrivia = 8543,
        SingleLineDocumentationCommentTrivia = 8544,
        MultiLineDocumentationCommentTrivia = 8545,
        DisabledTextTrivia = 8546,
        PreprocessingMessageTrivia = 8547,
        IfDirectiveTrivia = 8548,
        ElifDirectiveTrivia = 8549,
        ElseDirectiveTrivia = 8550,
        EndIfDirectiveTrivia = 8551,
        RegionDirectiveTrivia = 8552,
        EndRegionDirectiveTrivia = 8553,
        DefineDirectiveTrivia = 8554,
        UndefDirectiveTrivia = 8555,
        ErrorDirectiveTrivia = 8556,
        WarningDirectiveTrivia = 8557,
        LineDirectiveTrivia = 8558,
        PragmaWarningDirectiveTrivia = 8559,
        PragmaChecksumDirectiveTrivia = 8560,
        ReferenceDirectiveTrivia = 8561,
        BadDirectiveTrivia = 8562,
        SkippedTokensTrivia = 8563,
        ConflictMarkerTrivia = 8564,
        XmlElement = 8574,
        XmlElementStartTag = 8575,
        XmlElementEndTag = 8576,
        XmlEmptyElement = 8577,
        XmlTextAttribute = 8578,
        XmlCrefAttribute = 8579,
        XmlNameAttribute = 8580,
        XmlName = 8581,
        XmlPrefix = 8582,
        XmlText = 8583,
        XmlCDataSection = 8584,
        XmlComment = 8585,
        XmlProcessingInstruction = 8586,
        TypeCref = 8597,
        QualifiedCref = 8598,
        NameMemberCref = 8599,
        IndexerMemberCref = 8600,
        OperatorMemberCref = 8601,
        ConversionOperatorMemberCref = 8602,
        CrefParameterList = 8603,
        CrefBracketedParameterList = 8604,
        CrefParameter = 8605,
        IdentifierName = 8616,
        QualifiedName = 8617,
        GenericName = 8618,
        TypeArgumentList = 8619,
        AliasQualifiedName = 8620,
        PredefinedType = 8621,
        ArrayType = 8622,
        ArrayRankSpecifier = 8623,
        PointerType = 8624,
        NullableType = 8625,
        OmittedTypeArgument = 8626,
        ParenthesizedExpression = 8632,
        ConditionalExpression = 8633,
        InvocationExpression = 8634,
        ElementAccessExpression = 8635,
        ArgumentList = 8636,
        BracketedArgumentList = 8637,
        Argument = 8638,
        NameColon = 8639,
        CastExpression = 8640,
        AnonymousMethodExpression = 8641,
        SimpleLambdaExpression = 8642,
        ParenthesizedLambdaExpression = 8643,
        ObjectInitializerExpression = 8644,
        CollectionInitializerExpression = 8645,
        ArrayInitializerExpression = 8646,
        AnonymousObjectMemberDeclarator = 8647,
        ComplexElementInitializerExpression = 8648,
        ObjectCreationExpression = 8649,
        AnonymousObjectCreationExpression = 8650,
        ArrayCreationExpression = 8651,
        ImplicitArrayCreationExpression = 8652,
        StackAllocArrayCreationExpression = 8653,
        OmittedArraySizeExpression = 8654,
        InterpolatedStringExpression = 8655,
        ImplicitElementAccess = 8656,
        IsPatternExpression = 8657,
        RangeExpression = 8658,
        ImplicitObjectCreationExpression = 8659,
        AddExpression = 8668,
        SubtractExpression = 8669,
        MultiplyExpression = 8670,
        DivideExpression = 8671,
        ModuloExpression = 8672,
        LeftShiftExpression = 8673,
        RightShiftExpression = 8674,
        LogicalOrExpression = 8675,
        LogicalAndExpression = 8676,
        BitwiseOrExpression = 8677,
        BitwiseAndExpression = 8678,
        ExclusiveOrExpression = 8679,
        EqualsExpression = 8680,
        NotEqualsExpression = 8681,
        LessThanExpression = 8682,
        LessThanOrEqualExpression = 8683,
        GreaterThanExpression = 8684,
        GreaterThanOrEqualExpression = 8685,
        IsExpression = 8686,
        AsExpression = 8687,
        CoalesceExpression = 8688,
        SimpleMemberAccessExpression = 8689,
        PointerMemberAccessExpression = 8690,
        ConditionalAccessExpression = 8691,
        UnsignedRightShiftExpression = 8692,
        MemberBindingExpression = 8707,
        ElementBindingExpression = 8708,
        SimpleAssignmentExpression = 8714,
        AddAssignmentExpression = 8715,
        SubtractAssignmentExpression = 8716,
        MultiplyAssignmentExpression = 8717,
        DivideAssignmentExpression = 8718,
        ModuloAssignmentExpression = 8719,
        AndAssignmentExpression = 8720,
        ExclusiveOrAssignmentExpression = 8721,
        OrAssignmentExpression = 8722,
        LeftShiftAssignmentExpression = 8723,
        RightShiftAssignmentExpression = 8724,
        CoalesceAssignmentExpression = 8725,
        UnsignedRightShiftAssignmentExpression = 8726,
        UnaryPlusExpression = 8730,
        UnaryMinusExpression = 8731,
        BitwiseNotExpression = 8732,
        LogicalNotExpression = 8733,
        PreIncrementExpression = 8734,
        PreDecrementExpression = 8735,
        PointerIndirectionExpression = 8736,
        AddressOfExpression = 8737,
        PostIncrementExpression = 8738,
        PostDecrementExpression = 8739,
        AwaitExpression = 8740,
        IndexExpression = 8741,
        ThisExpression = 8746,
        BaseExpression = 8747,
        ArgListExpression = 8748,
        NumericLiteralExpression = 8749,
        StringLiteralExpression = 8750,
        CharacterLiteralExpression = 8751,
        TrueLiteralExpression = 8752,
        FalseLiteralExpression = 8753,
        NullLiteralExpression = 8754,
        DefaultLiteralExpression = 8755,
        Utf8StringLiteralExpression = 8756,
        TypeOfExpression = 8760,
        SizeOfExpression = 8761,
        CheckedExpression = 8762,
        UncheckedExpression = 8763,
        DefaultExpression = 8764,
        MakeRefExpression = 8765,
        RefValueExpression = 8766,
        RefTypeExpression = 8767,
        QueryExpression = 8774,
        QueryBody = 8775,
        FromClause = 8776,
        LetClause = 8777,
        JoinClause = 8778,
        JoinIntoClause = 8779,
        WhereClause = 8780,
        OrderByClause = 8781,
        AscendingOrdering = 8782,
        DescendingOrdering = 8783,
        SelectClause = 8784,
        GroupClause = 8785,
        QueryContinuation = 8786,
        Block = 8792,
        LocalDeclarationStatement = 8793,
        VariableDeclaration = 8794,
        VariableDeclarator = 8795,
        EqualsValueClause = 8796,
        ExpressionStatement = 8797,
        EmptyStatement = 8798,
        LabeledStatement = 8799,
        GotoStatement = 8800,
        GotoCaseStatement = 8801,
        GotoDefaultStatement = 8802,
        BreakStatement = 8803,
        ContinueStatement = 8804,
        ReturnStatement = 8805,
        YieldReturnStatement = 8806,
        YieldBreakStatement = 8807,
        ThrowStatement = 8808,
        WhileStatement = 8809,
        DoStatement = 8810,
        ForStatement = 8811,
        ForEachStatement = 8812,
        UsingStatement = 8813,
        FixedStatement = 8814,
        CheckedStatement = 8815,
        UncheckedStatement = 8816,
        UnsafeStatement = 8817,
        LockStatement = 8818,
        IfStatement = 8819,
        ElseClause = 8820,
        SwitchStatement = 8821,
        SwitchSection = 8822,
        CaseSwitchLabel = 8823,
        DefaultSwitchLabel = 8824,
        TryStatement = 8825,
        CatchClause = 8826,
        CatchDeclaration = 8827,
        CatchFilterClause = 8828,
        FinallyClause = 8829,
        LocalFunctionStatement = 8830,
        CompilationUnit = 8840,
        GlobalStatement = 8841,
        NamespaceDeclaration = 8842,
        UsingDirective = 8843,
        ExternAliasDirective = 8844,
        FileScopedNamespaceDeclaration = 8845,
        AttributeList = 8847,
        AttributeTargetSpecifier = 8848,
        Attribute = 8849,
        AttributeArgumentList = 8850,
        AttributeArgument = 8851,
        NameEquals = 8852,
        ClassDeclaration = 8855,
        StructDeclaration = 8856,
        InterfaceDeclaration = 8857,
        EnumDeclaration = 8858,
        DelegateDeclaration = 8859,
        BaseList = 8864,
        SimpleBaseType = 8865,
        TypeParameterConstraintClause = 8866,
        ConstructorConstraint = 8867,
        ClassConstraint = 8868,
        StructConstraint = 8869,
        TypeConstraint = 8870,
        ExplicitInterfaceSpecifier = 8871,
        EnumMemberDeclaration = 8872,
        FieldDeclaration = 8873,
        EventFieldDeclaration = 8874,
        MethodDeclaration = 8875,
        OperatorDeclaration = 8876,
        ConversionOperatorDeclaration = 8877,
        ConstructorDeclaration = 8878,
        BaseConstructorInitializer = 8889,
        ThisConstructorInitializer = 8890,
        DestructorDeclaration = 8891,
        PropertyDeclaration = 8892,
        EventDeclaration = 8893,
        IndexerDeclaration = 8894,
        AccessorList = 8895,
        GetAccessorDeclaration = 8896,
        SetAccessorDeclaration = 8897,
        AddAccessorDeclaration = 8898,
        RemoveAccessorDeclaration = 8899,
        UnknownAccessorDeclaration = 8900,
        ParameterList = 8906,
        BracketedParameterList = 8907,
        Parameter = 8908,
        TypeParameterList = 8909,
        TypeParameter = 8910,
        IncompleteMember = 8916,
        ArrowExpressionClause = 8917,
        Interpolation = 8918,
        InterpolatedStringText = 8919,
        InterpolationAlignmentClause = 8920,
        InterpolationFormatClause = 8921,
        ShebangDirectiveTrivia = 8922,
        LoadDirectiveTrivia = 8923,
        TupleType = 8924,
        TupleElement = 8925,
        TupleExpression = 8926,
        SingleVariableDesignation = 8927,
        ParenthesizedVariableDesignation = 8928,
        ForEachVariableStatement = 8929,
        DeclarationPattern = 9000,
        ConstantPattern = 9002,
        CasePatternSwitchLabel = 9009,
        WhenClause = 9013,
        DiscardDesignation = 9014,
        RecursivePattern = 9020,
        PropertyPatternClause = 9021,
        Subpattern = 9022,
        PositionalPatternClause = 9023,
        DiscardPattern = 9024,
        SwitchExpression = 9025,
        SwitchExpressionArm = 9026,
        VarPattern = 9027,
        ParenthesizedPattern = 9028,
        RelationalPattern = 9029,
        TypePattern = 9030,
        OrPattern = 9031,
        AndPattern = 9032,
        NotPattern = 9033,
        SlicePattern = 9034,
        ListPattern = 9035,
        DeclarationExpression = 9040,
        RefExpression = 9050,
        RefType = 9051,
        ThrowExpression = 9052,
        ImplicitStackAllocArrayCreationExpression = 9053,
        SuppressNullableWarningExpression = 9054,
        NullableDirectiveTrivia = 9055,
        FunctionPointerType = 9056,
        FunctionPointerParameter = 9057,
        FunctionPointerParameterList = 9058,
        FunctionPointerCallingConvention = 9059,
        InitAccessorDeclaration = 9060,
        WithExpression = 9061,
        WithInitializerExpression = 9062,
        RecordDeclaration = 9063,
        DefaultConstraint = 9064,
        PrimaryConstructorBaseType = 9065,
        FunctionPointerUnmanagedCallingConventionList = 9066,
        FunctionPointerUnmanagedCallingConvention = 9067,
        RecordStructDeclaration = 9068,
        ExpressionColon = 9069,
        LineDirectivePosition = 9070,
        LineSpanDirectiveTrivia = 9071,
        InterpolatedSingleLineRawStringStartToken = 9072,
        InterpolatedMultiLineRawStringStartToken = 9073,
        InterpolatedRawStringEndToken = 9074,
        ScopedType = 9075
    }

    public static partial class TypedConstantExtensions
    {
        public static string ToCSharpString(this TypedConstant constant) { throw null; }
    }
}

namespace Microsoft.CodeAnalysis.CSharp.Syntax
{
    public sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
    {
        internal AccessorDeclarationSyntax() { }

        public SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public BlockSyntax? Body { get { throw null; } }

        public ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxTokenList Modifiers { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AccessorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public AccessorDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public AccessorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax? body, SyntaxToken semicolonToken) { throw null; }

        public AccessorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public AccessorDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public AccessorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class AccessorListSyntax : CSharpSyntaxNode
    {
        internal AccessorListSyntax() { }

        public SyntaxList<AccessorDeclarationSyntax> Accessors { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items) { throw null; }

        public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken) { throw null; }

        public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors) { throw null; }

        public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }
    }

    public sealed partial class AliasQualifiedNameSyntax : NameSyntax
    {
        internal AliasQualifiedNameSyntax() { }

        public IdentifierNameSyntax Alias { get { throw null; } }

        public SyntaxToken ColonColonToken { get { throw null; } }

        public SimpleNameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name) { throw null; }

        public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias) { throw null; }

        public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken) { throw null; }

        public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name) { throw null; }
    }

    public abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
    {
        internal AnonymousFunctionExpressionSyntax() { }

        public abstract SyntaxToken AsyncKeyword { get; }
        public abstract BlockSyntax? Block { get; }

        public CSharpSyntaxNode Body { get { throw null; } }

        public abstract ExpressionSyntax? ExpressionBody { get; }
        public abstract SyntaxTokenList Modifiers { get; }

        public AnonymousFunctionExpressionSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public AnonymousFunctionExpressionSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public AnonymousFunctionExpressionSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public AnonymousFunctionExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) { throw null; }

        public AnonymousFunctionExpressionSyntax WithBlock(BlockSyntax? block) { throw null; }

        public AnonymousFunctionExpressionSyntax WithBody(CSharpSyntaxNode body) { throw null; }

        public AnonymousFunctionExpressionSyntax WithExpressionBody(ExpressionSyntax? expressionBody) { throw null; }

        public AnonymousFunctionExpressionSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }
    }

    public sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
    {
        internal AnonymousMethodExpressionSyntax() { }

        public override SyntaxToken AsyncKeyword { get { throw null; } }

        public override BlockSyntax Block { get { throw null; } }

        public SyntaxToken DelegateKeyword { get { throw null; } }

        public override ExpressionSyntax? ExpressionBody { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public ParameterListSyntax? ParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new AnonymousMethodExpressionSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new AnonymousMethodExpressionSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public new AnonymousMethodExpressionSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body) { throw null; }

        public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block, ExpressionSyntax expressionBody) { throw null; }

        public AnonymousMethodExpressionSyntax Update(SyntaxTokenList modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody) { throw null; }

        public new AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) { throw null; }

        public new AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block) { throw null; }

        public new AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body) { throw null; }

        public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword) { throw null; }

        public new AnonymousMethodExpressionSyntax WithExpressionBody(ExpressionSyntax? expressionBody) { throw null; }

        public new AnonymousMethodExpressionSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }
    }

    public sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
    {
        internal AnonymousObjectCreationExpressionSyntax() { }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get { throw null; } }

        public SyntaxToken NewKeyword { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items) { throw null; }

        public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken) { throw null; }

        public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers) { throw null; }

        public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }

        public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }
    }

    public sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
    {
        internal AnonymousObjectMemberDeclaratorSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public NameEqualsSyntax? NameEquals { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax? nameEquals, ExpressionSyntax expression) { throw null; }

        public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax? nameEquals) { throw null; }
    }

    public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
    {
        internal ArgumentListSyntax() { }

        public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ArgumentListSyntax AddArguments(params ArgumentSyntax[] items) { throw null; }

        public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public new ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) { throw null; }

        public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class ArgumentSyntax : CSharpSyntaxNode
    {
        internal ArgumentSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public NameColonSyntax? NameColon { get { throw null; } }

        public SyntaxToken RefKindKeyword { get { throw null; } }

        public SyntaxToken RefOrOutKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ArgumentSyntax Update(NameColonSyntax? nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression) { throw null; }

        public ArgumentSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public ArgumentSyntax WithNameColon(NameColonSyntax? nameColon) { throw null; }

        public ArgumentSyntax WithRefKindKeyword(SyntaxToken refKindKeyword) { throw null; }

        public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword) { throw null; }
    }

    public sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal ArrayCreationExpressionSyntax() { }

        public InitializerExpressionSyntax? Initializer { get { throw null; } }

        public SyntaxToken NewKeyword { get { throw null; } }

        public ArrayTypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items) { throw null; }

        public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer) { throw null; }

        public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax? initializer) { throw null; }

        public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }

        public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type) { throw null; }
    }

    public sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
    {
        internal ArrayRankSpecifierSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public int Rank { get { throw null; } }

        public SeparatedSyntaxList<ExpressionSyntax> Sizes { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ArrayRankSpecifierSyntax AddSizes(params ExpressionSyntax[] items) { throw null; }

        public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken) { throw null; }

        public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList<ExpressionSyntax> sizes) { throw null; }
    }

    public sealed partial class ArrayTypeSyntax : TypeSyntax
    {
        internal ArrayTypeSyntax() { }

        public TypeSyntax ElementType { get { throw null; } }

        public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items) { throw null; }

        public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }

        public ArrayTypeSyntax WithElementType(TypeSyntax elementType) { throw null; }

        public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers) { throw null; }
    }

    public sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
    {
        internal ArrowExpressionClauseSyntax() { }

        public SyntaxToken ArrowToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression) { throw null; }

        public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken) { throw null; }

        public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
    {
        internal AssignmentExpressionSyntax() { }

        public ExpressionSyntax Left { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public ExpressionSyntax Right { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right) { throw null; }

        public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left) { throw null; }

        public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public AssignmentExpressionSyntax WithRight(ExpressionSyntax right) { throw null; }
    }

    public sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
    {
        internal AttributeArgumentListSyntax() { }

        public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items) { throw null; }

        public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments) { throw null; }

        public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
    {
        internal AttributeArgumentSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public NameColonSyntax? NameColon { get { throw null; } }

        public NameEqualsSyntax? NameEquals { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AttributeArgumentSyntax Update(NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression) { throw null; }

        public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public AttributeArgumentSyntax WithNameColon(NameColonSyntax? nameColon) { throw null; }

        public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax? nameEquals) { throw null; }
    }

    public sealed partial class AttributeListSyntax : CSharpSyntaxNode
    {
        internal AttributeListSyntax() { }

        public SeparatedSyntaxList<AttributeSyntax> Attributes { get { throw null; } }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public AttributeTargetSpecifierSyntax? Target { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AttributeListSyntax AddAttributes(params AttributeSyntax[] items) { throw null; }

        public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken) { throw null; }

        public AttributeListSyntax WithAttributes(SeparatedSyntaxList<AttributeSyntax> attributes) { throw null; }

        public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax? target) { throw null; }
    }

    public sealed partial class AttributeSyntax : CSharpSyntaxNode
    {
        internal AttributeSyntax() { }

        public AttributeArgumentListSyntax? ArgumentList { get { throw null; } }

        public NameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items) { throw null; }

        public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax? argumentList) { throw null; }

        public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax? argumentList) { throw null; }

        public AttributeSyntax WithName(NameSyntax name) { throw null; }
    }

    public sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
    {
        internal AttributeTargetSpecifierSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken) { throw null; }

        public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier) { throw null; }
    }

    public sealed partial class AwaitExpressionSyntax : ExpressionSyntax
    {
        internal AwaitExpressionSyntax() { }

        public SyntaxToken AwaitKeyword { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression) { throw null; }

        public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal BadDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public BadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
    {
        internal BaseArgumentListSyntax() { }

        public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }

        public BaseArgumentListSyntax AddArguments(params ArgumentSyntax[] items) { throw null; }

        public BaseArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) { throw null; }
    }

    public abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
    {
        internal BaseCrefParameterListSyntax() { }

        public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }

        public BaseCrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items) { throw null; }

        public BaseCrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) { throw null; }
    }

    public abstract partial class BaseExpressionColonSyntax : CSharpSyntaxNode
    {
        internal BaseExpressionColonSyntax() { }

        public abstract SyntaxToken ColonToken { get; }
        public abstract ExpressionSyntax Expression { get; }

        public BaseExpressionColonSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public BaseExpressionColonSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
    {
        internal BaseExpressionSyntax() { }

        public SyntaxToken Token { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public BaseExpressionSyntax Update(SyntaxToken token) { throw null; }

        public BaseExpressionSyntax WithToken(SyntaxToken token) { throw null; }
    }

    public abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseFieldDeclarationSyntax() { }

        public abstract override SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public abstract VariableDeclarationSyntax Declaration { get; }
        public abstract override SyntaxTokenList Modifiers { get; }
        public abstract SyntaxToken SemicolonToken { get; }

        public new BaseFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public new BaseFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new BaseFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BaseFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration) { throw null; }

        public new BaseFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BaseFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class BaseListSyntax : CSharpSyntaxNode
    {
        internal BaseListSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public SeparatedSyntaxList<BaseTypeSyntax> Types { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public BaseListSyntax AddTypes(params BaseTypeSyntax[] items) { throw null; }

        public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types) { throw null; }

        public BaseListSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public BaseListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types) { throw null; }
    }

    public abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseMethodDeclarationSyntax() { }

        public abstract override SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public abstract BlockSyntax? Body { get; }
        public abstract ArrowExpressionClauseSyntax? ExpressionBody { get; }
        public abstract override SyntaxTokenList Modifiers { get; }
        public abstract ParameterListSyntax ParameterList { get; }
        public abstract SyntaxToken SemicolonToken { get; }

        public new BaseMethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseMethodDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseMethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public new BaseMethodDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public BaseMethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public new BaseMethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BaseMethodDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public BaseMethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public new BaseMethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BaseMethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public BaseMethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public abstract partial class BaseNamespaceDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseNamespaceDeclarationSyntax() { }

        public abstract SyntaxList<ExternAliasDirectiveSyntax> Externs { get; }
        public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
        public abstract NameSyntax Name { get; }
        public abstract SyntaxToken NamespaceKeyword { get; }
        public abstract SyntaxList<UsingDirectiveSyntax> Usings { get; }

        public new BaseNamespaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseNamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items) { throw null; }

        public BaseNamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new BaseNamespaceDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public BaseNamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items) { throw null; }

        public new BaseNamespaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BaseNamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs) { throw null; }

        public BaseNamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new BaseNamespaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BaseNamespaceDeclarationSyntax WithName(NameSyntax name) { throw null; }

        public BaseNamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword) { throw null; }

        public BaseNamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings) { throw null; }
    }

    public abstract partial class BaseObjectCreationExpressionSyntax : ExpressionSyntax
    {
        internal BaseObjectCreationExpressionSyntax() { }

        public abstract ArgumentListSyntax? ArgumentList { get; }
        public abstract InitializerExpressionSyntax? Initializer { get; }
        public abstract SyntaxToken NewKeyword { get; }

        public BaseObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public BaseObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax? argumentList) { throw null; }

        public BaseObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax? initializer) { throw null; }

        public BaseObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }
    }

    public abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
    {
        internal BaseParameterListSyntax() { }

        public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }

        public BaseParameterListSyntax AddParameters(params ParameterSyntax[] items) { throw null; }

        public BaseParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) { throw null; }
    }

    public abstract partial class BaseParameterSyntax : CSharpSyntaxNode
    {
        internal BaseParameterSyntax() { }

        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public abstract SyntaxTokenList Modifiers { get; }
        public abstract TypeSyntax? Type { get; }

        public BaseParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseParameterSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public BaseParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BaseParameterSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BaseParameterSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BasePropertyDeclarationSyntax() { }

        public abstract AccessorListSyntax? AccessorList { get; }
        public abstract override SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public abstract ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get; }
        public abstract override SyntaxTokenList Modifiers { get; }
        public abstract TypeSyntax Type { get; }

        public BasePropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items) { throw null; }

        public new BasePropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new BasePropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public BasePropertyDeclarationSyntax WithAccessorList(AccessorListSyntax? accessorList) { throw null; }

        public new BasePropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public new BasePropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BasePropertyDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseTypeDeclarationSyntax() { }

        public abstract BaseListSyntax? BaseList { get; }
        public abstract SyntaxToken CloseBraceToken { get; }
        public abstract SyntaxToken Identifier { get; }
        public abstract SyntaxToken OpenBraceToken { get; }
        public abstract SyntaxToken SemicolonToken { get; }

        public new BaseTypeDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BaseTypeDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public new BaseTypeDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new BaseTypeDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BaseTypeDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public BaseTypeDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public BaseTypeDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new BaseTypeDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public BaseTypeDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public BaseTypeDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public abstract partial class BaseTypeSyntax : CSharpSyntaxNode
    {
        internal BaseTypeSyntax() { }

        public abstract TypeSyntax Type { get; }

        public BaseTypeSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        internal BinaryExpressionSyntax() { }

        public ExpressionSyntax Left { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public ExpressionSyntax Right { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right) { throw null; }

        public BinaryExpressionSyntax WithLeft(ExpressionSyntax left) { throw null; }

        public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public BinaryExpressionSyntax WithRight(ExpressionSyntax right) { throw null; }
    }

    public sealed partial class BinaryPatternSyntax : PatternSyntax
    {
        internal BinaryPatternSyntax() { }

        public PatternSyntax Left { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public PatternSyntax Right { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public BinaryPatternSyntax Update(PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right) { throw null; }

        public BinaryPatternSyntax WithLeft(PatternSyntax left) { throw null; }

        public BinaryPatternSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public BinaryPatternSyntax WithRight(PatternSyntax right) { throw null; }
    }

    public sealed partial class BlockSyntax : StatementSyntax
    {
        internal BlockSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public SyntaxList<StatementSyntax> Statements { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new BlockSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BlockSyntax AddStatements(params StatementSyntax[] items) { throw null; }

        public BlockSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken) { throw null; }

        public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken) { throw null; }

        public new BlockSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements) { throw null; }
    }

    public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
    {
        internal BracketedArgumentListSyntax() { }

        public override SeparatedSyntaxList<ArgumentSyntax> Arguments { get { throw null; } }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items) { throw null; }

        public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken) { throw null; }

        public new BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) { throw null; }

        public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }
    }

    public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
    {
        internal BracketedParameterListSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items) { throw null; }

        public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken) { throw null; }

        public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public new BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) { throw null; }
    }

    public abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal BranchingDirectiveTriviaSyntax() { }

        public abstract bool BranchTaken { get; }

        public new BranchingDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new BranchingDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }
    }

    public sealed partial class BreakStatementSyntax : StatementSyntax
    {
        internal BreakStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken BreakKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new BreakStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public BreakStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken) { throw null; }

        public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken) { throw null; }

        public new BreakStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword) { throw null; }

        public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal CasePatternSwitchLabelSyntax() { }

        public override SyntaxToken ColonToken { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public WhenClauseSyntax? WhenClause { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken) { throw null; }

        public new CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public new CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern) { throw null; }

        public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax? whenClause) { throw null; }
    }

    public sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal CaseSwitchLabelSyntax() { }

        public override SyntaxToken ColonToken { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public ExpressionSyntax Value { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken) { throw null; }

        public new CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public new CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value) { throw null; }
    }

    public sealed partial class CastExpressionSyntax : ExpressionSyntax
    {
        internal CastExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression) { throw null; }

        public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CastExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public CastExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class CatchClauseSyntax : CSharpSyntaxNode
    {
        internal CatchClauseSyntax() { }

        public BlockSyntax Block { get { throw null; } }

        public SyntaxToken CatchKeyword { get { throw null; } }

        public CatchDeclarationSyntax? Declaration { get { throw null; } }

        public CatchFilterClauseSyntax? Filter { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CatchClauseSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block) { throw null; }

        public CatchClauseSyntax WithBlock(BlockSyntax block) { throw null; }

        public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword) { throw null; }

        public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax? declaration) { throw null; }

        public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax? filter) { throw null; }
    }

    public sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
    {
        internal CatchDeclarationSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken) { throw null; }

        public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public CatchDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
    {
        internal CatchFilterClauseSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax FilterExpression { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SyntaxToken WhenKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken) { throw null; }

        public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression) { throw null; }

        public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword) { throw null; }
    }

    public sealed partial class CheckedExpressionSyntax : ExpressionSyntax
    {
        internal CheckedExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class CheckedStatementSyntax : StatementSyntax
    {
        internal CheckedStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public BlockSyntax Block { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new CheckedStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public CheckedStatementSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public CheckedStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken keyword, BlockSyntax block) { throw null; }

        public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block) { throw null; }

        public new CheckedStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public CheckedStatementSyntax WithBlock(BlockSyntax block) { throw null; }

        public CheckedStatementSyntax WithKeyword(SyntaxToken keyword) { throw null; }
    }

    public sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
    {
        internal ClassDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BaseListSyntax? BaseList { get { throw null; } }

        public override SyntaxToken CloseBraceToken { get { throw null; } }

        public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public override SyntaxToken Identifier { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken OpenBraceToken { get { throw null; } }

        public override ParameterListSyntax? ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ClassDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ClassDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public new ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new ClassDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public new ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public ClassDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new ClassDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ClassDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public new ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public new ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public new ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new ClassDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public new ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public new ClassDeclarationSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }

        public new ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal ClassOrStructConstraintSyntax() { }

        public SyntaxToken ClassOrStructKeyword { get { throw null; } }

        public SyntaxToken QuestionToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword, SyntaxToken questionToken) { throw null; }

        public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword) { throw null; }

        public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword) { throw null; }

        public ClassOrStructConstraintSyntax WithQuestionToken(SyntaxToken questionToken) { throw null; }
    }

    public abstract partial class CommonForEachStatementSyntax : StatementSyntax
    {
        internal CommonForEachStatementSyntax() { }

        public abstract SyntaxToken AwaitKeyword { get; }
        public abstract SyntaxToken CloseParenToken { get; }
        public abstract ExpressionSyntax Expression { get; }
        public abstract SyntaxToken ForEachKeyword { get; }
        public abstract SyntaxToken InKeyword { get; }
        public abstract SyntaxToken OpenParenToken { get; }
        public abstract StatementSyntax Statement { get; }

        public new CommonForEachStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new CommonForEachStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public CommonForEachStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public CommonForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CommonForEachStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public CommonForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword) { throw null; }

        public CommonForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword) { throw null; }

        public CommonForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public CommonForEachStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class CompilationUnitSyntax : CSharpSyntaxNode, ICompilationUnitSyntax
    {
        internal CompilationUnitSyntax() { }

        public SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken EndOfFileToken { get { throw null; } }

        public SyntaxList<ExternAliasDirectiveSyntax> Externs { get { throw null; } }

        public SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public SyntaxList<UsingDirectiveSyntax> Usings { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CompilationUnitSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items) { throw null; }

        public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public CompilationUnitSyntax AddUsings(params UsingDirectiveSyntax[] items) { throw null; }

        public System.Collections.Generic.IList<LoadDirectiveTriviaSyntax> GetLoadDirectives() { throw null; }

        public System.Collections.Generic.IList<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives() { throw null; }

        public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken) { throw null; }

        public CompilationUnitSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken) { throw null; }

        public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs) { throw null; }

        public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public CompilationUnitSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings) { throw null; }
    }

    public sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
    {
        internal ConditionalAccessExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public ExpressionSyntax WhenNotNull { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull) { throw null; }

        public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull) { throw null; }
    }

    public abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
    {
        internal ConditionalDirectiveTriviaSyntax() { }

        public abstract ExpressionSyntax Condition { get; }
        public abstract bool ConditionValue { get; }

        public ConditionalDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition) { throw null; }
    }

    public sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
    {
        internal ConditionalExpressionSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public ExpressionSyntax Condition { get { throw null; } }

        public SyntaxToken QuestionToken { get { throw null; } }

        public ExpressionSyntax WhenFalse { get { throw null; } }

        public ExpressionSyntax WhenTrue { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse) { throw null; }

        public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken) { throw null; }

        public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse) { throw null; }

        public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue) { throw null; }
    }

    public sealed partial class ConstantPatternSyntax : PatternSyntax
    {
        internal ConstantPatternSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConstantPatternSyntax Update(ExpressionSyntax expression) { throw null; }

        public ConstantPatternSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal ConstructorConstraintSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken NewKeyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken) { throw null; }

        public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }

        public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal ConstructorDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Body { get { throw null; } }

        public override ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public ConstructorInitializerSyntax? Initializer { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override ParameterListSyntax ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ConstructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ConstructorDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public new ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public ConstructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken) { throw null; }

        public new ConstructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ConstructorDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public new ConstructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax? initializer) { throw null; }

        public new ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public new ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
    {
        internal ConstructorInitializerSyntax() { }

        public ArgumentListSyntax ArgumentList { get { throw null; } }

        public SyntaxToken ColonToken { get { throw null; } }

        public SyntaxToken ThisOrBaseKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList) { throw null; }

        public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList) { throw null; }

        public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword) { throw null; }
    }

    public sealed partial class ContinueStatementSyntax : StatementSyntax
    {
        internal ContinueStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken ContinueKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ContinueStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ContinueStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken) { throw null; }

        public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken) { throw null; }

        public new ContinueStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword) { throw null; }

        public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal ConversionOperatorDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Body { get { throw null; } }

        public SyntaxToken CheckedKeyword { get { throw null; } }

        public ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public override ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public SyntaxToken OperatorKeyword { get { throw null; } }

        public override ParameterListSyntax ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ConversionOperatorDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public new ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public ConversionOperatorDeclarationSyntax WithCheckedKeyword(SyntaxToken checkedKeyword) { throw null; }

        public ConversionOperatorDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public new ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal ConversionOperatorMemberCrefSyntax() { }

        public SyntaxToken CheckedKeyword { get { throw null; } }

        public SyntaxToken ImplicitOrExplicitKeyword { get { throw null; } }

        public SyntaxToken OperatorKeyword { get { throw null; } }

        public CrefParameterListSyntax? Parameters { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items) { throw null; }

        public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters) { throw null; }

        public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, TypeSyntax type, CrefParameterListSyntax? parameters) { throw null; }

        public ConversionOperatorMemberCrefSyntax WithCheckedKeyword(SyntaxToken checkedKeyword) { throw null; }

        public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword) { throw null; }

        public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) { throw null; }

        public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) { throw null; }

        public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal CrefBracketedParameterListSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items) { throw null; }

        public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken) { throw null; }

        public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public new CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) { throw null; }
    }

    public sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal CrefParameterListSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items) { throw null; }

        public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken) { throw null; }

        public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public new CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) { throw null; }
    }

    public sealed partial class CrefParameterSyntax : CSharpSyntaxNode
    {
        internal CrefParameterSyntax() { }

        public SyntaxToken RefKindKeyword { get { throw null; } }

        public SyntaxToken RefOrOutKeyword { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeSyntax type) { throw null; }

        public CrefParameterSyntax WithRefKindKeyword(SyntaxToken refKindKeyword) { throw null; }

        public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword) { throw null; }

        public CrefParameterSyntax WithType(TypeSyntax type) { throw null; }
    }

    public abstract partial class CrefSyntax : CSharpSyntaxNode
    {
        internal CrefSyntax() { }
    }

    public sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
    {
        internal DeclarationExpressionSyntax() { }

        public VariableDesignationSyntax Designation { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation) { throw null; }

        public DeclarationExpressionSyntax WithDesignation(VariableDesignationSyntax designation) { throw null; }

        public DeclarationExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class DeclarationPatternSyntax : PatternSyntax
    {
        internal DeclarationPatternSyntax() { }

        public VariableDesignationSyntax Designation { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation) { throw null; }

        public DeclarationPatternSyntax WithDesignation(VariableDesignationSyntax designation) { throw null; }

        public DeclarationPatternSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class DefaultConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal DefaultConstraintSyntax() { }

        public SyntaxToken DefaultKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DefaultConstraintSyntax Update(SyntaxToken defaultKeyword) { throw null; }

        public DefaultConstraintSyntax WithDefaultKeyword(SyntaxToken defaultKeyword) { throw null; }
    }

    public sealed partial class DefaultExpressionSyntax : ExpressionSyntax
    {
        internal DefaultExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public DefaultExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal DefaultSwitchLabelSyntax() { }

        public override SyntaxToken ColonToken { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken) { throw null; }

        public new DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public new DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword) { throw null; }
    }

    public sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal DefineDirectiveTriviaSyntax() { }

        public SyntaxToken DefineKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword) { throw null; }

        public new DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public DefineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public DefineDirectiveTriviaSyntax WithName(SyntaxToken name) { throw null; }
    }

    public sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
    {
        internal DelegateDeclarationSyntax() { }

        public int Arity { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public SyntaxToken DelegateKeyword { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public ParameterListSyntax ParameterList { get { throw null; } }

        public TypeSyntax ReturnType { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new DelegateDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public DelegateDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken) { throw null; }

        public new DelegateDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword) { throw null; }

        public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType) { throw null; }

        public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal DestructorDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Body { get { throw null; } }

        public override ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override ParameterListSyntax ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken TildeToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new DestructorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new DestructorDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public new DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public DestructorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken) { throw null; }

        public new DestructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new DestructorDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public new DestructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public new DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken) { throw null; }
    }

    public abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
    {
        internal DirectiveTriviaSyntax() { }

        public SyntaxToken DirectiveNameToken { get { throw null; } }

        public abstract SyntaxToken EndOfDirectiveToken { get; }
        public abstract SyntaxToken HashToken { get; }
        public abstract bool IsActive { get; }

        public DirectiveTriviaSyntax? GetNextDirective(System.Func<DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public DirectiveTriviaSyntax? GetPreviousDirective(System.Func<DirectiveTriviaSyntax, bool>? predicate = null) { throw null; }

        public System.Collections.Generic.List<DirectiveTriviaSyntax> GetRelatedDirectives() { throw null; }

        public DirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public DirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }
    }

    public sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
    {
        internal DiscardDesignationSyntax() { }

        public SyntaxToken UnderscoreToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DiscardDesignationSyntax Update(SyntaxToken underscoreToken) { throw null; }

        public DiscardDesignationSyntax WithUnderscoreToken(SyntaxToken underscoreToken) { throw null; }
    }

    public sealed partial class DiscardPatternSyntax : PatternSyntax
    {
        internal DiscardPatternSyntax() { }

        public SyntaxToken UnderscoreToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DiscardPatternSyntax Update(SyntaxToken underscoreToken) { throw null; }

        public DiscardPatternSyntax WithUnderscoreToken(SyntaxToken underscoreToken) { throw null; }
    }

    public sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
    {
        internal DocumentationCommentTriviaSyntax() { }

        public SyntaxList<XmlNodeSyntax> Content { get { throw null; } }

        public SyntaxToken EndOfComment { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items) { throw null; }

        public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment) { throw null; }

        public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content) { throw null; }

        public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment) { throw null; }
    }

    public sealed partial class DoStatementSyntax : StatementSyntax
    {
        internal DoStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Condition { get { throw null; } }

        public SyntaxToken DoKeyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public SyntaxToken WhileKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new DoStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public DoStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken) { throw null; }

        public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken) { throw null; }

        public new DoStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public DoStatementSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword) { throw null; }

        public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public DoStatementSyntax WithStatement(StatementSyntax statement) { throw null; }

        public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword) { throw null; }
    }

    public sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
    {
        internal ElementAccessExpressionSyntax() { }

        public BracketedArgumentListSyntax ArgumentList { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList) { throw null; }

        public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList) { throw null; }

        public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
    {
        internal ElementBindingExpressionSyntax() { }

        public BracketedArgumentListSyntax ArgumentList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList) { throw null; }

        public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList) { throw null; }
    }

    public sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
    {
        internal ElifDirectiveTriviaSyntax() { }

        public override bool BranchTaken { get { throw null; } }

        public override ExpressionSyntax Condition { get { throw null; } }

        public override bool ConditionValue { get { throw null; } }

        public SyntaxToken ElifKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }

        public new ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }

        public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword) { throw null; }

        public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public ElifDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class ElseClauseSyntax : CSharpSyntaxNode
    {
        internal ElseClauseSyntax() { }

        public SyntaxToken ElseKeyword { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement) { throw null; }

        public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword) { throw null; }

        public ElseClauseSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
    {
        internal ElseDirectiveTriviaSyntax() { }

        public override bool BranchTaken { get { throw null; } }

        public SyntaxToken ElseKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken) { throw null; }

        public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }

        public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword) { throw null; }

        public new ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public ElseDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class EmptyStatementSyntax : StatementSyntax
    {
        internal EmptyStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new EmptyStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public EmptyStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken semicolonToken) { throw null; }

        public EmptyStatementSyntax Update(SyntaxToken semicolonToken) { throw null; }

        public new EmptyStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal EndIfDirectiveTriviaSyntax() { }

        public SyntaxToken EndIfKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword) { throw null; }

        public new EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal EndRegionDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken EndRegionKeyword { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword) { throw null; }

        public new EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
    {
        internal EnumDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BaseListSyntax? BaseList { get { throw null; } }

        public override SyntaxToken CloseBraceToken { get { throw null; } }

        public SyntaxToken EnumKeyword { get { throw null; } }

        public override SyntaxToken Identifier { get { throw null; } }

        public SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken OpenBraceToken { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new EnumDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new EnumDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items) { throw null; }

        public new EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public EnumDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new EnumDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new EnumDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public new EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword) { throw null; }

        public new EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList<EnumMemberDeclarationSyntax> members) { throw null; }

        public new EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public new EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
    {
        internal EnumMemberDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public EqualsValueClauseSyntax? EqualsValue { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new EnumMemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new EnumMemberDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue) { throw null; }

        public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue) { throw null; }

        public new EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax? equalsValue) { throw null; }

        public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new EnumMemberDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }
    }

    public sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
    {
        internal EqualsValueClauseSyntax() { }

        public SyntaxToken EqualsToken { get { throw null; } }

        public ExpressionSyntax Value { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value) { throw null; }

        public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public EqualsValueClauseSyntax WithValue(ExpressionSyntax value) { throw null; }
    }

    public sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal ErrorDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken ErrorKeyword { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword) { throw null; }

        public new ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal EventDeclarationSyntax() { }

        public override AccessorListSyntax? AccessorList { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken EventKeyword { get { throw null; } }

        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items) { throw null; }

        public new EventDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new EventDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken semicolonToken) { throw null; }

        public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList) { throw null; }

        public EventDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, SyntaxToken semicolonToken) { throw null; }

        public new EventDeclarationSyntax WithAccessorList(AccessorListSyntax? accessorList) { throw null; }

        public new EventDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword) { throw null; }

        public new EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public EventDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new EventDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
    {
        internal EventFieldDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override VariableDeclarationSyntax Declaration { get { throw null; } }

        public SyntaxToken EventKeyword { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new EventFieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new EventFieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public new EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public EventFieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public new EventFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration) { throw null; }

        public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword) { throw null; }

        public new EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
    {
        internal ExplicitInterfaceSpecifierSyntax() { }

        public SyntaxToken DotToken { get { throw null; } }

        public NameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken) { throw null; }

        public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken) { throw null; }

        public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name) { throw null; }
    }

    public sealed partial class ExpressionColonSyntax : BaseExpressionColonSyntax
    {
        internal ExpressionColonSyntax() { }

        public override SyntaxToken ColonToken { get { throw null; } }

        public override ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ExpressionColonSyntax Update(ExpressionSyntax expression, SyntaxToken colonToken) { throw null; }

        public new ExpressionColonSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public new ExpressionColonSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public abstract partial class ExpressionOrPatternSyntax : CSharpSyntaxNode
    {
        internal ExpressionOrPatternSyntax() { }
    }

    public sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        internal ExpressionStatementSyntax() { }

        public bool AllowsAnyExpression { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ExpressionStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public ExpressionStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public new ExpressionStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public abstract partial class ExpressionSyntax : ExpressionOrPatternSyntax
    {
        internal ExpressionSyntax() { }
    }

    public sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
    {
        internal ExternAliasDirectiveSyntax() { }

        public SyntaxToken AliasKeyword { get { throw null; } }

        public SyntaxToken ExternKeyword { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken) { throw null; }

        public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword) { throw null; }

        public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword) { throw null; }

        public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
    {
        internal FieldDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override VariableDeclarationSyntax Declaration { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new FieldDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new FieldDeclarationSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public new FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public FieldDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public new FieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration) { throw null; }

        public new FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class FileScopedNamespaceDeclarationSyntax : BaseNamespaceDeclarationSyntax
    {
        internal FileScopedNamespaceDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxList<ExternAliasDirectiveSyntax> Externs { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override NameSyntax Name { get { throw null; } }

        public override SyntaxToken NamespaceKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override SyntaxList<UsingDirectiveSyntax> Usings { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new FileScopedNamespaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items) { throw null; }

        public FileScopedNamespaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken semicolonToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithName(NameSyntax name) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword) { throw null; }

        public FileScopedNamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new FileScopedNamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings) { throw null; }
    }

    public sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
    {
        internal FinallyClauseSyntax() { }

        public BlockSyntax Block { get { throw null; } }

        public SyntaxToken FinallyKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FinallyClauseSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block) { throw null; }

        public FinallyClauseSyntax WithBlock(BlockSyntax block) { throw null; }

        public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword) { throw null; }
    }

    public sealed partial class FixedStatementSyntax : StatementSyntax
    {
        internal FixedStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public VariableDeclarationSyntax Declaration { get { throw null; } }

        public SyntaxToken FixedKeyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new FixedStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public FixedStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public FixedStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new FixedStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration) { throw null; }

        public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword) { throw null; }

        public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public FixedStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class ForEachStatementSyntax : CommonForEachStatementSyntax
    {
        internal ForEachStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxToken AwaitKeyword { get { throw null; } }

        public override SyntaxToken CloseParenToken { get { throw null; } }

        public override ExpressionSyntax Expression { get { throw null; } }

        public override SyntaxToken ForEachKeyword { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxToken InKeyword { get { throw null; } }

        public override SyntaxToken OpenParenToken { get { throw null; } }

        public override StatementSyntax Statement { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ForEachStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ForEachStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public ForEachStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new ForEachStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ForEachStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public new ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public new ForEachStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public new ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword) { throw null; }

        public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword) { throw null; }

        public new ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public new ForEachStatementSyntax WithStatement(StatementSyntax statement) { throw null; }

        public ForEachStatementSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class ForEachVariableStatementSyntax : CommonForEachStatementSyntax
    {
        internal ForEachVariableStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxToken AwaitKeyword { get { throw null; } }

        public override SyntaxToken CloseParenToken { get { throw null; } }

        public override ExpressionSyntax Expression { get { throw null; } }

        public override SyntaxToken ForEachKeyword { get { throw null; } }

        public override SyntaxToken InKeyword { get { throw null; } }

        public override SyntaxToken OpenParenToken { get { throw null; } }

        public override StatementSyntax Statement { get { throw null; } }

        public ExpressionSyntax Variable { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ForEachVariableStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ForEachVariableStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public ForEachVariableStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public ForEachVariableStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new ForEachVariableStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ForEachVariableStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public new ForEachVariableStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public new ForEachVariableStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public new ForEachVariableStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword) { throw null; }

        public new ForEachVariableStatementSyntax WithInKeyword(SyntaxToken inKeyword) { throw null; }

        public new ForEachVariableStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public new ForEachVariableStatementSyntax WithStatement(StatementSyntax statement) { throw null; }

        public ForEachVariableStatementSyntax WithVariable(ExpressionSyntax variable) { throw null; }
    }

    public sealed partial class ForStatementSyntax : StatementSyntax
    {
        internal ForStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax? Condition { get { throw null; } }

        public VariableDeclarationSyntax? Declaration { get { throw null; } }

        public SyntaxToken FirstSemicolonToken { get { throw null; } }

        public SyntaxToken ForKeyword { get { throw null; } }

        public SeparatedSyntaxList<ExpressionSyntax> Incrementors { get { throw null; } }

        public SeparatedSyntaxList<ExpressionSyntax> Initializers { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SyntaxToken SecondSemicolonToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ForStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ForStatementSyntax AddIncrementors(params ExpressionSyntax[] items) { throw null; }

        public ForStatementSyntax AddInitializers(params ExpressionSyntax[] items) { throw null; }

        public ForStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new ForStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ForStatementSyntax WithCondition(ExpressionSyntax? condition) { throw null; }

        public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax? declaration) { throw null; }

        public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken) { throw null; }

        public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword) { throw null; }

        public ForStatementSyntax WithIncrementors(SeparatedSyntaxList<ExpressionSyntax> incrementors) { throw null; }

        public ForStatementSyntax WithInitializers(SeparatedSyntaxList<ExpressionSyntax> initializers) { throw null; }

        public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken) { throw null; }

        public ForStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class FromClauseSyntax : QueryClauseSyntax
    {
        internal FromClauseSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken FromKeyword { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken InKeyword { get { throw null; } }

        public TypeSyntax? Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression) { throw null; }

        public FromClauseSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword) { throw null; }

        public FromClauseSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword) { throw null; }

        public FromClauseSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public sealed partial class FunctionPointerCallingConventionSyntax : CSharpSyntaxNode
    {
        internal FunctionPointerCallingConventionSyntax() { }

        public SyntaxToken ManagedOrUnmanagedKeyword { get { throw null; } }

        public FunctionPointerUnmanagedCallingConventionListSyntax? UnmanagedCallingConventionList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FunctionPointerCallingConventionSyntax AddUnmanagedCallingConventionListCallingConventions(params FunctionPointerUnmanagedCallingConventionSyntax[] items) { throw null; }

        public FunctionPointerCallingConventionSyntax Update(SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }

        public FunctionPointerCallingConventionSyntax WithManagedOrUnmanagedKeyword(SyntaxToken managedOrUnmanagedKeyword) { throw null; }

        public FunctionPointerCallingConventionSyntax WithUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList) { throw null; }
    }

    public sealed partial class FunctionPointerParameterListSyntax : CSharpSyntaxNode
    {
        internal FunctionPointerParameterListSyntax() { }

        public SyntaxToken GreaterThanToken { get { throw null; } }

        public SyntaxToken LessThanToken { get { throw null; } }

        public SeparatedSyntaxList<FunctionPointerParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FunctionPointerParameterListSyntax AddParameters(params FunctionPointerParameterSyntax[] items) { throw null; }

        public FunctionPointerParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<FunctionPointerParameterSyntax> parameters, SyntaxToken greaterThanToken) { throw null; }

        public FunctionPointerParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) { throw null; }

        public FunctionPointerParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken) { throw null; }

        public FunctionPointerParameterListSyntax WithParameters(SeparatedSyntaxList<FunctionPointerParameterSyntax> parameters) { throw null; }
    }

    public sealed partial class FunctionPointerParameterSyntax : BaseParameterSyntax
    {
        internal FunctionPointerParameterSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new FunctionPointerParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new FunctionPointerParameterSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public FunctionPointerParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type) { throw null; }

        public new FunctionPointerParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new FunctionPointerParameterSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new FunctionPointerParameterSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class FunctionPointerTypeSyntax : TypeSyntax
    {
        internal FunctionPointerTypeSyntax() { }

        public SyntaxToken AsteriskToken { get { throw null; } }

        public FunctionPointerCallingConventionSyntax? CallingConvention { get { throw null; } }

        public SyntaxToken DelegateKeyword { get { throw null; } }

        public FunctionPointerParameterListSyntax ParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FunctionPointerTypeSyntax AddParameterListParameters(params FunctionPointerParameterSyntax[] items) { throw null; }

        public FunctionPointerTypeSyntax Update(SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList) { throw null; }

        public FunctionPointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken) { throw null; }

        public FunctionPointerTypeSyntax WithCallingConvention(FunctionPointerCallingConventionSyntax? callingConvention) { throw null; }

        public FunctionPointerTypeSyntax WithDelegateKeyword(SyntaxToken delegateKeyword) { throw null; }

        public FunctionPointerTypeSyntax WithParameterList(FunctionPointerParameterListSyntax parameterList) { throw null; }
    }

    public sealed partial class FunctionPointerUnmanagedCallingConventionListSyntax : CSharpSyntaxNode
    {
        internal FunctionPointerUnmanagedCallingConventionListSyntax() { }

        public SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> CallingConventions { get { throw null; } }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FunctionPointerUnmanagedCallingConventionListSyntax AddCallingConventions(params FunctionPointerUnmanagedCallingConventionSyntax[] items) { throw null; }

        public FunctionPointerUnmanagedCallingConventionListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, SyntaxToken closeBracketToken) { throw null; }

        public FunctionPointerUnmanagedCallingConventionListSyntax WithCallingConventions(SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> callingConventions) { throw null; }

        public FunctionPointerUnmanagedCallingConventionListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public FunctionPointerUnmanagedCallingConventionListSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }
    }

    public sealed partial class FunctionPointerUnmanagedCallingConventionSyntax : CSharpSyntaxNode
    {
        internal FunctionPointerUnmanagedCallingConventionSyntax() { }

        public SyntaxToken Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public FunctionPointerUnmanagedCallingConventionSyntax Update(SyntaxToken name) { throw null; }

        public FunctionPointerUnmanagedCallingConventionSyntax WithName(SyntaxToken name) { throw null; }
    }

    public sealed partial class GenericNameSyntax : SimpleNameSyntax
    {
        internal GenericNameSyntax() { }

        public override SyntaxToken Identifier { get { throw null; } }

        public bool IsUnboundGenericName { get { throw null; } }

        public TypeArgumentListSyntax TypeArgumentList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items) { throw null; }

        public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList) { throw null; }

        public new GenericNameSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList) { throw null; }
    }

    public sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
    {
        internal GlobalStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new GlobalStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new GlobalStatementSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public GlobalStatementSyntax Update(StatementSyntax statement) { throw null; }

        public GlobalStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, StatementSyntax statement) { throw null; }

        public new GlobalStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new GlobalStatementSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public GlobalStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class GotoStatementSyntax : StatementSyntax
    {
        internal GotoStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CaseOrDefaultKeyword { get { throw null; } }

        public ExpressionSyntax? Expression { get { throw null; } }

        public SyntaxToken GotoKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new GotoStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public GotoStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public new GotoStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword) { throw null; }

        public GotoStatementSyntax WithExpression(ExpressionSyntax? expression) { throw null; }

        public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword) { throw null; }

        public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
    {
        internal GroupClauseSyntax() { }

        public ExpressionSyntax ByExpression { get { throw null; } }

        public SyntaxToken ByKeyword { get { throw null; } }

        public ExpressionSyntax GroupExpression { get { throw null; } }

        public SyntaxToken GroupKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression) { throw null; }

        public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression) { throw null; }

        public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword) { throw null; }

        public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression) { throw null; }

        public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword) { throw null; }
    }

    public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {
        internal IdentifierNameSyntax() { }

        public override SyntaxToken Identifier { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public IdentifierNameSyntax Update(SyntaxToken identifier) { throw null; }

        public new IdentifierNameSyntax WithIdentifier(SyntaxToken identifier) { throw null; }
    }

    public sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
    {
        internal IfDirectiveTriviaSyntax() { }

        public override bool BranchTaken { get { throw null; } }

        public override ExpressionSyntax Condition { get { throw null; } }

        public override bool ConditionValue { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public SyntaxToken IfKeyword { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue) { throw null; }

        public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken) { throw null; }

        public new IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue) { throw null; }

        public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword) { throw null; }

        public IfDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class IfStatementSyntax : StatementSyntax
    {
        internal IfStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Condition { get { throw null; } }

        public ElseClauseSyntax? Else { get { throw null; } }

        public SyntaxToken IfKeyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new IfStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public IfStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else) { throw null; }

        public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else) { throw null; }

        public new IfStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public IfStatementSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public IfStatementSyntax WithElse(ElseClauseSyntax? @else) { throw null; }

        public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword) { throw null; }

        public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public IfStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal ImplicitArrayCreationExpressionSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public SyntaxTokenList Commas { get { throw null; } }

        public InitializerExpressionSyntax Initializer { get { throw null; } }

        public SyntaxToken NewKeyword { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items) { throw null; }

        public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items) { throw null; }

        public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer) { throw null; }

        public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas) { throw null; }

        public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer) { throw null; }

        public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }

        public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }
    }

    public sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
    {
        internal ImplicitElementAccessSyntax() { }

        public BracketedArgumentListSyntax ArgumentList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList) { throw null; }

        public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList) { throw null; }
    }

    public sealed partial class ImplicitObjectCreationExpressionSyntax : BaseObjectCreationExpressionSyntax
    {
        internal ImplicitObjectCreationExpressionSyntax() { }

        public override ArgumentListSyntax ArgumentList { get { throw null; } }

        public override InitializerExpressionSyntax? Initializer { get { throw null; } }

        public override SyntaxToken NewKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ImplicitObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ImplicitObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer) { throw null; }

        public new ImplicitObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList) { throw null; }

        public new ImplicitObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax? initializer) { throw null; }

        public new ImplicitObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }
    }

    public sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal ImplicitStackAllocArrayCreationExpressionSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public InitializerExpressionSyntax Initializer { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public SyntaxToken StackAllocKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items) { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer) { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer) { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public ImplicitStackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword) { throw null; }
    }

    public sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
    {
        internal IncompleteMemberSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public TypeSyntax? Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new IncompleteMemberSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public IncompleteMemberSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax? type) { throw null; }

        public new IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public IncompleteMemberSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal IndexerDeclarationSyntax() { }

        public override AccessorListSyntax? AccessorList { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public BracketedParameterListSyntax ParameterList { get { throw null; } }

        [System.Obsolete("This member is obsolete.", true)]
        public SyntaxToken Semicolon { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken ThisKeyword { get { throw null; } }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items) { throw null; }

        public new IndexerDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public IndexerDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public new IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax? accessorList) { throw null; }

        public new IndexerDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public new IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList) { throw null; }

        [System.Obsolete("This member is obsolete.", true)]
        public IndexerDeclarationSyntax WithSemicolon(SyntaxToken semicolon) { throw null; }

        public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword) { throw null; }

        public new IndexerDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
    {
        internal IndexerMemberCrefSyntax() { }

        public CrefBracketedParameterListSyntax? Parameters { get { throw null; } }

        public SyntaxToken ThisKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items) { throw null; }

        public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters) { throw null; }

        public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax? parameters) { throw null; }

        public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword) { throw null; }
    }

    public sealed partial class InitializerExpressionSyntax : ExpressionSyntax
    {
        internal InitializerExpressionSyntax() { }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SeparatedSyntaxList<ExpressionSyntax> Expressions { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items) { throw null; }

        public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken) { throw null; }

        public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions) { throw null; }

        public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }
    }

    public abstract partial class InstanceExpressionSyntax : ExpressionSyntax
    {
        internal InstanceExpressionSyntax() { }
    }

    public sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
    {
        internal InterfaceDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BaseListSyntax? BaseList { get { throw null; } }

        public override SyntaxToken CloseBraceToken { get { throw null; } }

        public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public override SyntaxToken Identifier { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken OpenBraceToken { get { throw null; } }

        public override ParameterListSyntax? ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new InterfaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public new InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public InterfaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new InterfaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new InterfaceDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public new InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public new InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public new InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public new InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public new InterfaceDeclarationSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }

        public new InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
    {
        internal InterpolatedStringContentSyntax() { }
    }

    public sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
    {
        internal InterpolatedStringExpressionSyntax() { }

        public SyntaxList<InterpolatedStringContentSyntax> Contents { get { throw null; } }

        public SyntaxToken StringEndToken { get { throw null; } }

        public SyntaxToken StringStartToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items) { throw null; }

        public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken) { throw null; }

        public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents) { throw null; }

        public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken) { throw null; }

        public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken) { throw null; }
    }

    public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {
        internal InterpolatedStringTextSyntax() { }

        public SyntaxToken TextToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken) { throw null; }

        public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken) { throw null; }
    }

    public sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
    {
        internal InterpolationAlignmentClauseSyntax() { }

        public SyntaxToken CommaToken { get { throw null; } }

        public ExpressionSyntax Value { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value) { throw null; }

        public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken) { throw null; }

        public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value) { throw null; }
    }

    public sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
    {
        internal InterpolationFormatClauseSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public SyntaxToken FormatStringToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken) { throw null; }

        public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken) { throw null; }
    }

    public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        internal InterpolationSyntax() { }

        public InterpolationAlignmentClauseSyntax? AlignmentClause { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public InterpolationFormatClauseSyntax? FormatClause { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken) { throw null; }

        public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax? alignmentClause) { throw null; }

        public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public InterpolationSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax? formatClause) { throw null; }

        public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }
    }

    public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
    {
        internal InvocationExpressionSyntax() { }

        public ArgumentListSyntax ArgumentList { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList) { throw null; }

        public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList) { throw null; }

        public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
    {
        internal IsPatternExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken IsKeyword { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern) { throw null; }

        public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword) { throw null; }

        public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern) { throw null; }
    }

    public sealed partial class JoinClauseSyntax : QueryClauseSyntax
    {
        internal JoinClauseSyntax() { }

        public SyntaxToken EqualsKeyword { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public ExpressionSyntax InExpression { get { throw null; } }

        public SyntaxToken InKeyword { get { throw null; } }

        public JoinIntoClauseSyntax? Into { get { throw null; } }

        public SyntaxToken JoinKeyword { get { throw null; } }

        public ExpressionSyntax LeftExpression { get { throw null; } }

        public SyntaxToken OnKeyword { get { throw null; } }

        public ExpressionSyntax RightExpression { get { throw null; } }

        public TypeSyntax? Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into) { throw null; }

        public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword) { throw null; }

        public JoinClauseSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression) { throw null; }

        public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword) { throw null; }

        public JoinClauseSyntax WithInto(JoinIntoClauseSyntax? into) { throw null; }

        public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword) { throw null; }

        public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression) { throw null; }

        public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword) { throw null; }

        public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression) { throw null; }

        public JoinClauseSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
    {
        internal JoinIntoClauseSyntax() { }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken IntoKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier) { throw null; }

        public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword) { throw null; }
    }

    public sealed partial class LabeledStatementSyntax : StatementSyntax
    {
        internal LabeledStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken ColonToken { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new LabeledStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public LabeledStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement) { throw null; }

        public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement) { throw null; }

        public new LabeledStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public LabeledStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
    {
        internal LambdaExpressionSyntax() { }

        public abstract SyntaxToken ArrowToken { get; }
        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

        public LambdaExpressionSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new AnonymousFunctionExpressionSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new AnonymousFunctionExpressionSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public new LambdaExpressionSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public LambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken) { throw null; }

        public new LambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) { throw null; }

        public LambdaExpressionSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new LambdaExpressionSyntax WithBlock(BlockSyntax? block) { throw null; }

        public new LambdaExpressionSyntax WithBody(CSharpSyntaxNode body) { throw null; }

        public new LambdaExpressionSyntax WithExpressionBody(ExpressionSyntax? expressionBody) { throw null; }

        public new LambdaExpressionSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }
    }

    public sealed partial class LetClauseSyntax : QueryClauseSyntax
    {
        internal LetClauseSyntax() { }

        public SyntaxToken EqualsToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken LetKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression) { throw null; }

        public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public LetClauseSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public LetClauseSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword) { throw null; }
    }

    public sealed partial class LineDirectivePositionSyntax : CSharpSyntaxNode
    {
        internal LineDirectivePositionSyntax() { }

        public SyntaxToken Character { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken CommaToken { get { throw null; } }

        public SyntaxToken Line { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LineDirectivePositionSyntax Update(SyntaxToken openParenToken, SyntaxToken line, SyntaxToken commaToken, SyntaxToken character, SyntaxToken closeParenToken) { throw null; }

        public LineDirectivePositionSyntax WithCharacter(SyntaxToken character) { throw null; }

        public LineDirectivePositionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public LineDirectivePositionSyntax WithCommaToken(SyntaxToken commaToken) { throw null; }

        public LineDirectivePositionSyntax WithLine(SyntaxToken line) { throw null; }

        public LineDirectivePositionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class LineDirectiveTriviaSyntax : LineOrSpanDirectiveTriviaSyntax
    {
        internal LineDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken File { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken Line { get { throw null; } }

        public override SyntaxToken LineKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new LineDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public new LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public LineDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public LineDirectiveTriviaSyntax WithLine(SyntaxToken line) { throw null; }

        public new LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword) { throw null; }
    }

    public abstract partial class LineOrSpanDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal LineOrSpanDirectiveTriviaSyntax() { }

        public abstract SyntaxToken File { get; }
        public abstract SyntaxToken LineKeyword { get; }

        public new LineOrSpanDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public LineOrSpanDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public new LineOrSpanDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public LineOrSpanDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword) { throw null; }
    }

    public sealed partial class LineSpanDirectiveTriviaSyntax : LineOrSpanDirectiveTriviaSyntax
    {
        internal LineSpanDirectiveTriviaSyntax() { }

        public SyntaxToken CharacterOffset { get { throw null; } }

        public LineDirectivePositionSyntax End { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken File { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override SyntaxToken LineKeyword { get { throw null; } }

        public SyntaxToken MinusToken { get { throw null; } }

        public LineDirectivePositionSyntax Start { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LineSpanDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, LineDirectivePositionSyntax start, SyntaxToken minusToken, LineDirectivePositionSyntax end, SyntaxToken characterOffset, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public LineSpanDirectiveTriviaSyntax WithCharacterOffset(SyntaxToken characterOffset) { throw null; }

        public LineSpanDirectiveTriviaSyntax WithEnd(LineDirectivePositionSyntax end) { throw null; }

        public new LineSpanDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new LineSpanDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public new LineSpanDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public LineSpanDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public new LineSpanDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword) { throw null; }

        public LineSpanDirectiveTriviaSyntax WithMinusToken(SyntaxToken minusToken) { throw null; }

        public LineSpanDirectiveTriviaSyntax WithStart(LineDirectivePositionSyntax start) { throw null; }
    }

    public sealed partial class ListPatternSyntax : PatternSyntax
    {
        internal ListPatternSyntax() { }

        public SyntaxToken CloseBracketToken { get { throw null; } }

        public VariableDesignationSyntax? Designation { get { throw null; } }

        public SyntaxToken OpenBracketToken { get { throw null; } }

        public SeparatedSyntaxList<PatternSyntax> Patterns { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ListPatternSyntax AddPatterns(params PatternSyntax[] items) { throw null; }

        public ListPatternSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<PatternSyntax> patterns, SyntaxToken closeBracketToken, VariableDesignationSyntax? designation) { throw null; }

        public ListPatternSyntax WithCloseBracketToken(SyntaxToken closeBracketToken) { throw null; }

        public ListPatternSyntax WithDesignation(VariableDesignationSyntax? designation) { throw null; }

        public ListPatternSyntax WithOpenBracketToken(SyntaxToken openBracketToken) { throw null; }

        public ListPatternSyntax WithPatterns(SeparatedSyntaxList<PatternSyntax> patterns) { throw null; }
    }

    public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {
        internal LiteralExpressionSyntax() { }

        public SyntaxToken Token { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LiteralExpressionSyntax Update(SyntaxToken token) { throw null; }

        public LiteralExpressionSyntax WithToken(SyntaxToken token) { throw null; }
    }

    public sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal LoadDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken File { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken LoadKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public new LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public LoadDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword) { throw null; }
    }

    public sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
    {
        internal LocalDeclarationStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken AwaitKeyword { get { throw null; } }

        public VariableDeclarationSyntax Declaration { get { throw null; } }

        public bool IsConst { get { throw null; } }

        public SyntaxTokenList Modifiers { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken UsingKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new LocalDeclarationStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public LocalDeclarationStatementSyntax AddDeclarationVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public LocalDeclarationStatementSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public LocalDeclarationStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public LocalDeclarationStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken) { throw null; }

        public new LocalDeclarationStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public LocalDeclarationStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration) { throw null; }

        public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public LocalDeclarationStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword) { throw null; }
    }

    public sealed partial class LocalFunctionStatementSyntax : StatementSyntax
    {
        internal LocalFunctionStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public BlockSyntax? Body { get { throw null; } }

        public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxTokenList Modifiers { get { throw null; } }

        public ParameterListSyntax ParameterList { get { throw null; } }

        public TypeSyntax ReturnType { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new LocalFunctionStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public LocalFunctionStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken) { throw null; }

        public new LocalFunctionStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public LocalFunctionStatementSyntax WithBody(BlockSyntax? body) { throw null; }

        public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType) { throw null; }

        public LocalFunctionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class LockStatementSyntax : StatementSyntax
    {
        internal LockStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken LockKeyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new LockStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public LockStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new LockStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public LockStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword) { throw null; }

        public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public LockStatementSyntax WithStatement(StatementSyntax statement) { throw null; }
    }

    public sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
    {
        internal MakeRefExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
    {
        internal MemberAccessExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SimpleNameSyntax Name { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name) { throw null; }

        public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name) { throw null; }

        public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }
    }

    public sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
    {
        internal MemberBindingExpressionSyntax() { }

        public SimpleNameSyntax Name { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name) { throw null; }

        public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name) { throw null; }

        public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }
    }

    public abstract partial class MemberCrefSyntax : CrefSyntax
    {
        internal MemberCrefSyntax() { }
    }

    public abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
    {
        internal MemberDeclarationSyntax() { }

        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }
        public abstract SyntaxTokenList Modifiers { get; }

        public MemberDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public MemberDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public MemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public MemberDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }
    }

    public sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal MethodDeclarationSyntax() { }

        public int Arity { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Body { get { throw null; } }

        public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public override ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override ParameterListSyntax ParameterList { get { throw null; } }

        public TypeSyntax ReturnType { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new MethodDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new MethodDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public MethodDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public new MethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new MethodDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public new MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType) { throw null; }

        public new MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class NameColonSyntax : BaseExpressionColonSyntax
    {
        internal NameColonSyntax() { }

        public override SyntaxToken ColonToken { get { throw null; } }

        public override ExpressionSyntax Expression { get { throw null; } }

        public IdentifierNameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken) { throw null; }

        public new NameColonSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public NameColonSyntax WithName(IdentifierNameSyntax name) { throw null; }
    }

    public sealed partial class NameEqualsSyntax : CSharpSyntaxNode
    {
        internal NameEqualsSyntax() { }

        public SyntaxToken EqualsToken { get { throw null; } }

        public IdentifierNameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken) { throw null; }

        public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public NameEqualsSyntax WithName(IdentifierNameSyntax name) { throw null; }
    }

    public sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
    {
        internal NameMemberCrefSyntax() { }

        public TypeSyntax Name { get { throw null; } }

        public CrefParameterListSyntax? Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items) { throw null; }

        public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax? parameters) { throw null; }

        public NameMemberCrefSyntax WithName(TypeSyntax name) { throw null; }

        public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) { throw null; }
    }

    public sealed partial class NamespaceDeclarationSyntax : BaseNamespaceDeclarationSyntax
    {
        internal NamespaceDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public override SyntaxList<ExternAliasDirectiveSyntax> Externs { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override NameSyntax Name { get { throw null; } }

        public override SyntaxToken NamespaceKeyword { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override SyntaxList<UsingDirectiveSyntax> Usings { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new NamespaceDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items) { throw null; }

        public new NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new NamespaceDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new NamespaceDeclarationSyntax AddUsings(params UsingDirectiveSyntax[] items) { throw null; }

        public NamespaceDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new NamespaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public new NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs) { throw null; }

        public new NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new NamespaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new NamespaceDeclarationSyntax WithName(NameSyntax name) { throw null; }

        public new NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword) { throw null; }

        public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new NamespaceDeclarationSyntax WithUsings(SyntaxList<UsingDirectiveSyntax> usings) { throw null; }
    }

    public abstract partial class NameSyntax : TypeSyntax
    {
        internal NameSyntax() { }

        public int Arity { get { throw null; } }
    }

    public sealed partial class NullableDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal NullableDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken NullableKeyword { get { throw null; } }

        public SyntaxToken SettingToken { get { throw null; } }

        public SyntaxToken TargetToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public NullableDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new NullableDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new NullableDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public NullableDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public NullableDirectiveTriviaSyntax WithNullableKeyword(SyntaxToken nullableKeyword) { throw null; }

        public NullableDirectiveTriviaSyntax WithSettingToken(SyntaxToken settingToken) { throw null; }

        public NullableDirectiveTriviaSyntax WithTargetToken(SyntaxToken targetToken) { throw null; }
    }

    public sealed partial class NullableTypeSyntax : TypeSyntax
    {
        internal NullableTypeSyntax() { }

        public TypeSyntax ElementType { get { throw null; } }

        public SyntaxToken QuestionToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken) { throw null; }

        public NullableTypeSyntax WithElementType(TypeSyntax elementType) { throw null; }

        public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken) { throw null; }
    }

    public sealed partial class ObjectCreationExpressionSyntax : BaseObjectCreationExpressionSyntax
    {
        internal ObjectCreationExpressionSyntax() { }

        public override ArgumentListSyntax? ArgumentList { get { throw null; } }

        public override InitializerExpressionSyntax? Initializer { get { throw null; } }

        public override SyntaxToken NewKeyword { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer) { throw null; }

        public new ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax? argumentList) { throw null; }

        public new ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax? initializer) { throw null; }

        public new ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword) { throw null; }

        public ObjectCreationExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
    {
        internal OmittedArraySizeExpressionSyntax() { }

        public SyntaxToken OmittedArraySizeExpressionToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken) { throw null; }

        public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken) { throw null; }
    }

    public sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
    {
        internal OmittedTypeArgumentSyntax() { }

        public SyntaxToken OmittedTypeArgumentToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken) { throw null; }

        public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken) { throw null; }
    }

    public sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal OperatorDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Body { get { throw null; } }

        public SyntaxToken CheckedKeyword { get { throw null; } }

        public ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public override ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public SyntaxToken OperatorKeyword { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override ParameterListSyntax ParameterList { get { throw null; } }

        public TypeSyntax ReturnType { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new OperatorDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new OperatorDeclarationSyntax AddBodyAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) { throw null; }

        public new OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public OperatorDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken semicolonToken) { throw null; }

        public new OperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new OperatorDeclarationSyntax WithBody(BlockSyntax? body) { throw null; }

        public OperatorDeclarationSyntax WithCheckedKeyword(SyntaxToken checkedKeyword) { throw null; }

        public OperatorDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public new OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public new OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) { throw null; }

        public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public new OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType) { throw null; }

        public new OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal OperatorMemberCrefSyntax() { }

        public SyntaxToken CheckedKeyword { get { throw null; } }

        public SyntaxToken OperatorKeyword { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public CrefParameterListSyntax? Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items) { throw null; }

        public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters) { throw null; }

        public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken checkedKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters) { throw null; }

        public OperatorMemberCrefSyntax WithCheckedKeyword(SyntaxToken checkedKeyword) { throw null; }

        public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword) { throw null; }

        public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax? parameters) { throw null; }
    }

    public sealed partial class OrderByClauseSyntax : QueryClauseSyntax
    {
        internal OrderByClauseSyntax() { }

        public SyntaxToken OrderByKeyword { get { throw null; } }

        public SeparatedSyntaxList<OrderingSyntax> Orderings { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items) { throw null; }

        public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings) { throw null; }

        public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword) { throw null; }

        public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings) { throw null; }
    }

    public sealed partial class OrderingSyntax : CSharpSyntaxNode
    {
        internal OrderingSyntax() { }

        public SyntaxToken AscendingOrDescendingKeyword { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword) { throw null; }

        public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword) { throw null; }

        public OrderingSyntax WithExpression(ExpressionSyntax expression) { throw null; }
    }

    public sealed partial class ParameterListSyntax : BaseParameterListSyntax
    {
        internal ParameterListSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override SeparatedSyntaxList<ParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ParameterListSyntax AddParameters(params ParameterSyntax[] items) { throw null; }

        public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken) { throw null; }

        public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public new ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) { throw null; }
    }

    public sealed partial class ParameterSyntax : BaseParameterSyntax
    {
        internal ParameterSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public EqualsValueClauseSyntax? Default { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override TypeSyntax? Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ParameterSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public ParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default) { throw null; }

        public new ParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ParameterSyntax WithDefault(EqualsValueClauseSyntax? @default) { throw null; }

        public ParameterSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new ParameterSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new ParameterSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        internal ParenthesizedExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
    {
        internal ParenthesizedLambdaExpressionSyntax() { }

        public override SyntaxToken ArrowToken { get { throw null; } }

        public override SyntaxToken AsyncKeyword { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Block { get { throw null; } }

        public override ExpressionSyntax? ExpressionBody { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public ParameterListSyntax ParameterList { get { throw null; } }

        public TypeSyntax? ReturnType { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ParenthesizedLambdaExpressionSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public ParenthesizedLambdaExpressionSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public ParenthesizedLambdaExpressionSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax? returnType, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body) { throw null; }

        public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public ParenthesizedLambdaExpressionSyntax Update(SyntaxTokenList modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithBlock(BlockSyntax? block) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithExpressionBody(ExpressionSyntax? expressionBody) { throw null; }

        public new ParenthesizedLambdaExpressionSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList) { throw null; }

        public ParenthesizedLambdaExpressionSyntax WithReturnType(TypeSyntax? returnType) { throw null; }
    }

    public sealed partial class ParenthesizedPatternSyntax : PatternSyntax
    {
        internal ParenthesizedPatternSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ParenthesizedPatternSyntax Update(SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedPatternSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedPatternSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public ParenthesizedPatternSyntax WithPattern(PatternSyntax pattern) { throw null; }
    }

    public sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
    {
        internal ParenthesizedVariableDesignationSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SeparatedSyntaxList<VariableDesignationSyntax> Variables { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ParenthesizedVariableDesignationSyntax AddVariables(params VariableDesignationSyntax[] items) { throw null; }

        public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedVariableDesignationSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public ParenthesizedVariableDesignationSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public ParenthesizedVariableDesignationSyntax WithVariables(SeparatedSyntaxList<VariableDesignationSyntax> variables) { throw null; }
    }

    public abstract partial class PatternSyntax : ExpressionOrPatternSyntax
    {
        internal PatternSyntax() { }
    }

    public sealed partial class PointerTypeSyntax : TypeSyntax
    {
        internal PointerTypeSyntax() { }

        public SyntaxToken AsteriskToken { get { throw null; } }

        public TypeSyntax ElementType { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken) { throw null; }

        public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken) { throw null; }

        public PointerTypeSyntax WithElementType(TypeSyntax elementType) { throw null; }
    }

    public sealed partial class PositionalPatternClauseSyntax : CSharpSyntaxNode
    {
        internal PositionalPatternClauseSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SeparatedSyntaxList<SubpatternSyntax> Subpatterns { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PositionalPatternClauseSyntax AddSubpatterns(params SubpatternSyntax[] items) { throw null; }

        public PositionalPatternClauseSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken) { throw null; }

        public PositionalPatternClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public PositionalPatternClauseSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public PositionalPatternClauseSyntax WithSubpatterns(SeparatedSyntaxList<SubpatternSyntax> subpatterns) { throw null; }
    }

    public sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
    {
        internal PostfixUnaryExpressionSyntax() { }

        public ExpressionSyntax Operand { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken) { throw null; }

        public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand) { throw null; }

        public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }
    }

    public sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal PragmaChecksumDirectiveTriviaSyntax() { }

        public SyntaxToken Bytes { get { throw null; } }

        public SyntaxToken ChecksumKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken File { get { throw null; } }

        public SyntaxToken Guid { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken PragmaKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword) { throw null; }

        public new PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid) { throw null; }

        public new PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword) { throw null; }
    }

    public sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal PragmaWarningDirectiveTriviaSyntax() { }

        public SyntaxToken DisableOrRestoreKeyword { get { throw null; } }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken PragmaKeyword { get { throw null; } }

        public SyntaxToken WarningKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword) { throw null; }

        public new PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes) { throw null; }

        public new PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword) { throw null; }

        public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword) { throw null; }
    }

    public sealed partial class PredefinedTypeSyntax : TypeSyntax
    {
        internal PredefinedTypeSyntax() { }

        public SyntaxToken Keyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PredefinedTypeSyntax Update(SyntaxToken keyword) { throw null; }

        public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword) { throw null; }
    }

    public sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
    {
        internal PrefixUnaryExpressionSyntax() { }

        public ExpressionSyntax Operand { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand) { throw null; }

        public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand) { throw null; }

        public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }
    }

    public sealed partial class PrimaryConstructorBaseTypeSyntax : BaseTypeSyntax
    {
        internal PrimaryConstructorBaseTypeSyntax() { }

        public ArgumentListSyntax ArgumentList { get { throw null; } }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PrimaryConstructorBaseTypeSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public PrimaryConstructorBaseTypeSyntax Update(TypeSyntax type, ArgumentListSyntax argumentList) { throw null; }

        public PrimaryConstructorBaseTypeSyntax WithArgumentList(ArgumentListSyntax argumentList) { throw null; }

        public new PrimaryConstructorBaseTypeSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal PropertyDeclarationSyntax() { }

        public override AccessorListSyntax? AccessorList { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get { throw null; } }

        public ArrowExpressionClauseSyntax? ExpressionBody { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public EqualsValueClauseSyntax? Initializer { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        [System.Obsolete("This member is obsolete.", true)]
        public SyntaxToken Semicolon { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items) { throw null; }

        public new PropertyDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public PropertyDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken semicolonToken) { throw null; }

        public new PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax? accessorList) { throw null; }

        public new PropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier) { throw null; }

        public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax? expressionBody) { throw null; }

        public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax? initializer) { throw null; }

        public new PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        [System.Obsolete("This member is obsolete.", true)]
        public PropertyDeclarationSyntax WithSemicolon(SyntaxToken semicolon) { throw null; }

        public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new PropertyDeclarationSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class PropertyPatternClauseSyntax : CSharpSyntaxNode
    {
        internal PropertyPatternClauseSyntax() { }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public SeparatedSyntaxList<SubpatternSyntax> Subpatterns { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public PropertyPatternClauseSyntax AddSubpatterns(params SubpatternSyntax[] items) { throw null; }

        public PropertyPatternClauseSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken) { throw null; }

        public PropertyPatternClauseSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public PropertyPatternClauseSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public PropertyPatternClauseSyntax WithSubpatterns(SeparatedSyntaxList<SubpatternSyntax> subpatterns) { throw null; }
    }

    public sealed partial class QualifiedCrefSyntax : CrefSyntax
    {
        internal QualifiedCrefSyntax() { }

        public TypeSyntax Container { get { throw null; } }

        public SyntaxToken DotToken { get { throw null; } }

        public MemberCrefSyntax Member { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member) { throw null; }

        public QualifiedCrefSyntax WithContainer(TypeSyntax container) { throw null; }

        public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken) { throw null; }

        public QualifiedCrefSyntax WithMember(MemberCrefSyntax member) { throw null; }
    }

    public sealed partial class QualifiedNameSyntax : NameSyntax
    {
        internal QualifiedNameSyntax() { }

        public SyntaxToken DotToken { get { throw null; } }

        public NameSyntax Left { get { throw null; } }

        public SimpleNameSyntax Right { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right) { throw null; }

        public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken) { throw null; }

        public QualifiedNameSyntax WithLeft(NameSyntax left) { throw null; }

        public QualifiedNameSyntax WithRight(SimpleNameSyntax right) { throw null; }
    }

    public sealed partial class QueryBodySyntax : CSharpSyntaxNode
    {
        internal QueryBodySyntax() { }

        public SyntaxList<QueryClauseSyntax> Clauses { get { throw null; } }

        public QueryContinuationSyntax? Continuation { get { throw null; } }

        public SelectOrGroupClauseSyntax SelectOrGroup { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items) { throw null; }

        public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation) { throw null; }

        public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses) { throw null; }

        public QueryBodySyntax WithContinuation(QueryContinuationSyntax? continuation) { throw null; }

        public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup) { throw null; }
    }

    public abstract partial class QueryClauseSyntax : CSharpSyntaxNode
    {
        internal QueryClauseSyntax() { }
    }

    public sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
    {
        internal QueryContinuationSyntax() { }

        public QueryBodySyntax Body { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken IntoKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items) { throw null; }

        public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body) { throw null; }

        public QueryContinuationSyntax WithBody(QueryBodySyntax body) { throw null; }

        public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword) { throw null; }
    }

    public sealed partial class QueryExpressionSyntax : ExpressionSyntax
    {
        internal QueryExpressionSyntax() { }

        public QueryBodySyntax Body { get { throw null; } }

        public FromClauseSyntax FromClause { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items) { throw null; }

        public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body) { throw null; }

        public QueryExpressionSyntax WithBody(QueryBodySyntax body) { throw null; }

        public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause) { throw null; }
    }

    public sealed partial class RangeExpressionSyntax : ExpressionSyntax
    {
        internal RangeExpressionSyntax() { }

        public ExpressionSyntax? LeftOperand { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public ExpressionSyntax? RightOperand { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RangeExpressionSyntax Update(ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand) { throw null; }

        public RangeExpressionSyntax WithLeftOperand(ExpressionSyntax? leftOperand) { throw null; }

        public RangeExpressionSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public RangeExpressionSyntax WithRightOperand(ExpressionSyntax? rightOperand) { throw null; }
    }

    public sealed partial class RecordDeclarationSyntax : TypeDeclarationSyntax
    {
        internal RecordDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BaseListSyntax? BaseList { get { throw null; } }

        public SyntaxToken ClassOrStructKeyword { get { throw null; } }

        public override SyntaxToken CloseBraceToken { get { throw null; } }

        public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public override SyntaxToken Identifier { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken OpenBraceToken { get { throw null; } }

        public override ParameterListSyntax? ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new RecordDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new RecordDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public new RecordDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new RecordDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new RecordDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new RecordDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public new RecordDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public RecordDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public RecordDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken classOrStructKeyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new RecordDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new RecordDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public RecordDeclarationSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword) { throw null; }

        public new RecordDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public new RecordDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public new RecordDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new RecordDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public new RecordDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new RecordDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new RecordDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public new RecordDeclarationSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }

        public new RecordDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new RecordDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class RecursivePatternSyntax : PatternSyntax
    {
        internal RecursivePatternSyntax() { }

        public VariableDesignationSyntax? Designation { get { throw null; } }

        public PositionalPatternClauseSyntax? PositionalPatternClause { get { throw null; } }

        public PropertyPatternClauseSyntax? PropertyPatternClause { get { throw null; } }

        public TypeSyntax? Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RecursivePatternSyntax AddPositionalPatternClauseSubpatterns(params SubpatternSyntax[] items) { throw null; }

        public RecursivePatternSyntax AddPropertyPatternClauseSubpatterns(params SubpatternSyntax[] items) { throw null; }

        public RecursivePatternSyntax Update(TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation) { throw null; }

        public RecursivePatternSyntax WithDesignation(VariableDesignationSyntax? designation) { throw null; }

        public RecursivePatternSyntax WithPositionalPatternClause(PositionalPatternClauseSyntax? positionalPatternClause) { throw null; }

        public RecursivePatternSyntax WithPropertyPatternClause(PropertyPatternClauseSyntax? propertyPatternClause) { throw null; }

        public RecursivePatternSyntax WithType(TypeSyntax? type) { throw null; }
    }

    public sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal ReferenceDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken File { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken ReferenceKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file) { throw null; }

        public new ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword) { throw null; }
    }

    public sealed partial class RefExpressionSyntax : ExpressionSyntax
    {
        internal RefExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken RefKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression) { throw null; }

        public RefExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public RefExpressionSyntax WithRefKeyword(SyntaxToken refKeyword) { throw null; }
    }

    public sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
    {
        internal RefTypeExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken) { throw null; }

        public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class RefTypeSyntax : TypeSyntax
    {
        internal RefTypeSyntax() { }

        public SyntaxToken ReadOnlyKeyword { get { throw null; } }

        public SyntaxToken RefKeyword { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RefTypeSyntax Update(SyntaxToken refKeyword, TypeSyntax type) { throw null; }

        public RefTypeSyntax Update(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type) { throw null; }

        public RefTypeSyntax WithReadOnlyKeyword(SyntaxToken readOnlyKeyword) { throw null; }

        public RefTypeSyntax WithRefKeyword(SyntaxToken refKeyword) { throw null; }

        public RefTypeSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class RefValueExpressionSyntax : ExpressionSyntax
    {
        internal RefValueExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken Comma { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public RefValueExpressionSyntax WithComma(SyntaxToken comma) { throw null; }

        public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public RefValueExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal RegionDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken RegionKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public RegionDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword) { throw null; }
    }

    public sealed partial class RelationalPatternSyntax : PatternSyntax
    {
        internal RelationalPatternSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken OperatorToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public RelationalPatternSyntax Update(SyntaxToken operatorToken, ExpressionSyntax expression) { throw null; }

        public RelationalPatternSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public RelationalPatternSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }
    }

    public sealed partial class ReturnStatementSyntax : StatementSyntax
    {
        internal ReturnStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public ExpressionSyntax? Expression { get { throw null; } }

        public SyntaxToken ReturnKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ReturnStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ReturnStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public new ReturnStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ReturnStatementSyntax WithExpression(ExpressionSyntax? expression) { throw null; }

        public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword) { throw null; }

        public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }
    }

    public sealed partial class ScopedTypeSyntax : TypeSyntax
    {
        internal ScopedTypeSyntax() { }

        public SyntaxToken ScopedKeyword { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ScopedTypeSyntax Update(SyntaxToken scopedKeyword, TypeSyntax type) { throw null; }

        public ScopedTypeSyntax WithScopedKeyword(SyntaxToken scopedKeyword) { throw null; }

        public ScopedTypeSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
    {
        internal SelectClauseSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken SelectKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression) { throw null; }

        public SelectClauseSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword) { throw null; }
    }

    public abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
    {
        internal SelectOrGroupClauseSyntax() { }
    }

    public sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal ShebangDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public SyntaxToken ExclamationToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken) { throw null; }

        public new ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }
    }

    public sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
    {
        internal SimpleBaseTypeSyntax() { }

        public override TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SimpleBaseTypeSyntax Update(TypeSyntax type) { throw null; }

        public new SimpleBaseTypeSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
    {
        internal SimpleLambdaExpressionSyntax() { }

        public override SyntaxToken ArrowToken { get { throw null; } }

        public override SyntaxToken AsyncKeyword { get { throw null; } }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BlockSyntax? Block { get { throw null; } }

        public override ExpressionSyntax? ExpressionBody { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public ParameterSyntax Parameter { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new SimpleLambdaExpressionSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new SimpleLambdaExpressionSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new SimpleLambdaExpressionSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public new SimpleLambdaExpressionSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public SimpleLambdaExpressionSyntax AddParameterModifiers(params SyntaxToken[] items) { throw null; }

        public SimpleLambdaExpressionSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body) { throw null; }

        public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public SimpleLambdaExpressionSyntax Update(SyntaxTokenList modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody) { throw null; }

        public new SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken) { throw null; }

        public new SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) { throw null; }

        public new SimpleLambdaExpressionSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new SimpleLambdaExpressionSyntax WithBlock(BlockSyntax? block) { throw null; }

        public new SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body) { throw null; }

        public new SimpleLambdaExpressionSyntax WithExpressionBody(ExpressionSyntax? expressionBody) { throw null; }

        public new SimpleLambdaExpressionSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter) { throw null; }
    }

    public abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax() { }

        public abstract SyntaxToken Identifier { get; }

        public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) { throw null; }
    }

    public sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
    {
        internal SingleVariableDesignationSyntax() { }

        public SyntaxToken Identifier { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SingleVariableDesignationSyntax Update(SyntaxToken identifier) { throw null; }

        public SingleVariableDesignationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }
    }

    public sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
    {
        internal SizeOfExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public SizeOfExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax, ISkippedTokensTriviaSyntax
    {
        internal SkippedTokensTriviaSyntax() { }

        public SyntaxTokenList Tokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items) { throw null; }

        public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens) { throw null; }

        public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens) { throw null; }
    }

    public sealed partial class SlicePatternSyntax : PatternSyntax
    {
        internal SlicePatternSyntax() { }

        public SyntaxToken DotDotToken { get { throw null; } }

        public PatternSyntax? Pattern { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SlicePatternSyntax Update(SyntaxToken dotDotToken, PatternSyntax? pattern) { throw null; }

        public SlicePatternSyntax WithDotDotToken(SyntaxToken dotDotToken) { throw null; }

        public SlicePatternSyntax WithPattern(PatternSyntax? pattern) { throw null; }
    }

    public sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal StackAllocArrayCreationExpressionSyntax() { }

        public InitializerExpressionSyntax? Initializer { get { throw null; } }

        public SyntaxToken StackAllocKeyword { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer) { throw null; }

        public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type) { throw null; }

        public StackAllocArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax? initializer) { throw null; }

        public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword) { throw null; }

        public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public abstract partial class StatementSyntax : CSharpSyntaxNode
    {
        internal StatementSyntax() { }

        public abstract SyntaxList<AttributeListSyntax> AttributeLists { get; }

        public StatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public StatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }
    }

    public sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
    {
        internal StructDeclarationSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public override BaseListSyntax? BaseList { get { throw null; } }

        public override SyntaxToken CloseBraceToken { get { throw null; } }

        public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { throw null; } }

        public override SyntaxToken Identifier { get { throw null; } }

        public override SyntaxToken Keyword { get { throw null; } }

        public override SyntaxList<MemberDeclarationSyntax> Members { get { throw null; } }

        public override SyntaxTokenList Modifiers { get { throw null; } }

        public override SyntaxToken OpenBraceToken { get { throw null; } }

        public override ParameterListSyntax? ParameterList { get { throw null; } }

        public override SyntaxToken SemicolonToken { get { throw null; } }

        public override TypeParameterListSyntax? TypeParameterList { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new StructDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new StructDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public new StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public new StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new StructDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public new StructDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public new StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public StructDeclarationSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken) { throw null; }

        public new StructDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new StructDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public new StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public new StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public new StructDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public new StructDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public new StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public new StructDeclarationSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }

        public new StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public new StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public abstract partial class StructuredTriviaSyntax : CSharpSyntaxNode, IStructuredTriviaSyntax
    {
        internal StructuredTriviaSyntax() { }

        public override SyntaxTrivia ParentTrivia { get { throw null; } }
    }

    public sealed partial class SubpatternSyntax : CSharpSyntaxNode
    {
        internal SubpatternSyntax() { }

        public BaseExpressionColonSyntax? ExpressionColon { get { throw null; } }

        public NameColonSyntax? NameColon { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SubpatternSyntax Update(BaseExpressionColonSyntax? expressionColon, PatternSyntax pattern) { throw null; }

        public SubpatternSyntax Update(NameColonSyntax? nameColon, PatternSyntax pattern) { throw null; }

        public SubpatternSyntax WithExpressionColon(BaseExpressionColonSyntax? expressionColon) { throw null; }

        public SubpatternSyntax WithNameColon(NameColonSyntax? nameColon) { throw null; }

        public SubpatternSyntax WithPattern(PatternSyntax pattern) { throw null; }
    }

    public sealed partial class SwitchExpressionArmSyntax : CSharpSyntaxNode
    {
        internal SwitchExpressionArmSyntax() { }

        public SyntaxToken EqualsGreaterThanToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public WhenClauseSyntax? WhenClause { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SwitchExpressionArmSyntax Update(PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression) { throw null; }

        public SwitchExpressionArmSyntax WithEqualsGreaterThanToken(SyntaxToken equalsGreaterThanToken) { throw null; }

        public SwitchExpressionArmSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public SwitchExpressionArmSyntax WithPattern(PatternSyntax pattern) { throw null; }

        public SwitchExpressionArmSyntax WithWhenClause(WhenClauseSyntax? whenClause) { throw null; }
    }

    public sealed partial class SwitchExpressionSyntax : ExpressionSyntax
    {
        internal SwitchExpressionSyntax() { }

        public SeparatedSyntaxList<SwitchExpressionArmSyntax> Arms { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public ExpressionSyntax GoverningExpression { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public SyntaxToken SwitchKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SwitchExpressionSyntax AddArms(params SwitchExpressionArmSyntax[] items) { throw null; }

        public SwitchExpressionSyntax Update(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken) { throw null; }

        public SwitchExpressionSyntax WithArms(SeparatedSyntaxList<SwitchExpressionArmSyntax> arms) { throw null; }

        public SwitchExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public SwitchExpressionSyntax WithGoverningExpression(ExpressionSyntax governingExpression) { throw null; }

        public SwitchExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public SwitchExpressionSyntax WithSwitchKeyword(SyntaxToken switchKeyword) { throw null; }
    }

    public abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
    {
        internal SwitchLabelSyntax() { }

        public abstract SyntaxToken ColonToken { get; }
        public abstract SyntaxToken Keyword { get; }

        public SwitchLabelSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public SwitchLabelSyntax WithKeyword(SyntaxToken keyword) { throw null; }
    }

    public sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
    {
        internal SwitchSectionSyntax() { }

        public SyntaxList<SwitchLabelSyntax> Labels { get { throw null; } }

        public SyntaxList<StatementSyntax> Statements { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items) { throw null; }

        public SwitchSectionSyntax AddStatements(params StatementSyntax[] items) { throw null; }

        public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements) { throw null; }

        public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels) { throw null; }

        public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements) { throw null; }
    }

    public sealed partial class SwitchStatementSyntax : StatementSyntax
    {
        internal SwitchStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseBraceToken { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken OpenBraceToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public SyntaxList<SwitchSectionSyntax> Sections { get { throw null; } }

        public SyntaxToken SwitchKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new SwitchStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items) { throw null; }

        public SwitchStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken) { throw null; }

        public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken) { throw null; }

        public new SwitchStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public SwitchStatementSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections) { throw null; }

        public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword) { throw null; }
    }

    public sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
    {
        internal ThisExpressionSyntax() { }

        public SyntaxToken Token { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ThisExpressionSyntax Update(SyntaxToken token) { throw null; }

        public ThisExpressionSyntax WithToken(SyntaxToken token) { throw null; }
    }

    public sealed partial class ThrowExpressionSyntax : ExpressionSyntax
    {
        internal ThrowExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public SyntaxToken ThrowKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression) { throw null; }

        public ThrowExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public ThrowExpressionSyntax WithThrowKeyword(SyntaxToken throwKeyword) { throw null; }
    }

    public sealed partial class ThrowStatementSyntax : StatementSyntax
    {
        internal ThrowStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public ExpressionSyntax? Expression { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken ThrowKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new ThrowStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public ThrowStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public new ThrowStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public ThrowStatementSyntax WithExpression(ExpressionSyntax? expression) { throw null; }

        public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword) { throw null; }
    }

    public sealed partial class TryStatementSyntax : StatementSyntax
    {
        internal TryStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public BlockSyntax Block { get { throw null; } }

        public SyntaxList<CatchClauseSyntax> Catches { get { throw null; } }

        public FinallyClauseSyntax? Finally { get { throw null; } }

        public SyntaxToken TryKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new TryStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public TryStatementSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items) { throw null; }

        public TryStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax? @finally) { throw null; }

        public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally) { throw null; }

        public new TryStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public TryStatementSyntax WithBlock(BlockSyntax block) { throw null; }

        public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches) { throw null; }

        public TryStatementSyntax WithFinally(FinallyClauseSyntax? @finally) { throw null; }

        public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword) { throw null; }
    }

    public sealed partial class TupleElementSyntax : CSharpSyntaxNode
    {
        internal TupleElementSyntax() { }

        public SyntaxToken Identifier { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier) { throw null; }

        public TupleElementSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public TupleElementSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class TupleExpressionSyntax : ExpressionSyntax
    {
        internal TupleExpressionSyntax() { }

        public SeparatedSyntaxList<ArgumentSyntax> Arguments { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items) { throw null; }

        public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken) { throw null; }

        public TupleExpressionSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) { throw null; }

        public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class TupleTypeSyntax : TypeSyntax
    {
        internal TupleTypeSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SeparatedSyntaxList<TupleElementSyntax> Elements { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TupleTypeSyntax AddElements(params TupleElementSyntax[] items) { throw null; }

        public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken) { throw null; }

        public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public TupleTypeSyntax WithElements(SeparatedSyntaxList<TupleElementSyntax> elements) { throw null; }

        public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }
    }

    public sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
    {
        internal TypeArgumentListSyntax() { }

        public SeparatedSyntaxList<TypeSyntax> Arguments { get { throw null; } }

        public SyntaxToken GreaterThanToken { get { throw null; } }

        public SyntaxToken LessThanToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items) { throw null; }

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken) { throw null; }

        public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments) { throw null; }

        public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) { throw null; }

        public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken) { throw null; }
    }

    public sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal TypeConstraintSyntax() { }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeConstraintSyntax Update(TypeSyntax type) { throw null; }

        public TypeConstraintSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class TypeCrefSyntax : CrefSyntax
    {
        internal TypeCrefSyntax() { }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeCrefSyntax Update(TypeSyntax type) { throw null; }

        public TypeCrefSyntax WithType(TypeSyntax type) { throw null; }
    }

    public abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
    {
        internal TypeDeclarationSyntax() { }

        public int Arity { get { throw null; } }

        public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
        public abstract SyntaxToken Keyword { get; }
        public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
        public abstract ParameterListSyntax? ParameterList { get; }
        public abstract TypeParameterListSyntax? TypeParameterList { get; }

        public new TypeDeclarationSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public new BaseTypeDeclarationSyntax AddBaseListTypes(params BaseTypeSyntax[] items) { throw null; }

        public TypeDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) { throw null; }

        public TypeDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) { throw null; }

        public new TypeDeclarationSyntax AddModifiers(params SyntaxToken[] items) { throw null; }

        public TypeDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) { throw null; }

        public TypeDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) { throw null; }

        public new TypeDeclarationSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public new TypeDeclarationSyntax WithBaseList(BaseListSyntax? baseList) { throw null; }

        public new TypeDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) { throw null; }

        public TypeDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) { throw null; }

        public new TypeDeclarationSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public TypeDeclarationSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public TypeDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) { throw null; }

        public new TypeDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) { throw null; }

        public new TypeDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) { throw null; }

        public TypeDeclarationSyntax WithParameterList(ParameterListSyntax? parameterList) { throw null; }

        public new TypeDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public TypeDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax? typeParameterList) { throw null; }
    }

    public sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
    {
        internal TypeOfExpressionSyntax() { }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public SyntaxToken Keyword { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken) { throw null; }

        public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword) { throw null; }

        public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public TypeOfExpressionSyntax WithType(TypeSyntax type) { throw null; }
    }

    public sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
    {
        internal TypeParameterConstraintClauseSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get { throw null; } }

        public IdentifierNameSyntax Name { get { throw null; } }

        public SyntaxToken WhereKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items) { throw null; }

        public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints) { throw null; }

        public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints) { throw null; }

        public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name) { throw null; }

        public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword) { throw null; }
    }

    public abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
    {
        internal TypeParameterConstraintSyntax() { }
    }

    public sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
    {
        internal TypeParameterListSyntax() { }

        public SyntaxToken GreaterThanToken { get { throw null; } }

        public SyntaxToken LessThanToken { get { throw null; } }

        public SeparatedSyntaxList<TypeParameterSyntax> Parameters { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items) { throw null; }

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken) { throw null; }

        public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) { throw null; }

        public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken) { throw null; }

        public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters) { throw null; }
    }

    public sealed partial class TypeParameterSyntax : CSharpSyntaxNode
    {
        internal TypeParameterSyntax() { }

        public SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public SyntaxToken VarianceKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypeParameterSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public TypeParameterSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier) { throw null; }

        public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public TypeParameterSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword) { throw null; }
    }

    public sealed partial class TypePatternSyntax : PatternSyntax
    {
        internal TypePatternSyntax() { }

        public TypeSyntax Type { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public TypePatternSyntax Update(TypeSyntax type) { throw null; }

        public TypePatternSyntax WithType(TypeSyntax type) { throw null; }
    }

    public abstract partial class TypeSyntax : ExpressionSyntax
    {
        internal TypeSyntax() { }

        public bool IsNint { get { throw null; } }

        public bool IsNotNull { get { throw null; } }

        public bool IsNuint { get { throw null; } }

        public bool IsUnmanaged { get { throw null; } }

        public bool IsVar { get { throw null; } }
    }

    public sealed partial class UnaryPatternSyntax : PatternSyntax
    {
        internal UnaryPatternSyntax() { }

        public SyntaxToken OperatorToken { get { throw null; } }

        public PatternSyntax Pattern { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public UnaryPatternSyntax Update(SyntaxToken operatorToken, PatternSyntax pattern) { throw null; }

        public UnaryPatternSyntax WithOperatorToken(SyntaxToken operatorToken) { throw null; }

        public UnaryPatternSyntax WithPattern(PatternSyntax pattern) { throw null; }
    }

    public sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal UndefDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken Name { get { throw null; } }

        public SyntaxToken UndefKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public UndefDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public UndefDirectiveTriviaSyntax WithName(SyntaxToken name) { throw null; }

        public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword) { throw null; }
    }

    public sealed partial class UnsafeStatementSyntax : StatementSyntax
    {
        internal UnsafeStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public BlockSyntax Block { get { throw null; } }

        public SyntaxToken UnsafeKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new UnsafeStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public UnsafeStatementSyntax AddBlockAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items) { throw null; }

        public UnsafeStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block) { throw null; }

        public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block) { throw null; }

        public new UnsafeStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public UnsafeStatementSyntax WithBlock(BlockSyntax block) { throw null; }

        public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword) { throw null; }
    }

    public sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
    {
        internal UsingDirectiveSyntax() { }

        public NameEqualsSyntax? Alias { get { throw null; } }

        public SyntaxToken GlobalKeyword { get { throw null; } }

        public NameSyntax? Name { get { throw null; } }

        public TypeSyntax NamespaceOrType { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken StaticKeyword { get { throw null; } }

        public SyntaxToken UnsafeKeyword { get { throw null; } }

        public SyntaxToken UsingKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken) { throw null; }

        public UsingDirectiveSyntax Update(SyntaxToken globalKeyword, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken) { throw null; }

        public UsingDirectiveSyntax Update(SyntaxToken globalKeyword, SyntaxToken usingKeyword, SyntaxToken staticKeyword, SyntaxToken unsafeKeyword, NameEqualsSyntax? alias, TypeSyntax namespaceOrType, SyntaxToken semicolonToken) { throw null; }

        public UsingDirectiveSyntax WithAlias(NameEqualsSyntax? alias) { throw null; }

        public UsingDirectiveSyntax WithGlobalKeyword(SyntaxToken globalKeyword) { throw null; }

        public UsingDirectiveSyntax WithName(NameSyntax name) { throw null; }

        public UsingDirectiveSyntax WithNamespaceOrType(TypeSyntax namespaceOrType) { throw null; }

        public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword) { throw null; }

        public UsingDirectiveSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword) { throw null; }

        public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword) { throw null; }
    }

    public sealed partial class UsingStatementSyntax : StatementSyntax
    {
        internal UsingStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken AwaitKeyword { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public VariableDeclarationSyntax? Declaration { get { throw null; } }

        public ExpressionSyntax? Expression { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public SyntaxToken UsingKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new UsingStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public UsingStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public UsingStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new UsingStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public UsingStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword) { throw null; }

        public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax? declaration) { throw null; }

        public UsingStatementSyntax WithExpression(ExpressionSyntax? expression) { throw null; }

        public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public UsingStatementSyntax WithStatement(StatementSyntax statement) { throw null; }

        public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword) { throw null; }
    }

    public sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
    {
        internal VariableDeclarationSyntax() { }

        public TypeSyntax Type { get { throw null; } }

        public SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public VariableDeclarationSyntax AddVariables(params VariableDeclaratorSyntax[] items) { throw null; }

        public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables) { throw null; }

        public VariableDeclarationSyntax WithType(TypeSyntax type) { throw null; }

        public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList<VariableDeclaratorSyntax> variables) { throw null; }
    }

    public sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
    {
        internal VariableDeclaratorSyntax() { }

        public BracketedArgumentListSyntax? ArgumentList { get { throw null; } }

        public SyntaxToken Identifier { get { throw null; } }

        public EqualsValueClauseSyntax? Initializer { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public VariableDeclaratorSyntax AddArgumentListArguments(params ArgumentSyntax[] items) { throw null; }

        public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer) { throw null; }

        public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax? argumentList) { throw null; }

        public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier) { throw null; }

        public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax? initializer) { throw null; }
    }

    public abstract partial class VariableDesignationSyntax : CSharpSyntaxNode
    {
        internal VariableDesignationSyntax() { }
    }

    public sealed partial class VarPatternSyntax : PatternSyntax
    {
        internal VarPatternSyntax() { }

        public VariableDesignationSyntax Designation { get { throw null; } }

        public SyntaxToken VarKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public VarPatternSyntax Update(SyntaxToken varKeyword, VariableDesignationSyntax designation) { throw null; }

        public VarPatternSyntax WithDesignation(VariableDesignationSyntax designation) { throw null; }

        public VarPatternSyntax WithVarKeyword(SyntaxToken varKeyword) { throw null; }
    }

    public sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal WarningDirectiveTriviaSyntax() { }

        public override SyntaxToken EndOfDirectiveToken { get { throw null; } }

        public override SyntaxToken HashToken { get { throw null; } }

        public override bool IsActive { get { throw null; } }

        public SyntaxToken WarningKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive) { throw null; }

        public new WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) { throw null; }

        public new WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) { throw null; }

        public WarningDirectiveTriviaSyntax WithIsActive(bool isActive) { throw null; }

        public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword) { throw null; }
    }

    public sealed partial class WhenClauseSyntax : CSharpSyntaxNode
    {
        internal WhenClauseSyntax() { }

        public ExpressionSyntax Condition { get { throw null; } }

        public SyntaxToken WhenKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition) { throw null; }

        public WhenClauseSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword) { throw null; }
    }

    public sealed partial class WhereClauseSyntax : QueryClauseSyntax
    {
        internal WhereClauseSyntax() { }

        public ExpressionSyntax Condition { get { throw null; } }

        public SyntaxToken WhereKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition) { throw null; }

        public WhereClauseSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword) { throw null; }
    }

    public sealed partial class WhileStatementSyntax : StatementSyntax
    {
        internal WhileStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public SyntaxToken CloseParenToken { get { throw null; } }

        public ExpressionSyntax Condition { get { throw null; } }

        public SyntaxToken OpenParenToken { get { throw null; } }

        public StatementSyntax Statement { get { throw null; } }

        public SyntaxToken WhileKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new WhileStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public WhileStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement) { throw null; }

        public new WhileStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken) { throw null; }

        public WhileStatementSyntax WithCondition(ExpressionSyntax condition) { throw null; }

        public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken) { throw null; }

        public WhileStatementSyntax WithStatement(StatementSyntax statement) { throw null; }

        public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword) { throw null; }
    }

    public sealed partial class WithExpressionSyntax : ExpressionSyntax
    {
        internal WithExpressionSyntax() { }

        public ExpressionSyntax Expression { get { throw null; } }

        public InitializerExpressionSyntax Initializer { get { throw null; } }

        public SyntaxToken WithKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public WithExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items) { throw null; }

        public WithExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer) { throw null; }

        public WithExpressionSyntax WithExpression(ExpressionSyntax expression) { throw null; }

        public WithExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer) { throw null; }

        public WithExpressionSyntax WithWithKeyword(SyntaxToken withKeyword) { throw null; }
    }

    public abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
    {
        internal XmlAttributeSyntax() { }

        public abstract SyntaxToken EndQuoteToken { get; }
        public abstract SyntaxToken EqualsToken { get; }
        public abstract XmlNameSyntax Name { get; }
        public abstract SyntaxToken StartQuoteToken { get; }

        public XmlAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) { throw null; }

        public XmlAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public XmlAttributeSyntax WithName(XmlNameSyntax name) { throw null; }

        public XmlAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) { throw null; }
    }

    public sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
    {
        internal XmlCDataSectionSyntax() { }

        public SyntaxToken EndCDataToken { get { throw null; } }

        public SyntaxToken StartCDataToken { get { throw null; } }

        public SyntaxTokenList TextTokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items) { throw null; }

        public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken) { throw null; }

        public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken) { throw null; }

        public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken) { throw null; }

        public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens) { throw null; }
    }

    public sealed partial class XmlCommentSyntax : XmlNodeSyntax
    {
        internal XmlCommentSyntax() { }

        public SyntaxToken LessThanExclamationMinusMinusToken { get { throw null; } }

        public SyntaxToken MinusMinusGreaterThanToken { get { throw null; } }

        public SyntaxTokenList TextTokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items) { throw null; }

        public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken) { throw null; }

        public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken) { throw null; }

        public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken) { throw null; }

        public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens) { throw null; }
    }

    public sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
    {
        internal XmlCrefAttributeSyntax() { }

        public CrefSyntax Cref { get { throw null; } }

        public override SyntaxToken EndQuoteToken { get { throw null; } }

        public override SyntaxToken EqualsToken { get { throw null; } }

        public override XmlNameSyntax Name { get { throw null; } }

        public override SyntaxToken StartQuoteToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken) { throw null; }

        public XmlCrefAttributeSyntax WithCref(CrefSyntax cref) { throw null; }

        public new XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) { throw null; }

        public new XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public new XmlCrefAttributeSyntax WithName(XmlNameSyntax name) { throw null; }

        public new XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) { throw null; }
    }

    public sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
    {
        internal XmlElementEndTagSyntax() { }

        public SyntaxToken GreaterThanToken { get { throw null; } }

        public SyntaxToken LessThanSlashToken { get { throw null; } }

        public XmlNameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken) { throw null; }

        public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) { throw null; }

        public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken) { throw null; }

        public XmlElementEndTagSyntax WithName(XmlNameSyntax name) { throw null; }
    }

    public sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
    {
        internal XmlElementStartTagSyntax() { }

        public SyntaxList<XmlAttributeSyntax> Attributes { get { throw null; } }

        public SyntaxToken GreaterThanToken { get { throw null; } }

        public SyntaxToken LessThanToken { get { throw null; } }

        public XmlNameSyntax Name { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items) { throw null; }

        public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken) { throw null; }

        public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes) { throw null; }

        public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken) { throw null; }

        public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken) { throw null; }

        public XmlElementStartTagSyntax WithName(XmlNameSyntax name) { throw null; }
    }

    public sealed partial class XmlElementSyntax : XmlNodeSyntax
    {
        internal XmlElementSyntax() { }

        public SyntaxList<XmlNodeSyntax> Content { get { throw null; } }

        public XmlElementEndTagSyntax EndTag { get { throw null; } }

        public XmlElementStartTagSyntax StartTag { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlElementSyntax AddContent(params XmlNodeSyntax[] items) { throw null; }

        public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items) { throw null; }

        public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag) { throw null; }

        public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content) { throw null; }

        public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag) { throw null; }

        public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag) { throw null; }
    }

    public sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
    {
        internal XmlEmptyElementSyntax() { }

        public SyntaxList<XmlAttributeSyntax> Attributes { get { throw null; } }

        public SyntaxToken LessThanToken { get { throw null; } }

        public XmlNameSyntax Name { get { throw null; } }

        public SyntaxToken SlashGreaterThanToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items) { throw null; }

        public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken) { throw null; }

        public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes) { throw null; }

        public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken) { throw null; }

        public XmlEmptyElementSyntax WithName(XmlNameSyntax name) { throw null; }

        public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken) { throw null; }
    }

    public enum XmlNameAttributeElementKind : byte
    {
        Parameter = 0,
        ParameterReference = 1,
        TypeParameter = 2,
        TypeParameterReference = 3
    }

    public sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
    {
        internal XmlNameAttributeSyntax() { }

        public override SyntaxToken EndQuoteToken { get { throw null; } }

        public override SyntaxToken EqualsToken { get { throw null; } }

        public IdentifierNameSyntax Identifier { get { throw null; } }

        public override XmlNameSyntax Name { get { throw null; } }

        public override SyntaxToken StartQuoteToken { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken) { throw null; }

        public new XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) { throw null; }

        public new XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier) { throw null; }

        public new XmlNameAttributeSyntax WithName(XmlNameSyntax name) { throw null; }

        public new XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) { throw null; }
    }

    public sealed partial class XmlNameSyntax : CSharpSyntaxNode
    {
        internal XmlNameSyntax() { }

        public SyntaxToken LocalName { get { throw null; } }

        public XmlPrefixSyntax? Prefix { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlNameSyntax Update(XmlPrefixSyntax? prefix, SyntaxToken localName) { throw null; }

        public XmlNameSyntax WithLocalName(SyntaxToken localName) { throw null; }

        public XmlNameSyntax WithPrefix(XmlPrefixSyntax? prefix) { throw null; }
    }

    public abstract partial class XmlNodeSyntax : CSharpSyntaxNode
    {
        internal XmlNodeSyntax() { }
    }

    public sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
    {
        internal XmlPrefixSyntax() { }

        public SyntaxToken ColonToken { get { throw null; } }

        public SyntaxToken Prefix { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken) { throw null; }

        public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken) { throw null; }

        public XmlPrefixSyntax WithPrefix(SyntaxToken prefix) { throw null; }
    }

    public sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
    {
        internal XmlProcessingInstructionSyntax() { }

        public SyntaxToken EndProcessingInstructionToken { get { throw null; } }

        public XmlNameSyntax Name { get { throw null; } }

        public SyntaxToken StartProcessingInstructionToken { get { throw null; } }

        public SyntaxTokenList TextTokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items) { throw null; }

        public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken) { throw null; }

        public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken) { throw null; }

        public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name) { throw null; }

        public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken) { throw null; }

        public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens) { throw null; }
    }

    public sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
    {
        internal XmlTextAttributeSyntax() { }

        public override SyntaxToken EndQuoteToken { get { throw null; } }

        public override SyntaxToken EqualsToken { get { throw null; } }

        public override XmlNameSyntax Name { get { throw null; } }

        public override SyntaxToken StartQuoteToken { get { throw null; } }

        public SyntaxTokenList TextTokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items) { throw null; }

        public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken) { throw null; }

        public new XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) { throw null; }

        public new XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) { throw null; }

        public new XmlTextAttributeSyntax WithName(XmlNameSyntax name) { throw null; }

        public new XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) { throw null; }

        public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens) { throw null; }
    }

    public sealed partial class XmlTextSyntax : XmlNodeSyntax
    {
        internal XmlTextSyntax() { }

        public SyntaxTokenList TextTokens { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public XmlTextSyntax AddTextTokens(params SyntaxToken[] items) { throw null; }

        public XmlTextSyntax Update(SyntaxTokenList textTokens) { throw null; }

        public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens) { throw null; }
    }

    public sealed partial class YieldStatementSyntax : StatementSyntax
    {
        internal YieldStatementSyntax() { }

        public override SyntaxList<AttributeListSyntax> AttributeLists { get { throw null; } }

        public ExpressionSyntax? Expression { get { throw null; } }

        public SyntaxToken ReturnOrBreakKeyword { get { throw null; } }

        public SyntaxToken SemicolonToken { get { throw null; } }

        public SyntaxToken YieldKeyword { get { throw null; } }

        public override void Accept(CSharpSyntaxVisitor visitor) { }

        public override TResult? Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
            where TResult : default { throw null; }

        public new YieldStatementSyntax AddAttributeLists(params AttributeListSyntax[] items) { throw null; }

        public YieldStatementSyntax Update(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken) { throw null; }

        public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken) { throw null; }

        public new YieldStatementSyntax WithAttributeLists(SyntaxList<AttributeListSyntax> attributeLists) { throw null; }

        public YieldStatementSyntax WithExpression(ExpressionSyntax? expression) { throw null; }

        public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword) { throw null; }

        public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken) { throw null; }

        public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword) { throw null; }
    }
}
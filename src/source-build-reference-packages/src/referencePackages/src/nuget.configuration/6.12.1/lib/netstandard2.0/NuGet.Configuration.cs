// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
// ------------------------------------------------------------------------------
// Changes to this file must follow the http://aka.ms/api-review process.
// ------------------------------------------------------------------------------
[assembly: System.Runtime.CompilerServices.CompilationRelaxations(8)]
[assembly: System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: System.Diagnostics.Debuggable(System.Diagnostics.DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: System.CLSCompliant(true)]
[assembly: System.Runtime.Versioning.TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
[assembly: System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly: System.Reflection.AssemblyConfiguration("release")]
[assembly: System.Reflection.AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")]
[assembly: System.Reflection.AssemblyDescription("NuGet's configuration settings implementation.")]
[assembly: System.Reflection.AssemblyFileVersion("6.12.1.1")]
[assembly: System.Reflection.AssemblyInformationalVersion("6.12.1+aa7eb9987d28e7169cfabfa484f2fdd22d2b91d2.aa7eb9987d28e7169cfabfa484f2fdd22d2b91d2")]
[assembly: System.Reflection.AssemblyProduct("NuGet")]
[assembly: System.Reflection.AssemblyTitle("NuGet.Configuration")]
[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/NuGet/NuGet.Client")]
[assembly: System.Resources.NeutralResourcesLanguage("en-US")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100C547CAC37ABD99C8DB225EF2F6C8A3602F3B3606CC9891605D02BAA56104F4CFC0734AA39B93BF7852F7D9266654753CC297E7D2EDFE0BAC1CDCF9F717241550E0A7B191195B7667BB4F64BCB8E2121380FD1D9D46AD2D92D2D15605093924CCEAF74C4861EFF62ABF69B9291ED0A340E113BE11E6A7D3113E92484CF7045CC7")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.Commands.FuncTest, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.Commands.Test, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.Configuration.Test, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.Credentials.Test, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.DependencyResolver.Core.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.SolutionRestoreManager.Test, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("NuGet.VisualStudio.Implementation.Test, PublicKey=0024000004800000940000000602000000240000525341310004000001000100A5276DF8650A58CB43396DC7B3D395F30A82D0D1FA98FBCFE3ABEAD5DE0B1DB6764347A0F6BF0B060A27C202CCD122DB5DED8F596CEBE2ECC3A6629015EEB96C94F6B9E8185D4ACC84C376FF6B1C3147431A4D55CB5736DB97A9E88FCC47D9193F4DB5896DC5817E5D0CBD2641726E7431990BCD2DD7FA1D28493D0CFD9DCFA4")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Test.Utility, PublicKey=002400000480000094000000060200000024000052534131000400000100010007D1FA57C4AED9F0A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C834C99921EB23BE79AD9D5DCC1DD9AD236132102900B723CF980957FC4E177108FC607774F29E8320E92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF0FC4963D261C8A12436518206DC093344D5AD293")]
[assembly: System.Reflection.AssemblyVersionAttribute("6.12.1.1")]
[assembly: System.Runtime.CompilerServices.ReferenceAssembly]
[assembly: System.Reflection.AssemblyFlagsAttribute((System.Reflection.AssemblyNameFlags)0x70)]
namespace NuGet.Configuration
{
    public partial class AddItem : SettingItem
    {
        public AddItem(string key, string? value, System.Collections.Generic.IReadOnlyDictionary<string, string>? additionalAttributes) { }

        public AddItem(string key, string? value) { }

        public System.Collections.Generic.IReadOnlyDictionary<string, string> AdditionalAttributes { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyCollection<string>> DisallowedValues { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public string Key { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public virtual string Value { get { throw null; } set { } }

        public void AddOrUpdateAdditionalAttribute(string attributeName, string value) { }

        public override SettingBase Clone() { throw null; }

        public sealed override bool Equals(object? other) { throw null; }

        public sealed override int GetHashCode() { throw null; }

        public virtual string GetValueAsPath() { throw null; }
    }

    public sealed partial class AuthorItem : TrustedSignerItem
    {
        public AuthorItem(string name, params CertificateItem[] certificates) : base(default!, default!) { }

        public override string ElementName { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public sealed partial class CertificateItem : SettingItem
    {
        public CertificateItem(string fingerprint, Common.HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot = false) { }

        public bool AllowUntrustedRoot { get { throw null; } set { } }

        public override string ElementName { get { throw null; } }

        public string Fingerprint { get { throw null; } set { } }

        public Common.HashAlgorithmName HashAlgorithm { get { throw null; } set { } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public sealed partial class ClearItem : SettingItem
    {
        public override string ElementName { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        public override bool IsEmpty() { throw null; }
    }

    public partial class ClientCertificateProvider : IClientCertificateProvider
    {
        public ClientCertificateProvider(ISettings settings) { }

        public void AddOrUpdate(ClientCertItem item) { }

        public ClientCertItem? GetClientCertificate(string packageSourceName) { throw null; }

        public System.Collections.Generic.IReadOnlyList<ClientCertItem> GetClientCertificates() { throw null; }

        public void Remove(System.Collections.Generic.IReadOnlyList<ClientCertItem> items) { }
    }

    public abstract partial class ClientCertItem : SettingItem
    {
        protected ClientCertItem(string packageSource) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public string PackageSource { get { throw null; } }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        public abstract System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate> Search();
        protected void SetPackageSource(string value) { }
    }

    public static partial class ConfigurationConstants
    {
        public static readonly string ActivePackageSourceSectionName;
        public static readonly string Add;
        public static readonly string AllowInsecureConnections;
        public static readonly string AllowUntrustedRoot;
        public static readonly string ApiKeys;
        public static readonly string AuditSources;
        public static readonly string Author;
        public static readonly string BeginIgnoreMarker;
        public static readonly string BindingRedirectsSection;
        public static readonly string Certificate;
        public static readonly string Clear;
        public static readonly string ClearTextPasswordAttribute;
        public static readonly string ClearTextPasswordToken;
        public static readonly string ClientCertificates;
        public static readonly string Config;
        public static readonly string Configuration;
        public static readonly string ConfigurationDefaultsFile;
        public static readonly string CredentialsSectionName;
        public static readonly string DefaultPackageManagementFormatKey;
        public static readonly string DefaultPushSource;
        public static readonly string DependencyVersion;
        public static readonly string DisabledPackageSources;
        public static readonly string DisableTLSCertificateValidation;
        public static readonly string DoNotShowPackageManagementSelectionKey;
        public static readonly string Enabled;
        public static readonly string EndIgnoreMarker;
        public static readonly string FailOnBindingRedirects;
        public static readonly string FallbackPackageFolders;
        public static readonly string FileCertificate;
        public static readonly string FindByAttribute;
        public static readonly string FindValueAttribute;
        public static readonly string Fingerprint;
        public static readonly string FingerprintAlgorithm;
        public static readonly string GlobalPackagesFolder;
        public static readonly string HashAlgorithm;
        public static readonly string HostKey;
        public static readonly string KeyAttribute;
        public static readonly string MaxHttpRequestsPerSource;
        public static readonly string NameAttribute;
        public static readonly string NoProxy;
        public static readonly string Owners;
        public static readonly string Package;
        public static readonly string PackageManagementSection;
        public static readonly string PackageRestore;
        public static readonly string PackageSourceAttribute;
        public static readonly string PackageSourceMapping;
        public static readonly string PackageSources;
        public static readonly string PasswordAttribute;
        public static readonly string PasswordKey;
        public static readonly string PasswordToken;
        public static readonly string PathAttribute;
        public static readonly string PatternAttribute;
        public static readonly string ProtocolVersionAttribute;
        public static readonly string Repository;
        public static readonly string RepositoryPath;
        public static readonly string ServiceIndex;
        public static readonly string SignatureValidationMode;
        public static readonly string SkipBindingRedirectsKey;
        public static readonly string StoreCertificate;
        public static readonly string StoreLocationAttribute;
        public static readonly string StoreNameAttribute;
        public static readonly string TrustedSigners;
        public static readonly string UpdatePackageLastAccessTime;
        public static readonly string UserKey;
        public static readonly string UsernameToken;
        public static readonly string ValidAuthenticationTypesToken;
        public static readonly string ValueAttribute;
        public static System.Collections.Generic.IReadOnlyList<string> GetConfigKeys() { throw null; }
    }

    public partial class ConfigurationDefaults
    {
        internal ConfigurationDefaults() { }

        public System.Collections.Generic.IReadOnlyList<PackageSource> DefaultAuditSources { get { throw null; } }

        public string? DefaultPackageRestoreConsent { get { throw null; } }

        public System.Collections.Generic.IEnumerable<PackageSource> DefaultPackageSources { get { throw null; } }

        public string? DefaultPushSource { get { throw null; } }

        public static ConfigurationDefaults Instance { get { throw null; } }
    }

    public enum CredentialRequestType
    {
        Proxy = 0,
        Unauthorized = 1,
        Forbidden = 2
    }

    public sealed partial class CredentialsItem : SettingItem
    {
        public CredentialsItem(string name, string username, string password, bool isPasswordClearText, string? validAuthenticationTypes) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public bool IsPasswordClearText { get { throw null; } }

        public string Password { get { throw null; } }

        public string Username { get { throw null; } set { } }

        public string? ValidAuthenticationTypes { get { throw null; } set { } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        public override bool IsEmpty() { throw null; }

        public void UpdatePassword(string password, bool isPasswordClearText = true) { }
    }

    public static partial class EncryptionUtility
    {
        public static string DecryptString(string encryptedString) { throw null; }

        public static string EncryptString(string value) { throw null; }
    }

    public sealed partial class FileClientCertItem : ClientCertItem
    {
        public FileClientCertItem(string packageSource, string filePath, string? password, bool storePasswordInClearText, string settingsFilePath) : base(default!) { }

        protected override System.Collections.Generic.IReadOnlyCollection<string> AllowedAttributes { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public string FilePath { get { throw null; } }

        public bool IsPasswordIsClearText { get { throw null; } }

        public string? Password { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate> Search() { throw null; }

        public void Update(string filePath, string? password, bool storePasswordInClearText) { }
    }

    public partial interface IClientCertificateProvider
    {
        void AddOrUpdate(ClientCertItem item);
        System.Collections.Generic.IReadOnlyList<ClientCertItem> GetClientCertificates();
        void Remove(System.Collections.Generic.IReadOnlyList<ClientCertItem> items);
    }

    public partial interface ICredentialCache
    {
        void Add(System.Uri uri, System.Net.ICredentials credentials);
        System.Net.ICredentials GetCredentials(System.Uri uri);
    }

    public partial interface ICredentialService
    {
        bool HandlesDefaultCredentials { get; }

        System.Threading.Tasks.Task<System.Net.ICredentials?> GetCredentialsAsync(System.Uri uri, System.Net.IWebProxy? proxy, CredentialRequestType type, string message, System.Threading.CancellationToken cancellationToken);
        bool TryGetLastKnownGoodCredentialsFromCache(System.Uri uri, bool isProxy, out System.Net.ICredentials? credentials);
    }

    public partial interface IExtensionLocator
    {
        System.Collections.Generic.IEnumerable<string> FindCredentialProviders();
        System.Collections.Generic.IEnumerable<string> FindExtensions();
    }

    public partial interface IMachineWideSettings
    {
        ISettings Settings { get; }
    }

    public partial interface IPackageSourceProvider
    {
        string? ActivePackageSourceName { get; }

        string? DefaultPushSource { get; }

        event System.EventHandler? PackageSourcesChanged;
        void AddPackageSource(PackageSource source);
        void DisablePackageSource(string name);
        void EnablePackageSource(string name);
        PackageSource? GetPackageSourceByName(string name);
        PackageSource? GetPackageSourceBySource(string source);
        bool IsPackageSourceEnabled(string name);
        System.Collections.Generic.IReadOnlyList<PackageSource> LoadAuditSources();
        System.Collections.Generic.IEnumerable<PackageSource> LoadPackageSources();
        void RemovePackageSource(string name);
        void SaveActivePackageSource(PackageSource source);
        void SavePackageSources(System.Collections.Generic.IEnumerable<PackageSource> sources);
        void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    }

    public partial interface IProxyCache
    {
        void Add(System.Net.IWebProxy proxy);
        System.Net.IWebProxy? GetProxy(System.Uri uri);
    }

    public partial interface IProxyCredentialCache : System.Net.ICredentials
    {
        System.Guid Version { get; }

        void UpdateCredential(System.Uri proxyAddress, System.Net.NetworkCredential credentials);
    }

    public partial interface ISettings
    {
        event System.EventHandler? SettingsChanged;
        void AddOrUpdate(string sectionName, SettingItem item);
        System.Collections.Generic.IList<string> GetConfigFilePaths();
        System.Collections.Generic.IList<string> GetConfigRoots();
        SettingSection? GetSection(string sectionName);
        void Remove(string sectionName, SettingItem item);
        void SaveToDisk();
    }

    public partial class NuGetConfigurationException : System.Exception
    {
        protected NuGetConfigurationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }

        public NuGetConfigurationException(string message, System.Exception? innerException) { }

        public NuGetConfigurationException(string message) { }
    }

    public static partial class NuGetConstants
    {
        public static readonly string DefaultConfigContent;
        public static readonly string DefaultGalleryServerUrl;
        public static readonly string FeedName;
        public static readonly string ManifestExtension;
        public static readonly string ManifestSymbolsExtension;
        public static readonly string NuGetHostName;
        public static readonly string NuGetSolutionSettingsFolder;
        public static readonly string NuGetSymbolHostName;
        public static readonly string PackageExtension;
        public static readonly string PackageReferenceFile;
        public static readonly string PackageSpecFileName;
        public static readonly string ReadmeExtension;
        public static readonly string ReadmeFileName;
        public static readonly string SnupkgExtension;
        public static readonly string SymbolsExtension;
        public static readonly string V1FeedUrl;
        public const string V2FeedUrl = "https://www.nuget.org/api/v2/";
        public static readonly string V2LegacyFeedUrl;
        public static readonly string V2LegacyOfficialPackageSourceUrl;
        public const string V3FeedUrl = "https://api.nuget.org/v3/index.json";
    }

    public partial class NuGetPathContext : Common.INuGetPathContext
    {
        public required System.Collections.Generic.IReadOnlyList<string> FallbackPackageFolders { get { throw null; } init { } }

        public required string HttpCacheFolder { get { throw null; } init { } }

        public required string UserPackageFolder { get { throw null; } init { } }

        public static NuGetPathContext Create(ISettings settings) { throw null; }

        public static NuGetPathContext Create(string settingsRoot) { throw null; }
    }

    public partial class NullSettings : ISettings
    {
        public static NullSettings Instance { get { throw null; } }

        public event System.EventHandler? SettingsChanged { add { } remove { } }

        public void AddOrUpdate(string sectionName, SettingItem item) { }

        public System.Collections.Generic.IList<string> GetConfigFilePaths() { throw null; }

        public System.Collections.Generic.IList<string> GetConfigRoots() { throw null; }

        public SettingSection? GetSection(string sectionName) { throw null; }

        public void Remove(string sectionName, SettingItem item) { }

        public void SaveToDisk() { }
    }

    public sealed partial class OwnersItem : SettingItem
    {
        public static readonly char OwnersListSeparator;
        public OwnersItem(string owners) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public System.Collections.Generic.IList<string> Content { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public sealed partial class PackagePatternItem : SettingItem
    {
        public PackagePatternItem(string pattern) { }

        public override string ElementName { get { throw null; } }

        public string Pattern { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public partial class PackageSource : System.IEquatable<PackageSource>
    {
        public const int DefaultProtocolVersion = 2;
        public const int MaxProtocolVersion = 3;
        public PackageSource(string source, string name, bool isEnabled, bool isOfficial, bool isPersistable = true) { }

        public PackageSource(string source, string name, bool isEnabled) { }

        public PackageSource(string source, string name) { }

        public PackageSource(string source) { }

        public bool AllowInsecureConnections { get { throw null; } set { } }

        public System.Collections.Generic.IReadOnlyList<System.Security.Cryptography.X509Certificates.X509Certificate>? ClientCertificates { get { throw null; } set { } }

        public PackageSourceCredential? Credentials { get { throw null; } set { } }

        public string? Description { get { throw null; } set { } }

        public bool DisableTLSCertificateValidation { get { throw null; } set { } }

        public bool IsEnabled { get { throw null; } set { } }

        public bool IsHttp { get { throw null; } }

        public bool IsHttps { get { throw null; } }

        public bool IsLocal { get { throw null; } }

        public bool IsMachineWide { get { throw null; } set { } }

        public bool IsOfficial { get { throw null; } set { } }

        public bool IsPersistable { get { throw null; } }

        public int MaxHttpRequestsPerSource { get { throw null; } set { } }

        public string Name { get { throw null; } }

        public int ProtocolVersion { get { throw null; } set { } }

        public string Source { get { throw null; } set { } }

        public System.Uri SourceUri { get { throw null; } }

        public System.Uri? TrySourceAsUri { get { throw null; } }

        public SourceItem AsSourceItem() { throw null; }

        public PackageSource Clone() { throw null; }

        public bool Equals(PackageSource? other) { throw null; }

        public override bool Equals(object? obj) { throw null; }

        public override int GetHashCode() { throw null; }

        public override string ToString() { throw null; }
    }

    public partial class PackageSourceCredential : System.IEquatable<PackageSourceCredential>
    {
        public PackageSourceCredential(string source, string username, string passwordText, bool isPasswordClearText, string? validAuthenticationTypesText) { }

        public bool IsPasswordClearText { get { throw null; } }

        public string Password { get { throw null; } }

        public string PasswordText { get { throw null; } }

        public string Source { get { throw null; } }

        public string Username { get { throw null; } }

        public System.Collections.Generic.IEnumerable<string> ValidAuthenticationTypes { get { throw null; } }

        public string? ValidAuthenticationTypesText { get { throw null; } }

        public CredentialsItem AsCredentialsItem() { throw null; }

        public bool Equals(PackageSourceCredential? other) { throw null; }

        public override bool Equals(object? other) { throw null; }

        public static PackageSourceCredential FromUserInput(string source, string username, string password, bool storePasswordInClearText, string? validAuthenticationTypesText) { throw null; }

        public override int GetHashCode() { throw null; }

        public bool IsValid() { throw null; }

        public System.Net.ICredentials ToICredentials() { throw null; }
    }

    public partial class PackageSourceMapping
    {
        public PackageSourceMapping(System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyList<string>> patterns) { }

        public bool IsEnabled { get { throw null; } }

        public System.Collections.Generic.IReadOnlyList<string> GetConfiguredPackageSources(string packageId) { throw null; }

        public static PackageSourceMapping GetPackageSourceMapping(ISettings settings) { throw null; }

        public string? SearchForPattern(string packageId) { throw null; }
    }

    public partial class PackageSourceMappingProvider
    {
        public PackageSourceMappingProvider(ISettings settings, bool shouldSkipSave) { }

        public PackageSourceMappingProvider(ISettings settings) { }

        public bool ShouldSkipSave { get { throw null; } }

        public System.Collections.Generic.IReadOnlyList<PackageSourceMappingSourceItem> GetPackageSourceMappingItems() { throw null; }

        public void SavePackageSourceMappings(System.Collections.Generic.IReadOnlyList<PackageSourceMappingSourceItem> packageSourceMappingsSourceItems) { }
    }

    public partial class PackageSourceMappingSourceItem : SettingItem
    {
        public PackageSourceMappingSourceItem(string name, System.Collections.Generic.IEnumerable<PackagePatternItem> packagePatternItems) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public virtual string Key { get { throw null; } }

        public System.Collections.Generic.IList<PackagePatternItem> Patterns { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        protected void SetKey(string value) { }
    }

    public partial class PackageSourceProvider : IPackageSourceProvider
    {
        [System.Obsolete("https://github.com/NuGet/Home/issues/8479")]
        public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults, bool enablePackageSourcesChangedEvent) { }

        public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults) { }

        [System.Obsolete("https://github.com/NuGet/Home/issues/8479")]
        public PackageSourceProvider(ISettings settings, bool enablePackageSourcesChangedEvent) { }

        [System.Obsolete("https://github.com/NuGet/Home/issues/8479")]
        public PackageSourceProvider(ISettings settings, System.Collections.Generic.IEnumerable<PackageSource> configurationDefaultSources, bool enablePackageSourcesChangedEvent) { }

        public PackageSourceProvider(ISettings settings, System.Collections.Generic.IEnumerable<PackageSource> configurationDefaultSources) { }

        public PackageSourceProvider(ISettings settings) { }

        public string? ActivePackageSourceName { get { throw null; } }

        public string? DefaultPushSource { get { throw null; } }

        public ISettings Settings { get { throw null; } }

        public event System.EventHandler? PackageSourcesChanged { add { } remove { } }

        public void AddPackageSource(PackageSource source) { }

        [System.Obsolete("DisablePackageSource(PackageSource source) is deprecated. Please use DisablePackageSource(string name) instead.")]
        public void DisablePackageSource(PackageSource source) { }

        public void DisablePackageSource(string name) { }

        public void EnablePackageSource(string name) { }

        public PackageSource? GetPackageSourceByName(string name) { throw null; }

        public PackageSource? GetPackageSourceBySource(string source) { throw null; }

        public System.Collections.Generic.HashSet<string> GetPackageSourceNamesMatchingNamePrefix(string namePrefix) { throw null; }

        [System.Obsolete("IsPackageSourceEnabled(PackageSource source) is deprecated. Please use IsPackageSourceEnabled(string name) instead.")]
        public bool IsPackageSourceEnabled(PackageSource source) { throw null; }

        public bool IsPackageSourceEnabled(string name) { throw null; }

        public System.Collections.Generic.IReadOnlyList<PackageSource> LoadAuditSources() { throw null; }

        public System.Collections.Generic.IEnumerable<PackageSource> LoadPackageSources() { throw null; }

        public static System.Collections.Generic.IEnumerable<PackageSource> LoadPackageSources(ISettings settings) { throw null; }

        public void RemovePackageSource(string name) { }

        public void SaveActivePackageSource(PackageSource source) { }

        public void SavePackageSources(System.Collections.Generic.IEnumerable<PackageSource> sources) { }

        public void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled) { }
    }

    public partial class ProxyCache : IProxyCache, IProxyCredentialCache, System.Net.ICredentials
    {
        public ProxyCache(ISettings settings, Common.IEnvironmentVariableReader environment) { }

        public static ProxyCache Instance { get { throw null; } }

        public System.Guid Version { get { throw null; } }

        [System.Obsolete("Retained for backcompat only. Use UpdateCredential instead")]
        public void Add(System.Net.IWebProxy? proxy) { }

        public System.Net.NetworkCredential? GetCredential(System.Uri proxyAddress, string authType) { throw null; }

        public System.Net.IWebProxy? GetProxy(System.Uri sourceUri) { throw null; }

        public WebProxy? GetUserConfiguredProxy() { throw null; }

        public void UpdateCredential(System.Uri proxyAddress, System.Net.NetworkCredential credentials) { }
    }

    public sealed partial class RepositoryItem : TrustedSignerItem
    {
        public RepositoryItem(string name, string serviceIndex, params CertificateItem[] certificates) : base(default!, default!) { }

        public RepositoryItem(string name, string serviceIndex, string? owners, params CertificateItem[] certificates) : base(default!, default!) { }

        public override string ElementName { get { throw null; } }

        public new string Name { get { throw null; } set { } }

        public System.Collections.Generic.IList<string> Owners { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public string ServiceIndex { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public abstract partial class SettingBase
    {
        public abstract SettingBase Clone();
        public abstract bool IsEmpty();
    }

    public abstract partial class SettingElement : SettingBase
    {
        protected SettingElement() { }

        protected SettingElement(System.Collections.Generic.IReadOnlyDictionary<string, string>? attributes) { }

        protected virtual System.Collections.Generic.IReadOnlyCollection<string>? AllowedAttributes { get { throw null; } }

        protected virtual System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyCollection<string>>? AllowedValues { get { throw null; } }

        public string? ConfigPath { get { throw null; } }

        protected virtual System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyCollection<string>>? DisallowedValues { get { throw null; } }

        public abstract string ElementName { get; }

        protected System.Collections.Generic.Dictionary<string, string> MutableAttributes { get { throw null; } }

        protected virtual System.Collections.Generic.IReadOnlyCollection<string>? RequiredAttributes { get { throw null; } }

        protected void AddAttribute(string attributeName, string value) { }

        protected void AddOrUpdateAttribute(string attributeName, string? value) { }

        public override bool IsEmpty() { throw null; }
    }

    public enum SettingElementType
    {
        Unknown = 0,
        Configuration = 1,
        ActivePackageSource = 2,
        BindingRedirects = 3,
        Config = 4,
        PackageManagement = 5,
        PackageRestore = 6,
        PackageSourceCredentials = 7,
        PackageSources = 8,
        Add = 9,
        Author = 10,
        Certificate = 11,
        Clear = 12,
        Owners = 13,
        Repository = 14,
        FileCert = 15,
        StoreCert = 16,
        PackageSourceMapping = 17,
        PackageSource = 18,
        Package = 19,
        AuditSources = 20
    }

    public abstract partial class SettingItem : SettingElement
    {
        protected SettingItem() { }

        protected SettingItem(System.Collections.Generic.IReadOnlyDictionary<string, string>? attributes) { }

        protected virtual bool CanHaveChildren { get { throw null; } }

        public System.Collections.Generic.IReadOnlyDictionary<string, string> GetAttributes() { throw null; }
    }

    public partial class Settings : ISettings
    {
        public static readonly string DefaultSettingsFileName;
        public static readonly string[] OrderedSettingsFileNames;
        public static readonly string[] SupportedMachineWideConfigExtension;
        public Settings(string root, string fileName, bool isMachineWide) { }

        public Settings(string root, string fileName) { }

        public Settings(string root) { }

        public event System.EventHandler? SettingsChanged { add { } remove { } }

        public void AddOrUpdate(string sectionName, SettingItem item) { }

        public static string ApplyEnvironmentTransform(string value) { throw null; }

        public System.Collections.Generic.IEnumerable<string> GetAllSettingSections() { throw null; }

        public System.Collections.Generic.IList<string> GetConfigFilePaths() { throw null; }

        public System.Collections.Generic.IList<string> GetConfigRoots() { throw null; }

        public static System.Tuple<string, string> GetFileNameAndItsRoot(string root, string settingsPath) { throw null; }

        public SettingSection? GetSection(string sectionName) { throw null; }

        public static ISettings LoadDefaultSettings(string? root, string? configFileName, IMachineWideSettings? machineWideSettings, SettingsLoadingContext? settingsLoadingContext) { throw null; }

        public static ISettings LoadDefaultSettings(string? root, string? configFileName, IMachineWideSettings? machineWideSettings) { throw null; }

        public static ISettings LoadDefaultSettings(string? root) { throw null; }

        public static ISettings LoadImmutableSettingsGivenConfigPaths(System.Collections.Generic.IList<string>? configFilePaths, SettingsLoadingContext settingsLoadingContext) { throw null; }

        public static ISettings LoadMachineWideSettings(string root, params string[] paths) { throw null; }

        public static ISettings LoadSettingsGivenConfigPaths(System.Collections.Generic.IList<string> configFilePaths) { throw null; }

        public static ISettings LoadSpecificSettings(string root, string configFileName) { throw null; }

        public void Remove(string sectionName, SettingItem item) { }

        public void SaveToDisk() { }
    }

    public abstract partial class SettingSection : SettingsGroup<SettingItem>
    {
        protected SettingSection(string name, System.Collections.Generic.IReadOnlyDictionary<string, string>? attributes, System.Collections.Generic.IEnumerable<SettingItem>? children) : base(default!) { }

        public System.Collections.Generic.IReadOnlyCollection<SettingItem> Items { get { throw null; } }

        public override bool Equals(object? other) { throw null; }

        public T? GetFirstItemWithAttribute<T>(string attributeName, string expectedAttributeValue)
            where T : SettingItem { throw null; }

        public override int GetHashCode() { throw null; }
    }

    public abstract partial class SettingsGroup<T> : SettingElement where T : SettingElement
    {
        protected SettingsGroup(string name, System.Collections.Generic.IReadOnlyDictionary<string, string>? attributes, System.Collections.Generic.IEnumerable<T>? children) { }

        protected SettingsGroup(string name) { }

        protected virtual bool CanBeCleared { get { throw null; } }

        protected System.Collections.Generic.IList<T> Children { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public override bool IsEmpty() { throw null; }

        protected bool TryGetChild(T expectedChild, out T? currentChild) { throw null; }
    }

    public sealed partial class SettingsLoadingContext : System.IDisposable
    {
        public void Dispose() { }
    }

    public static partial class SettingsUtility
    {
        public static readonly string DefaultGlobalPackagesFolderPath;
        public static bool DeleteConfigValue(ISettings settings, string key) { throw null; }

        public static bool DeleteValue(ISettings settings, string section, string attributeKey, string attributeValue) { throw null; }

        public static string? GetConfigValue(ISettings settings, string key, bool decrypt = false, bool isPath = false) { throw null; }

        public static string? GetDecryptedValueForAddItem(ISettings settings, string section, string key, bool isPath = false) { throw null; }

        public static string? GetDefaultPushSource(ISettings settings) { throw null; }

        public static System.Collections.Generic.IEnumerable<PackageSource> GetEnabledSources(ISettings settings) { throw null; }

        public static System.Collections.Generic.IReadOnlyList<string> GetFallbackPackageFolders(ISettings settings) { throw null; }

        public static string GetGlobalPackagesFolder(ISettings settings) { throw null; }

        public static string GetHttpCacheFolder() { throw null; }

        public static int GetMaxHttpRequest(ISettings settings) { throw null; }

        public static string GetPluginsCacheFolder() { throw null; }

        public static string? GetRepositoryPath(ISettings settings) { throw null; }

        public static Common.RevocationMode GetRevocationMode(Common.IEnvironmentVariableReader? environmentVariableReader = null) { throw null; }

        public static Common.SignatureValidationMode GetSignatureValidationMode(ISettings settings) { throw null; }

        public static bool GetUpdatePackageLastAccessTimeEnabledStatus(ISettings settings) { throw null; }

        public static string? GetValueForAddItem(ISettings settings, string section, string key, bool isPath = false) { throw null; }

        public static void SetConfigValue(ISettings settings, string key, string? value, bool encrypt = false) { }

        public static void SetEncryptedValueForAddItem(ISettings settings, string section, string key, string? value) { }
    }

    public sealed partial class SettingText : SettingBase
    {
        public SettingText(string value) { }

        public string Value { get { throw null; } set { } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        public override bool IsEmpty() { throw null; }
    }

    public sealed partial class SourceItem : AddItem
    {
        public SourceItem(string key, string value, string? protocolVersion, string? allowInsecureConnections, string? disableTLSCertificateValidation) : base(default!, default) { }

        public SourceItem(string key, string value, string? protocolVersion, string? allowInsecureConnections) : base(default!, default) { }

        public SourceItem(string key, string value, string? protocolVersion) : base(default!, default) { }

        public SourceItem(string key, string value) : base(default!, default) { }

        public string? AllowInsecureConnections { get { throw null; } set { } }

        public string? DisableTLSCertificateValidation { get { throw null; } set { } }

        public string? ProtocolVersion { get { throw null; } set { } }

        public override SettingBase Clone() { throw null; }
    }

    public sealed partial class StoreClientCertItem : ClientCertItem
    {
        public StoreClientCertItem(string packageSource, string findValue, System.Security.Cryptography.X509Certificates.StoreLocation? storeLocation = null, System.Security.Cryptography.X509Certificates.StoreName? storeName = null, System.Security.Cryptography.X509Certificates.X509FindType? findBy = null) : base(default!) { }

        protected override System.Collections.Generic.IReadOnlyCollection<string> AllowedAttributes { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IReadOnlyCollection<string>> AllowedValues { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public System.Security.Cryptography.X509Certificates.X509FindType FindType { get { throw null; } }

        public string FindValue { get { throw null; } }

        protected override System.Collections.Generic.IReadOnlyCollection<string> RequiredAttributes { get { throw null; } }

        public System.Security.Cryptography.X509Certificates.StoreLocation StoreLocation { get { throw null; } }

        public System.Security.Cryptography.X509Certificates.StoreName StoreName { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public static string GetString(System.Security.Cryptography.X509Certificates.StoreLocation storeLocation) { throw null; }

        public static string GetString(System.Security.Cryptography.X509Certificates.StoreName storeName) { throw null; }

        public static string GetString(System.Security.Cryptography.X509Certificates.X509FindType type) { throw null; }

        public override System.Collections.Generic.IEnumerable<System.Security.Cryptography.X509Certificates.X509Certificate> Search() { throw null; }

        public void Update(string? findValue, System.Security.Cryptography.X509Certificates.StoreLocation? storeLocation = null, System.Security.Cryptography.X509Certificates.StoreName? storeName = null, System.Security.Cryptography.X509Certificates.X509FindType? findBy = null) { }
    }

    public abstract partial class TrustedSignerItem : SettingItem
    {
        protected TrustedSignerItem(string name, System.Collections.Generic.IEnumerable<CertificateItem> certificates) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public System.Collections.Generic.IList<CertificateItem> Certificates { get { throw null; } }

        public virtual string Name { get { throw null; } }

        protected void SetName(string value) { }
    }

    public sealed partial class UnknownItem : SettingItem
    {
        public UnknownItem(string name, System.Collections.Generic.IReadOnlyDictionary<string, string>? attributes, System.Collections.Generic.IEnumerable<SettingBase>? children) { }

        protected override bool CanHaveChildren { get { throw null; } }

        public System.Collections.Generic.IReadOnlyList<SettingBase> Children { get { throw null; } }

        public override string ElementName { get { throw null; } }

        public override SettingBase Clone() { throw null; }

        public override bool Equals(object? other) { throw null; }

        public override int GetHashCode() { throw null; }

        public override bool IsEmpty() { throw null; }
    }

    public sealed partial class VirtualSettingSection : SettingSection
    {
        internal VirtualSettingSection() : base(default!, default, default) { }

        public override SettingBase Clone() { throw null; }
    }

    public partial class WebProxy : System.Net.IWebProxy
    {
        public WebProxy(string proxyAddress) { }

        public WebProxy(System.Uri proxyAddress) { }

        public System.Collections.Generic.IReadOnlyList<string> BypassList { get { throw null; } set { } }

        public System.Net.ICredentials? Credentials { get { throw null; } set { } }

        public System.Uri ProxyAddress { get { throw null; } }

        public System.Uri GetProxy(System.Uri destination) { throw null; }

        public bool IsBypassed(System.Uri uri) { throw null; }
    }

    public partial class XPlatMachineWideSetting : IMachineWideSettings
    {
        public ISettings Settings { get { throw null; } }
    }
}
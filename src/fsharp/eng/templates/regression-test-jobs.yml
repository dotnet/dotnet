# Template for F# Compiler Regression Tests
# Tests third-party F# projects with the freshly built compiler
#
# buildScript notation:
#   - Single command:   buildScript: dotnet build MySolution.sln
#   - Multiple commands: buildScript: dotnet build A.fsproj ;; dotnet build B.fsproj
#     Commands separated by ';;' run sequentially; the job fails on the first non-zero exit code.

parameters:
- name: testMatrix
  type: object
- name: dependsOn
  type:  string
  default: 'EndToEndBuildTests'

jobs:
- ${{ each item in parameters.testMatrix }}:
  - job: RegressionTest_${{ replace(replace(item.displayName, '-', '_'), '.', '_') }}_${{ replace(replace(replace(item.repo, '/', '_'), '-', '_'), '.', '_') }}
    displayName:  '${{ item.displayName }} Regression Test'
    dependsOn: ${{ parameters.dependsOn }}
    ${{ if item.useVmImage }}:
      pool:
        ${{ if item.usePool }}:
          name: ${{ item.usePool }}
          demands: ImageOverride -equals ${{ item.useVmImage }}
        ${{ else }}:
          vmImage: ${{ item.useVmImage }}
    ${{ else }}:
      pool:
        name: $(DncEngPublicBuildPool)
        demands:  ImageOverride -equals $(_WindowsMachineQueueName)
    timeoutInMinutes: 120
    steps:
    - checkout: self
      displayName: Checkout F# compiler repo (for scripts)

    - task: DownloadPipelineArtifact@2
      displayName: Download F# Compiler FSC Artifacts
      inputs: 
        artifactName: 'FSharpCompilerFscArtifacts'
        downloadPath: '$(Pipeline.Workspace)/FSharpCompiler/artifacts/bin/fsc'

    - task: DownloadPipelineArtifact@2
      displayName: Download F# Core Artifacts
      inputs:
        artifactName: 'FSharpCoreArtifacts'
        downloadPath: '$(Pipeline.Workspace)/FSharpCompiler/artifacts/bin/FSharp.Core'

    - task: DownloadPipelineArtifact@2
      displayName:  Download UseLocalCompiler props
      inputs:
        artifactName: 'UseLocalCompilerProps'
        downloadPath: '$(Pipeline.Workspace)/Props'

    - pwsh: |
        Write-Host "Cloning repository:  ${{ item.repo }}"
        git clone --recursive https://github.com/${{ item.repo }}.git $(Pipeline.Workspace)/TestRepo
        Set-Location $(Pipeline.Workspace)/TestRepo
        
        Write-Host "Checking out commit:  ${{ item.commit }}"
        git checkout ${{ item.commit }}
        
        Write-Host "Initializing submodules (if any)..."
        git submodule update --init --recursive
        
        Write-Host "Successfully checked out ${{ item.repo }} at commit ${{ item.commit }}"
        git log -1 --oneline
        
        Write-Host "Repository structure:"
        Get-ChildItem -Name
        
        $buildScript = '${{ item.buildScript }}'
        # Support ';;' separator for multiple commands â€” validate each command's script file
        $commands = $buildScript -split ';;' | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        foreach ($cmd in $commands) {
          if ($cmd -like "dotnet*") {
            Write-Host "Built-in dotnet command, skipping file check:  $cmd"
          } else {
            $scriptFile = ($cmd -split ' ', 2)[0]
            Write-Host "Verifying build script exists:  $scriptFile"
            if (Test-Path $scriptFile) {
              Write-Host "Build script found: $scriptFile"
            } else {
              Write-Host "Build script not found:  $scriptFile"
              Write-Host "Available files in root:"
              Get-ChildItem
              exit 1
            }
          }
        }
      displayName:  Checkout ${{ item.displayName }} at specific commit

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        Write-Host "Removing global.json to use latest SDK..."
        if (Test-Path "global.json") {
          Remove-Item "global.json" -Force
          Write-Host "global.json removed"
        } else {
          Write-Host "No global.json found"
        }
      displayName: Remove global.json to use latest SDK

    - task: UseDotNet@2
      displayName:  Install .NET SDK 8.0.x for ${{ item.displayName }}
      inputs:
        packageType: sdk
        version: '8.0.x'
        installationPath: $(Pipeline.Workspace)/TestRepo/.dotnet

    - task: UseDotNet@2
      displayName:  Install .NET SDK 9.0.x for ${{ item.displayName }}
      inputs:
        packageType: sdk
        version: '9.0.x'
        installationPath: $(Pipeline.Workspace)/TestRepo/.dotnet

    - task: UseDotNet@2
      displayName:  Install .NET SDK 10.0.100 for ${{ item.displayName }}
      inputs:
        packageType: sdk
        version: '10.0.100'
        installationPath: $(Pipeline.Workspace)/TestRepo/.dotnet

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        
        Write-Host "Running PrepareRepoForRegressionTesting.fsx..."
        dotnet fsi $(Build.SourcesDirectory)/eng/scripts/PrepareRepoForRegressionTesting.fsx "$(Pipeline.Workspace)/Props/UseLocalCompiler.Directory.Build.props"
        
        if ($LASTEXITCODE -ne 0) {
          Write-Host "Failed to prepare repository for regression testing"
          exit 1
        }
      displayName: Setup local compiler configuration for ${{ item.displayName }}

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        Write-Host "==========================================="
        Write-Host "Environment Information for ${{ item.displayName }}"
        Write-Host "==========================================="
        dotnet --info
        Write-Host ""
        Write-Host "MSBuild version:"
        dotnet msbuild -version
        Write-Host ""
        Write-Host "F# Compiler artifacts available:"
        $productTfm = (dotnet msbuild "$(Pipeline.Workspace)/Props/TargetFrameworks.props" --getProperty:FSharpNetCoreProductTargetFramework).Trim()
        Get-ChildItem "$(Pipeline.Workspace)/FSharpCompiler/bin/fsc/Release/$productTfm" -Name -ErrorAction SilentlyContinue
        Write-Host ""
        Write-Host "F# Core available:"
        if (Test-Path "$(Pipeline.Workspace)/FSharpCompiler/bin/FSharp.Core/Release/netstandard2.0/FSharp.Core.dll") {
          Write-Host "FSharp.Core.dll found"
        } else {
          Write-Host "FSharp.Core.dll not found"
        }
        Write-Host ""
        Write-Host "Directory.Build.props content:"
        Get-Content "Directory.Build.props"
        Write-Host ""
        Write-Host "==========================================="
      displayName: Report build environment for ${{ item.displayName }}

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        if (Test-Path ".config/dotnet-tools.json") {
          Write-Host "Restoring dotnet tools..."
          dotnet tool restore
          Write-Host "Tool restore exit code: $LASTEXITCODE"
        } else {
          Write-Host "No dotnet-tools.json found, skipping tool restore"
        }
      displayName: Restore dotnet tools for ${{ item.displayName }}
      continueOnError: true

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        Write-Host "============================================"
        Write-Host "Starting build for ${{ item.displayName }}"
        Write-Host "Repository: ${{ item.repo }}"
        Write-Host "Commit: ${{ item.commit }}"
        Write-Host "Build Script: ${{ item.buildScript }}"
        Write-Host "============================================"
        Write-Host ""
        
        $errorLogPath = "$(Pipeline.Workspace)/build-errors.log"
        $fullLogPath = "$(Pipeline.Workspace)/build-full.log"
        
        # Function to filter and capture important lines
        function Process-BuildOutput {
          param([string]$line)
          Write-Host $line
          if ($line -match ':  error ' -or 
              $line -match ': warning ' -or 
              $line -match 'FAILED|Failed!' -or
              $line -match '^\s+X\s+' -or
              $line -match 'Exception: ' -or
              $line -match '^\s+at\s+.*\(\)' -or
              $line -match 'Build FAILED') {
            Add-Content -Path $errorLogPath -Value $line
          }
        }

        function Run-Command {
          param([string]$cmd)
          if ($cmd -like "dotnet*") {
            Write-Host "Executing built-in command:  $cmd"
            if ($IsWindows) {
              cmd /c $cmd 2>&1 | Tee-Object -FilePath $fullLogPath -Append | ForEach-Object {
                Process-BuildOutput $_
              }
            } else {
              bash -c "$cmd" 2>&1 | Tee-Object -FilePath $fullLogPath -Append | ForEach-Object {
                Process-BuildOutput $_
              }
            }
          } elseif ($IsWindows) {
            Write-Host "Executing file-based script: $cmd"
            cmd /c ".\$cmd" 2>&1 | Tee-Object -FilePath $fullLogPath -Append | ForEach-Object {
              Process-BuildOutput $_
            }
          } else {
            Write-Host "Executing file-based script: $cmd"
            $scriptFile = ($cmd -split ' ', 2)[0]
            chmod +x "$scriptFile"
            bash -c "./$cmd" 2>&1 | Tee-Object -FilePath $fullLogPath -Append | ForEach-Object {
              Process-BuildOutput $_
            }
          }
          return $LASTEXITCODE
        }

        # Support ';;' separator for multiple commands
        $commands = ('${{ item.buildScript }}' -split ';;') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
        
        foreach ($cmd in $commands) {
          $exitCode = Run-Command $cmd
          if ($exitCode -ne 0) {
            Write-Host ""
            Write-Host "============================================"
            Write-Host "Command failed: $cmd"
            Write-Host "Exit code: $exitCode"
            Write-Host "============================================"
            exit $exitCode
          }
        }
        
        Write-Host ""
        Write-Host "============================================"
        Write-Host "Build completed for ${{ item.displayName }}"
        Write-Host "Exit code: 0"
        Write-Host "============================================"
      displayName:  Build ${{ item.displayName }} with local F# compiler
      env:
        LocalFSharpCompilerPath: $(Pipeline.Workspace)/FSharpCompiler
        LoadLocalFSharpBuild: 'True'
        LocalFSharpCompilerConfiguration: Release
      timeoutInMinutes:  120

    - pwsh:  |
        Set-Location $(Pipeline.Workspace)/TestRepo
        $binlogDir = "$(Pipeline.Workspace)/BinaryLogs"
        New-Item -ItemType Directory -Force -Path $binlogDir | Out-Null

        Write-Host "Collecting .binlog files..."
        $binlogs = Get-ChildItem -Path "." -Filter "*.binlog" -Recurse -ErrorAction SilentlyContinue
        if ($binlogs.Count -eq 0) {
          Write-Host "No .binlog files found"
        } else {
          foreach ($binlog in $binlogs) {
            Write-Host "Copying:  $($binlog.FullName)"
            Copy-Item $binlog.FullName -Destination $binlogDir
          }
          Write-Host "Collected $($binlogs.Count) .binlog files"
        }
      displayName:  Collect Binary Logs
      condition: always()
      continueOnError: true

    - task: PublishPipelineArtifact@1
      displayName:  Publish ${{ item.displayName }} Binary Logs
      inputs: 
        targetPath: '$(Pipeline.Workspace)/BinaryLogs'
        artifactName: '${{ item.displayName }}_BinaryLogs'
        publishLocation: pipeline
      condition: always()
      continueOnError: true

    - pwsh: |
        Set-Location $(Pipeline.Workspace)/TestRepo
        Write-Host ""
        Write-Host "============================================"
        Write-Host "Regression test completed for ${{ item.displayName }}"
        Write-Host "Repository: ${{ item.repo }}"
        Write-Host "Commit: ${{ item.commit }}"
        Write-Host "Build Script: ${{ item.buildScript }}"
        
        if ($env:AGENT_JOBSTATUS -eq "Succeeded") {
          Write-Host "Status: SUCCESS"
          Write-Host "The ${{ item.displayName }} library builds successfully with the new F# compiler"
        } else {
          Write-Host "Status: FAILED"
          Write-Host "The ${{ item.displayName }} library failed to build with the new F# compiler"
          
          $errorLogPath = "$(Pipeline.Workspace)/build-errors.log"
          if (Test-Path $errorLogPath) {
            Write-Host ""
            Write-Host "##[error]============================================"
            Write-Host "##[error]FAILURE SUMMARY for ${{ item.displayName }}"
            Write-Host "##[error]============================================"
            
            $errors = Get-Content $errorLogPath | Select-Object -First 100
            $errorCount = 0
            $warningCount = 0
            $testFailCount = 0
            
            foreach ($line in $errors) {
              if ($line -match ': error ') {
                Write-Host "##[error]$line"
                $errorCount++
              } elseif ($line -match ': warning ') {
                Write-Host "##[warning]$line"
                $warningCount++
              } elseif ($line -match 'FAILED|Failed! |^\s+X\s+') {
                Write-Host "##[error][TEST] $line"
                $testFailCount++
              } else {
                Write-Host "##[error]$line"
              }
            }
            
            $totalLines = (Get-Content $errorLogPath | Measure-Object -Line).Lines
            if ($totalLines -gt 100) {
              Write-Host "##[warning]... and $($totalLines - 100) more lines (see full log or binary logs)"
            }
            
            Write-Host ""
            Write-Host "##[error]Summary: $errorCount error(s), $warningCount warning(s), $testFailCount test failure(s)"
            Write-Host "##[error]============================================"
          } else {
            Write-Host "##[warning]No error log captured - check full build output above"
          }
          
          Write-Host ""
          Write-Host "##[section]LOCAL REPRODUCTION STEPS (from fsharp repo root):"
          Write-Host "# 1. Build the F# compiler"
          Write-Host "./build.sh -c Release"
          Write-Host ""
          Write-Host "# 2. Clone and checkout the failing library"
          Write-Host "cd .."
          Write-Host "git clone --recursive https://github.com/${{ item.repo }}.git TestRepo"
          Write-Host "cd TestRepo"
          Write-Host "git checkout ${{ item.commit }}"
          Write-Host "git submodule update --init --recursive"
          Write-Host "rm -f global.json"
          Write-Host ""
          Write-Host "# 3. Prepare the repo for local compiler"
          Write-Host "dotnet fsi ../fsharp/eng/scripts/PrepareRepoForRegressionTesting.fsx `"../fsharp/UseLocalCompiler.Directory.Build.props`""
          Write-Host ""
          Write-Host "# 4. Build with local compiler"
          Write-Host "export LocalFSharpCompilerPath=`$PWD/../fsharp"
          Write-Host "export LoadLocalFSharpBuild=True"
          Write-Host "export LocalFSharpCompilerConfiguration=Release"
          Write-Host "${{ item.buildScript }}"
          
          Write-Host "##vso[task.logissue type=error;sourcepath=azure-pipelines-PR.yml]Regression test failed: ${{ item.displayName }}"
        }
        Write-Host "============================================"
        
        Write-Host ""
        Write-Host "Binary logs found:"
        Get-ChildItem "*.binlog" -Recurse -ErrorAction SilentlyContinue | ForEach-Object { Write-Host $_.FullName }
      displayName: Report ${{ item.displayName }} test result
      condition: always()

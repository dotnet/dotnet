// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// <auto-generated />
#nullable enable

using System.Collections;
using System.CodeDom.Compiler;

namespace Microsoft.AspNetCore.Http;

[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }

    public int Count => 1;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }

    public int Count => 2;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }

    public int Count => 3;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }

    public int Count => 4;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }

    public int Count => 5;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
        Arg5 = arg5;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            5 => Arg5,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
               case 5:
                    Arg5 = (T5)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }
    public T5 Arg5 { get; set; }

    public int Count => 6;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           5 => (T)(object)Arg5!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
        Arg5 = arg5;
        Arg6 = arg6;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            5 => Arg5,
            6 => Arg6,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
               case 5:
                    Arg5 = (T5)(object?)value!;
                    break;
               case 6:
                    Arg6 = (T6)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }
    public T5 Arg5 { get; set; }
    public T6 Arg6 { get; set; }

    public int Count => 7;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           5 => (T)(object)Arg5!,
           6 => (T)(object)Arg6!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
        Arg5 = arg5;
        Arg6 = arg6;
        Arg7 = arg7;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            5 => Arg5,
            6 => Arg6,
            7 => Arg7,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
               case 5:
                    Arg5 = (T5)(object?)value!;
                    break;
               case 6:
                    Arg6 = (T6)(object?)value!;
                    break;
               case 7:
                    Arg7 = (T7)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }
    public T5 Arg5 { get; set; }
    public T6 Arg6 { get; set; }
    public T7 Arg7 { get; set; }

    public int Count => 8;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           5 => (T)(object)Arg5!,
           6 => (T)(object)Arg6!,
           7 => (T)(object)Arg7!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7, T8> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
        Arg5 = arg5;
        Arg6 = arg6;
        Arg7 = arg7;
        Arg8 = arg8;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            5 => Arg5,
            6 => Arg6,
            7 => Arg7,
            8 => Arg8,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
               case 5:
                    Arg5 = (T5)(object?)value!;
                    break;
               case 6:
                    Arg6 = (T6)(object?)value!;
                    break;
               case 7:
                    Arg7 = (T7)(object?)value!;
                    break;
               case 8:
                    Arg8 = (T8)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }
    public T5 Arg5 { get; set; }
    public T6 Arg6 { get; set; }
    public T7 Arg7 { get; set; }
    public T8 Arg8 { get; set; }

    public int Count => 9;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           5 => (T)(object)Arg5!,
           6 => (T)(object)Arg6!,
           7 => (T)(object)Arg7!,
           8 => (T)(object)Arg8!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}
[GeneratedCode("TextTemplatingFileGenerator", "")]
internal sealed class EndpointFilterInvocationContext<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> : EndpointFilterInvocationContext, IList<object?>
{
    internal EndpointFilterInvocationContext(HttpContext httpContext, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
    {
        HttpContext = httpContext;
        Arg0 = arg0;
        Arg1 = arg1;
        Arg2 = arg2;
        Arg3 = arg3;
        Arg4 = arg4;
        Arg5 = arg5;
        Arg6 = arg6;
        Arg7 = arg7;
        Arg8 = arg8;
        Arg9 = arg9;
    }

    public object? this[int index]
    {
        get => index switch
        {
            0 => Arg0,
            1 => Arg1,
            2 => Arg2,
            3 => Arg3,
            4 => Arg4,
            5 => Arg5,
            6 => Arg6,
            7 => Arg7,
            8 => Arg8,
            9 => Arg9,
            _ => new ArgumentOutOfRangeException(nameof(index))
        };
        set
        {
            switch (index)
            {
               case 0:
                    Arg0 = (T0)(object?)value!;
                    break;
               case 1:
                    Arg1 = (T1)(object?)value!;
                    break;
               case 2:
                    Arg2 = (T2)(object?)value!;
                    break;
               case 3:
                    Arg3 = (T3)(object?)value!;
                    break;
               case 4:
                    Arg4 = (T4)(object?)value!;
                    break;
               case 5:
                    Arg5 = (T5)(object?)value!;
                    break;
               case 6:
                    Arg6 = (T6)(object?)value!;
                    break;
               case 7:
                    Arg7 = (T7)(object?)value!;
                    break;
               case 8:
                    Arg8 = (T8)(object?)value!;
                    break;
               case 9:
                    Arg9 = (T9)(object?)value!;
                    break;
                default:
                    break;
            }
        }
    }

    public override HttpContext HttpContext { get; }

    public override IList<object?> Arguments => this;

    public T0 Arg0 { get; set; }
    public T1 Arg1 { get; set; }
    public T2 Arg2 { get; set; }
    public T3 Arg3 { get; set; }
    public T4 Arg4 { get; set; }
    public T5 Arg5 { get; set; }
    public T6 Arg6 { get; set; }
    public T7 Arg7 { get; set; }
    public T8 Arg8 { get; set; }
    public T9 Arg9 { get; set; }

    public int Count => 10;

    public bool IsReadOnly => false;

    public bool IsFixedSize => true;

    public void Add(object? item)
    {
        throw new NotSupportedException();
    }

    public void Clear()
    {
        throw new NotSupportedException();
    }

    public bool Contains(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return true;
            }
        }

        return false;
    }

    public void CopyTo(object?[] array, int arrayIndex)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            array[arrayIndex++] = Arguments[i];
        }
    }

    public IEnumerator<object?> GetEnumerator()
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            yield return Arguments[i];
        }
    }

    public override T GetArgument<T>(int index)
    {
        return index switch
        {
           0 => (T)(object)Arg0!,
           1 => (T)(object)Arg1!,
           2 => (T)(object)Arg2!,
           3 => (T)(object)Arg3!,
           4 => (T)(object)Arg4!,
           5 => (T)(object)Arg5!,
           6 => (T)(object)Arg6!,
           7 => (T)(object)Arg7!,
           8 => (T)(object)Arg8!,
           9 => (T)(object)Arg9!,
           _ => throw new ArgumentOutOfRangeException(nameof(index))
        };
    }

    public int IndexOf(object? item)
    {
        for (int i = 0; i < Arguments.Count; i++)
        {
            if (Arguments[i]?.Equals(item) == true)
            {
                return i;
            }
        }

        return -1;
    }

    public void Insert(int index, object? item)
    {
        throw new NotSupportedException();
    }

    public bool Remove(object? item)
    {
        throw new NotSupportedException();
    }

    public void RemoveAt(int index)
    {
        throw new NotSupportedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

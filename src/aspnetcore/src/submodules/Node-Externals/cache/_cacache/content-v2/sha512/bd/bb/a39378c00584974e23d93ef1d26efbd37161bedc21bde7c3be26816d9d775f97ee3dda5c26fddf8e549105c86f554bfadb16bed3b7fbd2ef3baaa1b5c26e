{"_id":"diff-sequences","_rev":"99dc1080-4188-416a-b516-fa643d527ef8","name":"diff-sequences","dist-tags":{"latest":"29.6.3","next":"30.0.0-alpha.3"},"versions":{"0.0.0":{"_id":"diff-sequences@0.0.0","name":"diff-sequences","description":"","version":"0.0.0","directories":{},"dist":{"shasum":"0b3376e68c02ff5bbca4bb0d0bfe26ab67503bf7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-0.0.0.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_0.0.0_1517992034571_0.7324709934672862"},"_hasShrinkwrap":false},"22.2.0":{"_id":"diff-sequences@22.2.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"22.2.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"46a0e57335062a1bd4d1a8b88dd5aab4207307e7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-22.2.0.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_22.2.0_1517999151975_0.5374213453134911"},"_hasShrinkwrap":false},"22.4.3":{"_id":"diff-sequences@22.4.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"22.4.3","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"48d99ea376fb3f049215ccc8606ff4154f4516bf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-22.4.3.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_22.4.3_1521648478627_0.22926297299456455"},"_hasShrinkwrap":false},"23.0.1":{"_id":"diff-sequences@23.0.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"23.0.1","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"7c0ec0a9ad5c7ce4395ba948a8f040489c88ab2d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-23.0.1.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_23.0.1_1527435037960_0.3578688685807707"},"_hasShrinkwrap":false},"23.2.0":{"_id":"diff-sequences@23.2.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"23.2.0","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"77b4ce1229345db8744a8be5064063d6072c9678","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-23.2.0.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_23.2.0_1529935507744_0.33531794695212747"},"_hasShrinkwrap":false},"23.6.0":{"_id":"diff-sequences@23.6.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"23.6.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"313fbfaedd00565a143521a4ab05e007e3db297d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-23.6.0.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_23.6.0_1536583366712_0.4829199435875795"},"_hasShrinkwrap":false},"24.0.0-alpha.0":{"_id":"diff-sequences@24.0.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"797d848ddb4751ceaff3413ac70f78f942e1f39b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"22f67d49ffcce7a5b6d6891438b837b3b26ba9db","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.0_1539951144113_0.6432423922570261"},"_hasShrinkwrap":false},"24.0.0-alpha.1":{"_id":"diff-sequences@24.0.0-alpha.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"0cb8546f71e6a3d157cb92fe4b0a178e36c48f70","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.1.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"4954f46708415174c48a58f296a605fbe1244a31","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.1_1540222528051_0.5059020296169037"},"_hasShrinkwrap":false},"24.0.0-alpha.2":{"_id":"diff-sequences@24.0.0-alpha.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"4b23cec46266dd8bf61fe57b1cd1dbd1b6a37d6d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.2.tgz"},"gitHead":"c5e36835cff4b241327db9cf58c8f6f7227ed1f7","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.2_1540463500064_0.5225365388805607"},"_hasShrinkwrap":false},"24.0.0-alpha.4":{"_id":"diff-sequences@24.0.0-alpha.4","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.4","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"b77b2500545c5450f73c7cf79692d433941e3fc3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.4.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"e41f0bb257c6652c3100b97a1087f9f812fbea0d","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.4_1540571577591_0.5130622776524432"},"_hasShrinkwrap":false},"24.0.0-alpha.5":{"_id":"diff-sequences@24.0.0-alpha.5","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.5","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"4f6a3201d5cbc05c4ec85a8782918e40f7c070cf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.5.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"2c18a53e8ff2437bba5fcb8076b754ac5f79f9f8","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.5_1541769147515_0.16601082038693682"},"_hasShrinkwrap":false},"24.0.0-alpha.6":{"_id":"diff-sequences@24.0.0-alpha.6","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.6","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"d1421aad3daa4a0c412b8653582283be34cc652c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.6.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"49d08403a941e596eda1279c07a1eaf4d4a73dad","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.6_1541785765740_0.5487019499237025"},"_hasShrinkwrap":false},"24.0.0-alpha.7":{"_id":"diff-sequences@24.0.0-alpha.7","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.7","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"main":"build/index.js","dist":{"shasum":"0dbbe9eeb8cf2690682502750c0f14ff2484c372","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.7.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"4954f46708415174c48a58f296a605fbe1244a31","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.7_1544544450385_0.8767994851184364"},"_hasShrinkwrap":false},"24.0.0-alpha.9":{"_id":"diff-sequences@24.0.0-alpha.9","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.9","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"9fb1791b7ef1734b012c80306ba06735f38684e0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.9.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"c7caa7ba5904d0c61e586694cde5f536639e4afc","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.9_1545229373441_0.056509693246487025"},"_hasShrinkwrap":false},"24.0.0-alpha.10":{"_id":"diff-sequences@24.0.0-alpha.10","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.10","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"d9bb880f84078eb01aa4a72d9782d138e50c84cf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.10.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"722049ccd66947d48296dcb666bc99fccab86065","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.10_1547053258708_0.6037156508529322"},"_hasShrinkwrap":false},"24.0.0-alpha.11":{"_id":"diff-sequences@24.0.0-alpha.11","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.11","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"cb6bc9ebb9c4bc3f5e6bafaac786b326124a3fbb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.11.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"6a066c6afe2ae08669a27d3b703a6cf0d898e7b7","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.11_1547145684380_0.5361225083077126"},"_hasShrinkwrap":false},"24.0.0-alpha.12":{"_id":"diff-sequences@24.0.0-alpha.12","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.12","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"88cc5aebf11c60b5bfe01414a10e434d4e45311a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.12.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"4f2bcb861d1f0fb150c05970362e52a38c31f67e","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.12_1547218682692_0.19852421640191076"},"_hasShrinkwrap":false},"24.0.0-alpha.13":{"_id":"diff-sequences@24.0.0-alpha.13","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.13","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"f76ba219d05c5495f71a78316427c4b9c2cdca5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.13.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"6de22dde9a10f775adc7b6f80080bdd224f6ae31","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.13_1548256516166_0.37449123475823987"},"_hasShrinkwrap":false},"24.0.0-alpha.15":{"_id":"diff-sequences@24.0.0-alpha.15","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.15","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"29c6aad320390ac8b9f5ba48b99939fc7c4815e7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.15.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"28971c5f794330e8acc6861288e6daafcd32238e","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.15_1548352336663_0.6978139683358666"},"_hasShrinkwrap":false},"24.0.0-alpha.16":{"_id":"diff-sequences@24.0.0-alpha.16","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0-alpha.16","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"7d80b224c276f74807f6149f4f57aaadc0f695bc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0-alpha.16.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","gitHead":"634e5a54f46b2a62d1dc81a170562e6f4e55ad60","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0-alpha.16_1548423707835_0.8804922598482618"},"_hasShrinkwrap":false},"24.0.0":{"_id":"diff-sequences@24.0.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.0.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"cdf8e27ed20d8b8d3caccb4e0c0d8fe31a173013","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.0.0.tgz"},"gitHead":"634e5a54f46b2a62d1dc81a170562e6f4e55ad60","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.0.0_1548428682371_0.9163471860444559"},"_hasShrinkwrap":false},"24.2.0-alpha.0":{"_id":"diff-sequences@24.2.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.2.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"958be148e0bbb42462eb3594f4a92b3d8019d418","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.2.0-alpha.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"build/index.d.ts","gitHead":"800f2f803d01c8ae194d71b251e4965dd70e5bf2","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.2.0-alpha.0_1551797181846_0.29220347658793466"},"_hasShrinkwrap":false},"24.2.0":{"_id":"diff-sequences@24.2.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.2.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"605025e678673636d82c49eda94a9cebcbf4b648","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.2.0.tgz"},"types":"build/index.d.ts","gitHead":"d23f1ef18567763ab0133372e376ae5026a23d4b","_nodeVersion":"8.10.0","_npmVersion":"lerna/3.13.1/node@v8.10.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.2.0_1551784963744_0.9274550559945209"},"_hasShrinkwrap":false},"24.3.0":{"_id":"diff-sequences@24.3.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.3.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"0f20e8a1df1abddaf4d9c226680952e64118b975","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.3.0.tgz"},"types":"build/index.d.ts","gitHead":"3a7a4f3a3f5489ac8e07dcddf76bb949c482ec87","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.3.0_1551963558692_0.7852251620556123"},"_hasShrinkwrap":false},"24.9.0":{"_id":"diff-sequences@24.9.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"24.9.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5715d6244e2aa65f48bba0bc972db0b0b11e95b5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-24.9.0.tgz"},"types":"build/index.d.ts","gitHead":"9ad0f4bc6b8bdd94989804226c28c9960d9da7d1","_nodeVersion":"11.12.0","_npmVersion":"lerna/3.15.0/node@v11.12.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_24.9.0_1565934946970_0.6896997727763712"},"_hasShrinkwrap":false},"25.0.0":{"_id":"diff-sequences@25.0.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.0.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 8"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"12e39d89da8c559b4eceef169260d9175683509c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.0.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences'); // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\n/* eslint-disable no-var */\nvar a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nvar b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n/* eslint-disable no-var */\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  var n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nvar commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"build/index.d.ts","gitHead":"ff9269be05fd8316e95232198fce3463bf2f270e","readmeFilename":"README.md","_nodeVersion":"11.12.0","_npmVersion":"lerna/3.16.4/node@v11.12.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.0.0_1566444224445_0.703563251151955"},"_hasShrinkwrap":false},"25.1.0":{"_id":"diff-sequences@25.1.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.1.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fd29a46f1c913fd66c22645dc75bffbe43051f32","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.1.0.tgz"},"types":"build/index.d.ts","gitHead":"170eee11d03b0ed5c60077982fdbc3bafd403638","_nodeVersion":"10.16.0","_npmVersion":"lerna/3.20.2/node@v10.16.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"davidzilburg","email":"davidzilburg@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.1.0_1579654784507_0.9473791596126149"},"_hasShrinkwrap":false},"25.2.0-alpha.86":{"_id":"diff-sequences@25.2.0-alpha.86","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.0-alpha.86","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"c7970a3f6a3b61908865223adf006fabb4987d10","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.0-alpha.86.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"build/index.d.ts","gitHead":"cd98198c9397d8b69c55155d7b224d62ef117a90","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.0-alpha.86_1585156571169_0.36378894271963924"},"_hasShrinkwrap":false},"25.2.0":{"_id":"diff-sequences@25.2.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"180bd89ff45c490b175de6dbb1d346db7b998a94","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.0.tgz"},"types":"build/index.d.ts","gitHead":"9f0339c1c762e39f869f7df63e88470287728b93","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.0_1585159078401_0.09206383670667995"},"_hasShrinkwrap":false},"25.2.1-alpha.1":{"_id":"diff-sequences@25.2.1-alpha.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.1-alpha.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ca1ca72782027ba61c6c6b679a4e58c9d1216469","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.1-alpha.1.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"build/index.d.ts","typesVersions":{"<3.8":{"*":["ts3.4/*"]}},"gitHead":"5cc2ccdacb1b2433581222252e43cb5a1f6861a9","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.1-alpha.1_1585209253663_0.6680817370295136"},"_hasShrinkwrap":false},"25.2.1-alpha.2":{"_id":"diff-sequences@25.2.1-alpha.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.1-alpha.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"da2510f09903ab730a68ee8406bb39f971fd32c6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.1-alpha.2.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"79b7ab67c63d3708f9689e25fbc0e8b0094bd019","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.1-alpha.2_1585210222069_0.9125051342980572"},"_hasShrinkwrap":false},"25.2.1":{"_id":"diff-sequences@25.2.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fcfe8aa07dd9b0c648396a478dabca8e76c6ab27","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.1.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"a679390828b6c30aeaa547d8c4dc9aed6531e357","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.1_1585213264802_0.602644697730381"},"_hasShrinkwrap":false},"25.2.6":{"_id":"diff-sequences@25.2.6","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"25.2.6","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5f467c00edd35352b7bca46d7927d60e687a76dd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-25.2.6.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"43207b743df164e9e58bd483dd9167b9084da18b","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_25.2.6_1585823348872_0.44856025691436185"},"_hasShrinkwrap":false},"26.0.0-alpha.0":{"_id":"diff-sequences@26.0.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"26.0.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"cf0049175dbebd590534fc38705de6323e64d208","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-26.0.0-alpha.0.tgz"},"types":"build/index.d.ts","gitHead":"ba962e7e9669a4a2f723c2536c97462c8ddfff2d","_nodeVersion":"12.16.3","_npmVersion":"lerna/3.20.2/node@v12.16.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_26.0.0-alpha.0_1588421571517_0.9402255981559462"},"_hasShrinkwrap":false},"26.0.0":{"_id":"diff-sequences@26.0.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"26.0.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^1.13.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"0760059a5c287637b842bd7085311db7060e88a6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-26.0.0.tgz"},"types":"build/index.d.ts","gitHead":"343532a21f640ac2709c4076eef57e52279542e1","_nodeVersion":"12.16.3","_npmVersion":"lerna/3.20.2/node@v12.16.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_26.0.0_1588614781423_0.7492404900089518"},"_hasShrinkwrap":false},"26.3.0":{"_id":"diff-sequences@26.3.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"26.3.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^2.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"62a59b1b29ab7fd27cef2a33ae52abe73042d0a2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-26.3.0.tgz"},"types":"build/index.d.ts","gitHead":"3a7e06fe855515a848241bb06a6f6e117847443d","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.22.1/node@v12.18.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_26.3.0_1597059101667_0.3306323827723736"},"_hasShrinkwrap":false},"26.5.0":{"_id":"diff-sequences@26.5.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"26.5.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^2.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ef766cf09d43ed40406611f11c6d8d9dd8b2fefd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-26.5.0.tgz"},"types":"build/index.d.ts","gitHead":"68d1b1b638bc7464c2794a957c1b894de7da2ee3","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.22.1/node@v12.18.1+x64 (darwin)","maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_26.5.0_1601890085902_0.17535582257312332"},"_hasShrinkwrap":false},"26.6.2":{"_id":"diff-sequences@26.6.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"26.6.2","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":null,"devDependencies":{"benchmark":"^2.1.4","diff":"^4.0.1","fast-check":"^2.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"48ba99157de1923412eed41db6b6d4aa9ca7c0b1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-26.6.2.tgz"},"types":"build/index.d.ts","gitHead":"4c46930615602cbf983fb7e8e82884c282a624d5"},"27.0.0-next.0":{"_id":"diff-sequences@27.0.0-next.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.0.0-next.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"4f0502557fd02bd7596f9c42ce67bf7d022559e8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.0.0-next.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"4f77c70602cab8419794f10fa39510f13baafef8","readmeFilename":"README.md","_nodeVersion":"14.15.0","_npmVersion":"lerna/3.22.1/node@v14.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_27.0.0-next.0_1607189107821_0.17805614845269968"},"_hasShrinkwrap":false},"27.0.1":{"_id":"diff-sequences@27.0.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.0.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9c9801d52ed5f576ff0a20e3022a13ee6e297e7c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.0.1.tgz"},"types":"./build/index.d.ts","gitHead":"2cb20e945a26b2c9867b30b787e81f6317e59aa1","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_27.0.1_1621937184053_0.7682171173613457"},"_hasShrinkwrap":false},"27.0.6":{"_id":"diff-sequences@27.0.6","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.0.6","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"3305cb2e55a033924054695cc66019fd7f8e5723","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.0.6.tgz"},"types":"./build/index.d.ts","gitHead":"d257d1c44ba62079bd4307ae78ba226d47c56ac9","_nodeVersion":"14.17.1","_npmVersion":"lerna/4.0.0/node@v14.17.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_27.0.6_1624899930869_0.696743839206365"},"_hasShrinkwrap":false},"27.4.0":{"_id":"diff-sequences@27.4.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.4.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d783920ad8d06ec718a060d00196dfef25b132a5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.4.0.tgz"},"types":"./build/index.d.ts","gitHead":"0dc6dde296550370ade2574d6665748fed37f9c9","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_27.4.0_1638193014711_0.09706689969055016"},"_hasShrinkwrap":false},"27.5.0":{"_id":"diff-sequences@27.5.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.5.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a8ac0cb742b17d6f30a6c43e233893a2402c0729","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.5.0.tgz"},"types":"./build/index.d.ts","gitHead":"247cbe6026a590deaf0d23edecc7b2779a4aace9","_nodeVersion":"16.13.2","_npmVersion":"lerna/4.0.0/node@v16.13.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_27.5.0_1644055157827_0.465702729865906"},"_hasShrinkwrap":false},"27.5.1":{"_id":"diff-sequences@27.5.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"27.5.1","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":null,"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"eaecc0d327fd68c8d9672a1e64ab8dccb2ef5327","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-27.5.1.tgz"},"types":"./build/index.d.ts","gitHead":"67c1aa20c5fec31366d733e901fee2b981cb1850"},"28.0.0-alpha.0":{"_id":"diff-sequences@28.0.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a85967b8a6ef6404e8650bf3c1ebdb255206ebeb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0-alpha.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"89275b08977065d98e42ad71fcf223f4ad169f09","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0-alpha.0_1644517046427_0.2647410282139955"},"_hasShrinkwrap":false},"28.0.0-alpha.3":{"_id":"diff-sequences@28.0.0-alpha.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0-alpha.3","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d6cea7495a69137a0d21fa0bcf9a9e4aba6ab354","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0-alpha.3.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"fc30b27bd94bb7ebeaadc72626ebbdba535150d2","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0-alpha.3_1645112540718_0.6913026721557378"},"_hasShrinkwrap":false},"28.0.0-alpha.4":{"_id":"diff-sequences@28.0.0-alpha.4","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0-alpha.4","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d652a519ee0720abe2579d1569b8f07b3e2e0641","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0-alpha.4.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(getRange(aIndex, aEnd) + 'c' + getRange(bIndex, bEnd));\n  } else if (deleteLines) {\n    array.push(getRange(aIndex, aEnd) + 'd' + String(bIndex));\n  } else if (insertLines) {\n    array.push(String(aIndex) + 'a' + getRange(bIndex, bEnd));\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push('< ' + aLines[aIndex]); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push('> ' + bLines[bIndex]); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : array.join('\\n') + '\\n';\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push('-·' + aLinesIn[aIndex]); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push('+·' + bLinesIn[bIndex]); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push('··' + bLinesIn[bIndex]); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push('-·' + aLinesIn[aIndex]);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push('+·' + bLinesIn[bIndex]);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"c13dab19491ba6b57c2d703e7d7c4b20189e1e17","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0-alpha.4_1645532034420_0.06373520305908609"},"_hasShrinkwrap":false},"28.0.0-alpha.6":{"_id":"diff-sequences@28.0.0-alpha.6","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0-alpha.6","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","scripts":{"perf":"node --expose-gc perf/index.js"},"directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"0083a9cc62e72d489475508cda49b8935c900392","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0-alpha.6.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"6284ada4adb7008f5f8673b1a7b1c789d2e508fb","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0-alpha.6_1646123542400_0.27084416232972774"},"_hasShrinkwrap":false},"28.0.0-alpha.9":{"_id":"diff-sequences@28.0.0-alpha.9","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0-alpha.9","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"329012d40d786479331ba0166f061caa2c6755ff","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0-alpha.9.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"7c63f5981eb20d4b89a4c04f3675e0050d8d7887","readmeFilename":"README.md","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0-alpha.9_1650365953773_0.6725265028221681"},"_hasShrinkwrap":false},"28.0.0":{"_id":"diff-sequences@28.0.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"06d253f0005463bf203d96fdbd6296c5f1d1888c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.0.tgz"},"types":"./build/index.d.ts","gitHead":"8f9b812faf8e4d241d560a8574f0c6ed20a89365","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.0_1650888482261_0.8115378916877636"},"_hasShrinkwrap":false},"28.0.2":{"_id":"diff-sequences@28.0.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.0.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^2.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"40f8d4ffa081acbd8902ba35c798458d0ff1af41","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.0.2.tgz"},"types":"./build/index.d.ts","gitHead":"279ee6658d763f024d51f340fab6a37c17d94502","_nodeVersion":"16.15.0","_npmVersion":"lerna/4.0.0/node@v16.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.0.2_1651045440175_0.46656987751356693"},"_hasShrinkwrap":false},"28.1.1":{"_id":"diff-sequences@28.1.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"28.1.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9989dc731266dc2903457a70e996f3a041913ac6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-28.1.1.tgz"},"types":"./build/index.d.ts","gitHead":"eb954f8874960920ac50a8f976bb333fbb06ada9","_nodeVersion":"16.15.1","_npmVersion":"lerna/4.0.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_28.1.1_1654582175367_0.998049636018808"},"_hasShrinkwrap":false},"29.0.0-alpha.0":{"_id":"diff-sequences@29.0.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.0.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"63c9b0a4969e7597020a7df7231d09c52a26afd6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.0.0-alpha.0.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"6862afb00307b52f32eedee977a9b3041355f184","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/4.0.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.0.0-alpha.0_1658095626526_0.11460747405906546"},"_hasShrinkwrap":false},"29.0.0-alpha.2":{"_id":"diff-sequences@29.0.0-alpha.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.0.0-alpha.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a542354065d04e2f3a7d29d72b2c5d4cf4313eed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.0.0-alpha.2.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"53c11a22213dfde9901678a3fdeb438dc039066a","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.9.1/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.0.0-alpha.2_1659742345248_0.5103392827851343"},"_hasShrinkwrap":false},"29.0.0-alpha.3":{"_id":"diff-sequences@29.0.0-alpha.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.0.0-alpha.3","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"e27332f282e5142d4d03804ae6778ddd90dbb3e1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.0.0-alpha.3.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"09981873c55442e5e494d42012f518b7d3d41fbd","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.10.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.0.0-alpha.3_1659879691877_0.6277185356988579"},"_hasShrinkwrap":false},"29.0.0":{"_id":"diff-sequences@29.0.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.0.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"bae49972ef3933556bcb0800b72e8579d19d9e4f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.0.0.tgz"},"types":"./build/index.d.ts","gitHead":"75006e46c76f6fda14bbc0548f86edb2ba087cd2","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.10.0/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.0.0_1661430804495_0.6604604596238781"},"_hasShrinkwrap":false},"29.2.0":{"_id":"diff-sequences@29.2.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.2.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"benchmark":"^2.1.4","diff":"^5.0.0","fast-check":"^3.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"4c55b5b40706c7b5d2c5c75999a50c56d214e8f6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.2.0.tgz"},"types":"./build/index.d.ts","gitHead":"ee5b37a4f4433afcfffb0356cea47739d8092287","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.2.0_1665738821198_0.05435777744290804"},"_hasShrinkwrap":false},"29.3.1":{"_id":"diff-sequences@29.3.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.3.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"104b5b95fe725932421a9c6e5b4bef84c3f2249e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.3.1.tgz"},"types":"./build/index.d.ts","gitHead":"05deb8393c4ad71e19be2567b704dfd3a2ab5fc9","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.3.1_1667948179328_0.7857559123306008"},"_hasShrinkwrap":false},"29.4.2":{"_id":"diff-sequences@29.4.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.4.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"711fe6bd8a5869fe2539cee4a5152425ff671fda","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.4.2.tgz"},"types":"./build/index.d.ts","gitHead":"f0fc92e8443f09546c7ec0472bf9bce44fe5898f","_nodeVersion":"16.19.0","_npmVersion":"lerna/1.13.0/node@v16.19.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_29.4.2_1675777521692_0.4266724773528614"},"_hasShrinkwrap":false},"29.4.3":{"_id":"diff-sequences@29.4.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.4.3","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9314bc1fabe09267ffeca9cbafc457d8499a13f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.4.3.tgz"},"types":"./build/index.d.ts","gitHead":"a49c88610e49a3242576160740a32a2fe11161e1"},"29.6.3":{"_id":"diff-sequences@29.6.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"29.6.3","keywords":["fast","linear","space","callback","diff"],"repository":{"type":"git","url":"https://github.com/jestjs/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"4deaf894d11407c51efc8418012f9e70b84ea921","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-29.6.3.tgz"},"types":"./build/index.d.ts","gitHead":"fb7d95c8af6e0d65a8b65348433d8a0ea0725b5b"},"30.0.0-alpha.0":{"_id":"diff-sequences@30.0.0-alpha.0","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"30.0.0-alpha.0","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"55b1d44740ea6786c0451882978f03c95284f581","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-30.0.0-alpha.0.tgz"},"types":"./build/index.d.ts","gitHead":"780ae28333df4d188b2ef78bd19d4ed5bc53562d","_nodeVersion":"20.9.0","_npmVersion":"lerna/1.13.0/node@v20.9.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_30.0.0-alpha.0_1698671619575_0.24652076764896202"},"_hasShrinkwrap":false},"30.0.0-alpha.1":{"_id":"diff-sequences@30.0.0-alpha.1","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"30.0.0-alpha.1","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"88a95e2e493ac79456558c46888376cd070fb025","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-30.0.0-alpha.1.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"d005cb2505c041583e0c5636d006e08666a54b63","readmeFilename":"README.md","_nodeVersion":"20.9.0","_npmVersion":"lerna/1.13.0/node@v20.9.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_30.0.0-alpha.1_1698672766010_0.4029926200190441"},"_hasShrinkwrap":false},"30.0.0-alpha.2":{"_id":"diff-sequences@30.0.0-alpha.2","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"30.0.0-alpha.2","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"e7457cc887e495a5f9a4e6478e4ecf428bb5acb5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-30.0.0-alpha.2.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"c04d13d7abd22e47b0997f6027886aed225c9ce4","readmeFilename":"README.md","_nodeVersion":"20.9.0","_npmVersion":"lerna/2.7.0/node@v20.9.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_30.0.0-alpha.2_1700126894341_0.05463297810203871"},"_hasShrinkwrap":false},"30.0.0-alpha.3":{"_id":"diff-sequences@30.0.0-alpha.3","name":"diff-sequences","description":"Compare items in two sequences to find a longest common subsequence","version":"30.0.0-alpha.3","keywords":["fast","linear","space","callback","diff"],"homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@fast-check/jest":"^1.3.0","benchmark":"^2.1.4","diff":"^5.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"07e7a50a0d73f69f8343151ca653aca85f76aab6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/diff-sequences/-/diff-sequences-30.0.0-alpha.3.tgz"},"readme":"# diff-sequences\n\nCompare items in two sequences to find a **longest common subsequence**.\n\nThe items not in common are the items to delete or insert in a **shortest edit script**.\n\nTo maximize flexibility and minimize memory, you write **callback** functions as configuration:\n\n**Input** function `isCommon(aIndex, bIndex)` compares items at indexes in the sequences and returns a truthy/falsey value. This package might call your function more than once for some pairs of indexes.\n\n- Because your function encapsulates **comparison**, this package can compare items according to `===` operator, `Object.is` method, or other criterion.\n- Because your function encapsulates **sequences**, this package can find differences in arrays, strings, or other data.\n\n**Output** function `foundSubsequence(nCommon, aCommon, bCommon)` receives the number of adjacent items and starting indexes of each common subsequence. If sequences do not have common items, then this package does not call your function.\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then D = N – 2L is the number of **differences** in the corresponding shortest edit script.\n\n[_An O(ND) Difference Algorithm and Its Variations_](http://xmailserver.org/diff2.pdf) by Eugene W. Myers is fast when sequences have **few** differences.\n\nThis package implements the **linear space** variation with optimizations so it is fast even when sequences have **many** differences.\n\n## Usage\n\nTo add this package as a dependency of a project, do either of the following:\n\n- `npm install diff-sequences`\n- `yarn add diff-sequences`\n\nTo use `diff` as the name of the default export from this package, do either of the following:\n\n- `var diff = require('diff-sequences').default; // CommonJS modules`\n- `import diff from 'diff-sequences'; // ECMAScript modules`\n\nCall `diff` with the **lengths** of sequences and your **callback** functions:\n\n```js\nconst a = ['a', 'b', 'c', 'a', 'b', 'b', 'a'];\nconst b = ['c', 'b', 'a', 'b', 'a', 'c'];\n\nfunction isCommon(aIndex, bIndex) {\n  return a[aIndex] === b[bIndex];\n}\nfunction foundSubsequence(nCommon, aCommon, bCommon) {\n  // see examples\n}\n\ndiff(a.length, b.length, isCommon, foundSubsequence);\n```\n\n## Example of longest common subsequence\n\nSome sequences (for example, `a` and `b` in the example of usage) have more than one longest common subsequence.\n\nThis package finds the following common items:\n\n| comparisons of common items      | values     |            output arguments |\n| :------------------------------- | :--------- | --------------------------: |\n| `a[2] === b[0]`                  | `'c'`      | `foundSubsequence(1, 2, 0)` |\n| `a[4] === b[1]`                  | `'b'`      | `foundSubsequence(1, 4, 1)` |\n| `a[5] === b[3] && a[6] === b[4]` | `'b', 'a'` | `foundSubsequence(2, 5, 3)` |\n\nThe “edit graph” analogy in the Myers paper shows the following common items:\n\n| comparisons of common items      | values     |\n| :------------------------------- | :--------- |\n| `a[2] === b[0]`                  | `'c'`      |\n| `a[3] === b[2] && a[4] === b[3]` | `'a', 'b'` |\n| `a[6] === b[4]`                  | `'a'`      |\n\nVarious packages which implement the Myers algorithm will **always agree** on the **length** of a longest common subsequence, but might **sometimes disagree** on which **items** are in it.\n\n## Example of callback functions to count common items\n\n```js\n// Return length of longest common subsequence according to === operator.\nfunction countCommonItems(a, b) {\n  let n = 0;\n  function isCommon(aIndex, bIndex) {\n    return a[aIndex] === b[bIndex];\n  }\n  function foundSubsequence(nCommon) {\n    n += nCommon;\n  }\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  return n;\n}\n\nconst commonLength = countCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| category of items  |                expression | value |\n| :----------------- | ------------------------: | ----: |\n| in common          |            `commonLength` |   `4` |\n| to delete from `a` | `a.length - commonLength` |   `3` |\n| to insert from `b` | `b.length - commonLength` |   `2` |\n\nIf the length difference `b.length - a.length` is:\n\n- negative: its absolute value is the minimum number of items to **delete** from `a`\n- positive: it is the minimum number of items to **insert** from `b`\n- zero: there is an **equal** number of items to delete from `a` and insert from `b`\n- non-zero: there is an equal number of **additional** items to delete from `a` and insert from `b`\n\nIn this example, `6 - 7` is:\n\n- negative: `1` is the minimum number of items to **delete** from `a`\n- non-zero: `2` is the number of **additional** items to delete from `a` and insert from `b`\n\n## Example of callback functions to find common items\n\n```js\n// Return array of items in longest common subsequence according to Object.is method.\nconst findCommonItems = (a, b) => {\n  const array = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex, bIndex) => Object.is(a[aIndex], b[bIndex]),\n    (nCommon, aCommon) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst commonItems = findCommonItems(\n  ['a', 'b', 'c', 'a', 'b', 'b', 'a'],\n  ['c', 'b', 'a', 'b', 'a', 'c'],\n);\n```\n\n| `i` | `commonItems[i]` | `aIndex` |\n| --: | :--------------- | -------: |\n| `0` | `'c'`            |      `2` |\n| `1` | `'b'`            |      `4` |\n| `2` | `'b'`            |      `5` |\n| `3` | `'a'`            |      `6` |\n\n## Example of callback functions to diff index intervals\n\nInstead of slicing array-like objects, you can adjust indexes in your callback functions.\n\n```js\n// Diff index intervals that are half open [start, end) like array slice method.\nconst diffIndexIntervals = (a, aStart, aEnd, b, bStart, bEnd) => {\n  // Validate: 0 <= aStart and aStart <= aEnd and aEnd <= a.length\n  // Validate: 0 <= bStart and bStart <= bEnd and bEnd <= b.length\n\n  diff(\n    aEnd - aStart,\n    bEnd - bStart,\n    (aIndex, bIndex) => Object.is(a[aStart + aIndex], b[bStart + bIndex]),\n    (nCommon, aCommon, bCommon) => {\n      // aStart + aCommon, bStart + bCommon\n    },\n  );\n\n  // After the last common subsequence, do any remaining work.\n};\n```\n\n## Example of callback functions to emulate diff command\n\nLinux or Unix has a `diff` command to compare files line by line. Its output is a **shortest edit script**:\n\n- **c**hange adjacent lines from the first file to lines from the second file\n- **d**elete lines from the first file\n- **a**ppend or insert lines from the second file\n\n```js\n// Given zero-based half-open range [start, end) of array indexes,\n// return one-based closed range [start + 1, end] as string.\nconst getRange = (start, end) =>\n  start + 1 === end ? `${start + 1}` : `${start + 1},${end}`;\n\n// Given index intervals of lines to delete or insert, or both, or neither,\n// push formatted diff lines onto array.\nconst pushDelIns = (aLines, aIndex, aEnd, bLines, bIndex, bEnd, array) => {\n  const deleteLines = aIndex !== aEnd;\n  const insertLines = bIndex !== bEnd;\n  const changeLines = deleteLines && insertLines;\n  if (changeLines) {\n    array.push(`${getRange(aIndex, aEnd)}c${getRange(bIndex, bEnd)}`);\n  } else if (deleteLines) {\n    array.push(`${getRange(aIndex, aEnd)}d${String(bIndex)}`);\n  } else if (insertLines) {\n    array.push(`${String(aIndex)}a${getRange(bIndex, bEnd)}`);\n  } else {\n    return;\n  }\n\n  for (; aIndex !== aEnd; aIndex += 1) {\n    array.push(`< ${aLines[aIndex]}`); // delete is less than\n  }\n\n  if (changeLines) {\n    array.push('---');\n  }\n\n  for (; bIndex !== bEnd; bIndex += 1) {\n    array.push(`> ${bLines[bIndex]}`); // insert is greater than\n  }\n};\n\n// Given content of two files, return emulated output of diff utility.\nconst findShortestEditScript = (a, b) => {\n  const aLines = a.split('\\n');\n  const bLines = b.split('\\n');\n  const aLength = aLines.length;\n  const bLength = bLines.length;\n\n  const isCommon = (aIndex, bIndex) => aLines[aIndex] === bLines[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    pushDelIns(aLines, aIndex, aCommon, bLines, bIndex, bCommon, array);\n    aIndex = aCommon + nCommon; // number of lines compared in a\n    bIndex = bCommon + nCommon; // number of lines compared in b\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  pushDelIns(aLines, aIndex, aLength, bLines, bIndex, bLength, array);\n\n  return array.length === 0 ? '' : `${array.join('\\n')}\\n`;\n};\n```\n\n## Example of callback functions to format diff lines\n\nHere is simplified code to format **changed and unchanged lines** in expected and received values after a test fails in Jest:\n\n```js\n// Format diff with minus or plus for change lines and space for common lines.\nconst formatDiffLines = (a, b) => {\n  // Jest depends on pretty-format package to serialize objects as strings.\n  // Unindented for comparison to avoid distracting differences:\n  const aLinesUn = format(a, {indent: 0 /*, other options*/}).split('\\n');\n  const bLinesUn = format(b, {indent: 0 /*, other options*/}).split('\\n');\n  // Indented to display changed and unchanged lines:\n  const aLinesIn = format(a, {indent: 2 /*, other options*/}).split('\\n');\n  const bLinesIn = format(b, {indent: 2 /*, other options*/}).split('\\n');\n\n  const aLength = aLinesIn.length; // Validate: aLinesUn.length === aLength\n  const bLength = bLinesIn.length; // Validate: bLinesUn.length === bLength\n\n  const isCommon = (aIndex, bIndex) => aLinesUn[aIndex] === bLinesUn[bIndex];\n\n  // Only because the GitHub Flavored Markdown doc collapses adjacent spaces,\n  // this example code and the following table represent spaces as middle dots.\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    for (; aIndex !== aCommon; aIndex += 1) {\n      array.push(`-·${aLinesIn[aIndex]}`); // delete is minus\n    }\n    for (; bIndex !== bCommon; bIndex += 1) {\n      array.push(`+·${bLinesIn[bIndex]}`); // insert is plus\n    }\n    for (; nCommon !== 0; nCommon -= 1, aIndex += 1, bIndex += 1) {\n      // For common lines, received indentation seems more intuitive.\n      array.push(`··${bLinesIn[bIndex]}`); // common is space\n    }\n  };\n\n  diff(aLength, bLength, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change lines.\n  for (; aIndex !== aLength; aIndex += 1) {\n    array.push(`-·${aLinesIn[aIndex]}`);\n  }\n  for (; bIndex !== bLength; bIndex += 1) {\n    array.push(`+·${bLinesIn[bIndex]}`);\n  }\n\n  return array;\n};\n\nconst expected = {\n  searching: '',\n  sorting: {\n    ascending: true,\n    fieldKey: 'what',\n  },\n};\nconst received = {\n  searching: '',\n  sorting: [\n    {\n      descending: false,\n      fieldKey: 'what',\n    },\n  ],\n};\n\nconst diffLines = formatDiffLines(expected, received);\n```\n\nIf N is the sum of lengths of sequences and L is length of a longest common subsequence, then N – L is length of an array of diff lines. In this example, N is 7 + 9, L is 5, and N – L is 11.\n\n|  `i` | `diffLines[i]`                     | `aIndex` | `bIndex` |\n| ---: | :--------------------------------- | -------: | -------: |\n|  `0` | `'··Object {'`                     |      `0` |      `0` |\n|  `1` | `'····\"searching\": \"\",'`           |      `1` |      `1` |\n|  `2` | `'-···\"sorting\": Object {'`        |      `2` |          |\n|  `3` | `'-·····\"ascending\": true,'`       |      `3` |          |\n|  `4` | `'+·····\"sorting\": Array ['`       |          |      `2` |\n|  `5` | `'+·······Object {'`               |          |      `3` |\n|  `6` | `'+·········\"descending\": false,'` |          |      `4` |\n|  `7` | `'··········\"fieldKey\": \"what\",'`  |      `4` |      `5` |\n|  `8` | `'········},'`                     |      `5` |      `6` |\n|  `9` | `'+·····],'`                       |          |      `7` |\n| `10` | `'··}'`                            |      `6` |      `8` |\n\n## Example of callback functions to find diff items\n\nHere is simplified code to find changed and unchanged substrings **within adjacent changed lines** in expected and received values after a test fails in Jest:\n\n```js\n// Return diff items for strings (compatible with diff-match-patch package).\nconst findDiffItems = (a, b) => {\n  const isCommon = (aIndex, bIndex) => a[aIndex] === b[bIndex];\n\n  let aIndex = 0;\n  let bIndex = 0;\n  const array = [];\n  const foundSubsequence = (nCommon, aCommon, bCommon) => {\n    if (aIndex !== aCommon) {\n      array.push([-1, a.slice(aIndex, aCommon)]); // delete is -1\n    }\n    if (bIndex !== bCommon) {\n      array.push([1, b.slice(bIndex, bCommon)]); // insert is 1\n    }\n\n    aIndex = aCommon + nCommon; // number of characters compared in a\n    bIndex = bCommon + nCommon; // number of characters compared in b\n    array.push([0, a.slice(aCommon, aIndex)]); // common is 0\n  };\n\n  diff(a.length, b.length, isCommon, foundSubsequence);\n\n  // After the last common subsequence, push remaining change items.\n  if (aIndex !== a.length) {\n    array.push([-1, a.slice(aIndex)]);\n  }\n  if (bIndex !== b.length) {\n    array.push([1, b.slice(bIndex)]);\n  }\n\n  return array;\n};\n\nconst expectedDeleted = ['\"sorting\": Object {', '\"ascending\": true,'].join(\n  '\\n',\n);\nconst receivedInserted = [\n  '\"sorting\": Array [',\n  'Object {',\n  '\"descending\": false,',\n].join('\\n');\n\nconst diffItems = findDiffItems(expectedDeleted, receivedInserted);\n```\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `0` |               `0` | `'\"sorting\": '`   |\n| `1` |               `1` | `'Array [\\n'`     |\n| `2` |               `0` | `'Object {\\n\"'`   |\n| `3` |              `-1` | `'a'`             |\n| `4` |               `1` | `'de'`            |\n| `5` |               `0` | `'scending\": '`   |\n| `6` |              `-1` | `'tru'`           |\n| `7` |               `1` | `'fals'`          |\n| `8` |               `0` | `'e,'`            |\n\nThe length difference `b.length - a.length` is equal to the sum of `diffItems[i][0]` values times `diffItems[i][1]` lengths. In this example, the difference `48 - 38` is equal to the sum `10`.\n\n| category of diff item | `[0]` |      `[1]` lengths | subtotal |\n| :-------------------- | ----: | -----------------: | -------: |\n| in common             |   `0` | `11 + 10 + 11 + 2` |      `0` |\n| to delete from `a`    |  `–1` |            `1 + 3` |     `-4` |\n| to insert from `b`    |   `1` |        `8 + 2 + 4` |     `14` |\n\nInstead of formatting the changed substrings with escape codes for colors in the `foundSubsequence` function to save memory, this example spends memory to **gain flexibility** before formatting, so a separate heuristic algorithm might modify the generic array of diff items to show changes more clearly:\n\n| `i` | `diffItems[i][0]` | `diffItems[i][1]` |\n| --: | ----------------: | :---------------- |\n| `6` |              `-1` | `'true'`          |\n| `7` |               `1` | `'false'`         |\n| `8` |               `0` | `','`             |\n\nFor expected and received strings of serialized data, the result of finding changed **lines**, and then finding changed **substrings** within adjacent changed lines (as in the preceding two examples) sometimes displays the changes in a more intuitive way than the result of finding changed substrings, and then splitting them into changed and unchanged lines.\n","types":"./build/index.d.ts","gitHead":"e267aff33d105399f2134bad7c8f82285104f3da","readmeFilename":"README.md","_nodeVersion":"20.11.1","_npmVersion":"lerna/3.2.1/node@v20.11.1+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/diff-sequences_30.0.0-alpha.3_1708427327880_0.9053451012319795"},"_hasShrinkwrap":false}},"time":{"created":"2022-11-21T18:11:07Z","modified":"2024-02-20T14:42:32Z","0.0.0":"2022-11-21T18:11:07Z","22.2.0":"2022-11-21T18:11:07Z","22.4.3":"2022-11-21T18:11:07Z","23.0.1":"2022-11-21T18:11:07Z","23.2.0":"2022-11-21T18:11:07Z","23.6.0":"2022-11-21T18:11:07Z","24.0.0-alpha.0":"2022-11-21T18:11:07Z","24.0.0-alpha.1":"2022-11-21T18:11:07Z","24.0.0-alpha.2":"2022-11-21T18:11:07Z","24.0.0-alpha.4":"2022-11-21T18:11:07Z","24.0.0-alpha.5":"2022-11-21T18:11:07Z","24.0.0-alpha.6":"2022-11-21T18:11:07Z","24.0.0-alpha.7":"2022-11-21T18:11:07Z","24.0.0-alpha.9":"2022-11-21T18:11:07Z","24.0.0-alpha.10":"2022-11-21T18:11:07Z","24.0.0-alpha.11":"2022-11-21T18:11:07Z","24.0.0-alpha.12":"2022-11-21T18:11:07Z","24.0.0-alpha.13":"2022-11-21T18:11:07Z","24.0.0-alpha.15":"2022-11-21T18:11:07Z","24.0.0-alpha.16":"2022-11-21T18:11:07Z","24.0.0":"2022-11-21T18:11:07Z","24.2.0-alpha.0":"2022-11-21T18:11:07Z","24.2.0":"2022-11-21T18:11:07Z","24.3.0":"2022-11-21T18:11:07Z","24.9.0":"2022-11-21T18:11:07Z","25.0.0":"2022-11-21T18:11:07Z","25.1.0":"2022-11-21T18:11:07Z","25.2.0-alpha.86":"2022-11-21T18:11:07Z","25.2.0":"2022-11-21T18:11:07Z","25.2.1-alpha.1":"2022-11-21T18:11:07Z","25.2.1-alpha.2":"2022-11-21T18:11:07Z","25.2.1":"2022-11-21T18:11:07Z","25.2.6":"2022-11-21T18:11:07Z","26.0.0-alpha.0":"2022-11-21T18:11:07Z","26.0.0":"2022-11-21T18:11:07Z","26.3.0":"2022-11-21T18:11:07Z","26.5.0":"2022-11-21T18:11:07Z","26.6.2":"2022-11-21T18:12:02Z","27.0.0-next.0":"2022-11-21T18:11:07Z","27.0.1":"2022-11-21T18:11:07Z","27.0.6":"2022-11-21T18:11:07Z","27.4.0":"2022-11-21T18:11:07Z","27.5.0":"2022-11-21T18:11:07Z","27.5.1":"2023-01-13T12:59:25Z","28.0.0-alpha.0":"2022-11-21T18:11:07Z","28.0.0-alpha.3":"2022-11-21T18:11:07Z","28.0.0-alpha.4":"2022-11-21T18:11:07Z","28.0.0-alpha.6":"2022-11-21T18:11:07Z","28.0.0-alpha.9":"2022-11-21T18:11:07Z","28.0.0":"2022-11-21T18:11:07Z","28.0.2":"2022-11-21T18:11:07Z","28.1.1":"2022-11-21T18:11:07Z","29.0.0-alpha.0":"2022-11-21T18:11:07Z","29.0.0-alpha.2":"2022-11-21T18:11:07Z","29.0.0-alpha.3":"2022-11-21T18:11:07Z","29.0.0":"2022-11-21T18:11:07Z","29.2.0":"2022-11-21T18:11:07Z","29.3.1":"2022-11-21T18:11:07Z","29.4.2":"2023-02-07T14:40:36Z","29.4.3":"2023-03-24T16:55:00Z","29.6.3":"2023-08-22T22:36:40Z","30.0.0-alpha.0":"2023-10-30T17:39:21Z","30.0.0-alpha.1":"2023-10-30T17:39:21Z","30.0.0-alpha.2":"2023-11-16T14:44:31Z","30.0.0-alpha.3":"2024-02-20T14:42:32Z"}}
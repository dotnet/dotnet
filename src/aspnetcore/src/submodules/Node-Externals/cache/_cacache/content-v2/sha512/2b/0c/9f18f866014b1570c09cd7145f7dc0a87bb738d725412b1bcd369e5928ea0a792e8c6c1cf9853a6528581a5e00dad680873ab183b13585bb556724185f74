{"_id":"minipass","_rev":"d58bef35-1b0a-4ce3-930a-488fd0ce7a02","name":"minipass","dist-tags":{"latest":"7.0.4","legacy-v4":"4.2.8"},"versions":{"1.0.0":{"_id":"minipass@1.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"0ca84f7235109ffe3a8e459cb14d7d6bc3119a67","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.0.0.tgz"},"gitHead":"6e91377e7c076f768c2cfd556f365090717d249b","_from":".","_npmVersion":"4.3.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-1.0.0.tgz_1489450315564_0.20009294734336436"}},"1.0.1":{"_id":"minipass@1.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"ca57afde318b5ba9e059a7e64844baa53cdb4034","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.0.1.tgz"},"gitHead":"2ee0d11bc4ed89dda4892cffe92718190e4aa4ef","_from":".","_npmVersion":"4.4.2","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.0.1.tgz_1490142376611_0.3365593715570867"}},"1.0.2":{"_id":"minipass@1.0.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.0.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c2169e3f3ac2119f6e128ad860c679bf9854c0ec","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.0.2.tgz"},"gitHead":"bbd2607d80a77b3b2e880f065552ada47089f6f2","_from":".","_npmVersion":"4.4.2","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.0.2.tgz_1490157604381_0.3243618570268154"}},"1.1.0":{"_id":"minipass@1.1.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"a0bac558ae88e5f2652b2dea6b80e77aecdbe5be","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.0.tgz"},"gitHead":"5ff9f9e0394a3f997072e347204b0c2deea48d58","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.0.tgz_1490681589971_0.4406989624258131"}},"1.1.1":{"_id":"minipass@1.1.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"e5c6a6a64562e6038330d2d46694f660e7ebeed1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.1.tgz"},"gitHead":"27bbc0c5d090f3deff5836aeb43b20e115e874fd","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-1.1.1.tgz_1490684781086_0.2492500205989927"}},"1.1.2":{"_id":"minipass@1.1.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"83b490887b77c95f3049a1083403e16d3c0be6fa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.2.tgz"},"gitHead":"a226cbecaec3f354e7d3d3c68918d8d4ad552690","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.2.tgz_1490688898041_0.4253221561666578"}},"1.1.3":{"_id":"minipass@1.1.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"ed16a0d8585a2e67fe0762352e8cf9110c125427","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.3.tgz"},"gitHead":"852e03965a06911ff7f650b9d9d502e1a649c785","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-1.1.3.tgz_1490749088000_0.1479788450524211"}},"1.1.4":{"_id":"minipass@1.1.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c8801d72c80981c0e29e59d10e18cd15cadc927d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.4.tgz"},"gitHead":"b9cb84b174cd7295eada68d071a590d4f0c47642","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.4.tgz_1490750723304_0.5657442165538669"}},"1.1.5":{"_id":"minipass@1.1.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"b7a2293b9cc7a123f4878581b8e139693a39891b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.5.tgz"},"gitHead":"0232f2585e43297c6b5c15b36453ab6d43183be3","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.5.tgz_1490768335439_0.06365093612112105"}},"1.1.6":{"_id":"minipass@1.1.6","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.6","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"0dde63c08a781ad3f72ee2ba68f1cc23012b8944","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.6.tgz"},"gitHead":"8e1550a1fc92eea4cf4266782daf5c66682e22a9","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.6.tgz_1490770011445_0.6162307255435735"}},"1.1.7":{"_id":"minipass@1.1.7","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.7","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"8e800c24c61e49e1424d8c367855509df550f453","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.7.tgz"},"gitHead":"88b390364333585399e82bcac5878a56b42b9e90","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.7.tgz_1491250866481_0.022621459094807506"}},"1.1.8":{"_id":"minipass@1.1.8","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.8","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"70f2d1ec93c9f11613b6150529e9e1571e562b5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.8.tgz"},"gitHead":"cfc08d331585f233a0a513a15f9eb0804cdc814c","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.8.tgz_1491846777505_0.5472147725522518"}},"1.1.9":{"_id":"minipass@1.1.9","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.9","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"5fc44fce0b7f1a1f0c27418ec2fa4127f31bb1dc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.9.tgz"},"gitHead":"374dee67e86ca47b79573ed70a642ab20ae50853","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.9.tgz_1492830145534_0.7150215269066393"}},"1.1.10":{"_id":"minipass@1.1.10","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.10","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"cb0f3810d3380435597763069693b1c72f219eb2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.10.tgz"},"gitHead":"939c3e089af81de898e715151b11ac4cdb3f2887","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-1.1.10.tgz_1493340043913_0.4495376900304109"}},"1.1.11":{"_id":"minipass@1.1.11","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.1.11","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"0780ea6f54a04253e680eace2602302fc123af53","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.1.11.tgz"},"gitHead":"ce4800e752946d0dd11b4779123da0d9f5bb6930","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.1.11.tgz_1493519761127_0.9377385785337538"}},"1.2.0":{"_id":"minipass@1.2.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"1.2.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"1f4af9c2803921d3035de8aa19443aa5860fea7c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-1.2.0.tgz"},"gitHead":"e133c4120ae4ab18acc2cd468bd5668f499054cd","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-1.2.0.tgz_1493525670102_0.469406632008031"}},"2.0.0":{"_id":"minipass@2.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"e095385c8e8a89be8b2577c7b09ffa91e091fa02","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.0.0.tgz"},"gitHead":"81ddd48d09008cea36adaa7b2d307cb181901140","_from":".","_npmVersion":"4.5.0","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/minipass-2.0.0.tgz_1493884792228_0.924768059514463"}},"2.0.1":{"_id":"minipass@2.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"9ce4b0ce5b065eb2e5e2e20687e7e1d43579ef78","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.0.1.tgz"},"gitHead":"d029efb88726070e7c18c61259021e46efb1b8b1","_npmVersion":"5.0.0-beta.33","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-2.0.1.tgz_1493930811196_0.312193572986871"}},"2.0.2":{"_id":"minipass@2.0.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.0.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"fae5c78124051f56fd2007df0012e0dac7a752ce","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.0.2.tgz"},"gitHead":"b18627e376d16f9188cd4049efb8febacf8b2fa2","_npmVersion":"5.0.0-beta.44","_nodeVersion":"8.0.0-pre","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/minipass-2.0.2.tgz_1494436039082_0.553761099698022"}},"2.1.0":{"_id":"minipass@2.1.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.1.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"a25f21dd72a2b8e715ea5c784aa0dbd703759ef7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.1.0.tgz"},"gitHead":"7c67ec39540408cc404bac8d96e8bdf572cc641f","_npmVersion":"5.0.3","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass-2.1.0.tgz_1497457050581_0.37674622470512986"}},"2.1.1":{"_id":"minipass@2.1.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.1.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"10","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c80c80a3491c180d4071d8f219bd1b4b0284999d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.1.1.tgz"},"gitHead":"cc4d17e603adf90567fc0e0da2cf0b9cfb43d72b","_npmVersion":"5.0.3","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass-2.1.1.tgz_1497457610522_0.42575242393650115"}},"2.2.0":{"_id":"minipass@2.2.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.2.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^10.7.0","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c0db6c9d8ec7609e5a98b40a01bb229b803c961d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.2.0.tgz"},"gitHead":"277abefa0edbac568083d05b2d7130bc768ed552","_npmVersion":"5.1.0","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass-2.2.0.tgz_1499577467556_0.7973325287457556"}},"2.2.1":{"_id":"minipass@2.2.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.2.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^10.7.0","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"5ada97538b1027b4cf7213432428578cb564011f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.2.1.tgz"},"gitHead":"7b7d9ad23f01dd0a6347f66a8441cb2dbc0abcec","_npmVersion":"5.1.0","_nodeVersion":"8.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass-2.2.1.tgz_1499663387972_0.7067792634479702"}},"2.2.2":{"_id":"minipass@2.2.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.2.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^10.7.0","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"26feb237462d235ed8b6542abf36fe019490063a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.2.2.tgz"},"gitHead":"ba027488f63fc7de95ccf1ef770901693ae14c2f","_npmVersion":"5.7.1","_nodeVersion":"8.9.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.2.2_1521563006537_0.0684973195384373"},"_hasShrinkwrap":false},"2.2.3":{"_id":"minipass@2.2.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.2.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^10.7.0","through2":"^2.0.3"},"dependencies":{"yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"cf0ec79c88cd3880da991a9c376a77fe1140ed63","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.2.3.tgz"},"gitHead":"8af41a48a2ca01dc857003d650dd74765e950e03","_npmVersion":"5.7.1","_nodeVersion":"8.9.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.2.3_1521563195774_0.8260329475137804"},"_hasShrinkwrap":false},"2.2.4":{"_id":"minipass@2.2.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.2.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^10.7.0","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.1","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"03c824d84551ec38a8d1bb5bc350a5a30a354a40","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.2.4.tgz"},"gitHead":"73cf8431e3678b27083e353b8ef0a6bfab84650c","_npmVersion":"5.7.1","_nodeVersion":"8.9.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.2.4_1521564268128_0.1298490999080657"},"_hasShrinkwrap":false},"2.3.0":{"_id":"minipass@2.3.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^11.1.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.1","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"2e11b1c46df7fe7f1afbe9a490280add21ffe384","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.0.tgz"},"gitHead":"bcb7f538847de6d30af0c8e83933af7cade2cc58","_npmVersion":"5.6.0","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.0_1525629147927_0.7791628235820471"},"_hasShrinkwrap":false},"2.3.1":{"_id":"minipass@2.3.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^11.1.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.1","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"4e872b959131a672837ab3cb554962bc84b1537d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.1.tgz"},"gitHead":"df22eac41ed1d11e9f7bd2903f88f021cc34f27f","_npmVersion":"6.0.1","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.1_1526685947485_0.8626022137673797"},"_hasShrinkwrap":false},"2.3.2":{"_id":"minipass@2.3.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^11.1.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.1","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"2bb00e836f1f8d44573f96b08c4f440b330072e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.2.tgz"},"gitHead":"77971fac31a26cada594071e82cadfdfdd4949f3","_npmVersion":"6.0.1","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.2_1526960561378_0.7850614237575084"},"_hasShrinkwrap":false},"2.3.3":{"_id":"minipass@2.3.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^12.0.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"a7dcc8b7b833f5d368759cce544dccb55f50f233","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.3.tgz"},"gitHead":"eb6835c4199e205fae9ae48c5340ff4b3edca60e","_npmVersion":"6.0.1","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.3_1527015575005_0.7372253058813618"},"_hasShrinkwrap":false},"2.3.4":{"_id":"minipass@2.3.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^12.0.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"4768d7605ed6194d6d576169b9e12ef71e9d9957","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.4.tgz"},"gitHead":"6b2713ffe4871849d232caca4f05d390cfcb93dc","_npmVersion":"6.3.0","_nodeVersion":"10.0.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.4_1533918321682_0.4793462682470073"},"_hasShrinkwrap":false},"2.3.5":{"_id":"minipass@2.3.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.3.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^12.0.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"cacebe492022497f656b0f0f51e2682a9ed2d848","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.3.5.tgz"},"gitHead":"d362cb255c2b2ad24b0b6bf8cef35c522ba29019","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.3.5_1540331177990_0.793403052371799"},"_hasShrinkwrap":false},"2.4.0":{"_id":"minipass@2.4.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.4.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --all; git push origin --tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^12.0.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"38f0af94f42fb6f34d3d7d82a90e2c99cd3ff485","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.4.0.tgz"},"gitHead":"565ebb363ae2b6720fe4d0795aed96ba90f059d7","_nodeVersion":"12.8.1","_npmVersion":"6.11.1","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.4.0_1566578162152_0.5234555613255545"},"_hasShrinkwrap":false},"2.5.0":{"_id":"minipass@2.5.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.5.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"dddb1d001976978158a05badfcbef4a771612857","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.5.0.tgz"},"gitHead":"fab29874f70b04730c864ac52136a7a01bd1801c","_nodeVersion":"12.8.1","_npmVersion":"6.11.2","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.5.0_1567034403527_0.5492616475869285"},"_hasShrinkwrap":false},"2.5.1":{"_id":"minipass@2.5.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.5.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"cf435a9bf9408796ca3a3525a8b851464279c9b8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.5.1.tgz"},"gitHead":"43f76e2a9dfaccd1b6cc1f93c4130a849df29523","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.5.1_1568064840586_0.8526816449859596"},"_hasShrinkwrap":false},"2.6.0":{"_id":"minipass@2.6.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"80a68c8a43257b7f744ce09733f6a9c6eef9f731","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.0.tgz"},"gitHead":"f55f91cdda83c20552e431be8fb5ed1daed23ea4","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.0_1568614365824_0.06329190526617268"},"_hasShrinkwrap":false},"2.6.1":{"_id":"minipass@2.6.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"5f44a94f0d0cd1a347fd65274f32122f68b76acd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.1.tgz"},"gitHead":"78150126c62caef9e2f2d59e33ce6101adbaf95b","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.1_1568667348804_0.059379787938716344"},"_hasShrinkwrap":false},"2.6.2":{"_id":"minipass@2.6.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c3075a22680b3b1479bae5915904cb1eba50f5c0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.2.tgz"},"gitHead":"61a76c19b9cd2159c0784585a77d50645bdfe2d4","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.2_1568671093262_0.8670196477368928"},"_hasShrinkwrap":false},"2.6.3":{"_id":"minipass@2.6.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"3ac4ae0fc8835946fdf6d2480659e98e17e88424","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.3.tgz"},"gitHead":"0e5cd3265fd37d33ffd2474868d20fd529e40519","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.3_1568731016405_0.9743197614232673"},"_hasShrinkwrap":false},"2.6.4":{"_id":"minipass@2.6.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c15b8e86d1ecee001652564a2c240c0b6e58e817","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.4.tgz"},"gitHead":"e3b7320555e1d7a258bda1987e205ed72c623305","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.4_1568737215637_0.8029580992745486"},"_hasShrinkwrap":false},"2.6.5":{"_id":"minipass@2.6.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.6.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"1c245f9f2897f70fd4a219066261ce6c29f80b18","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.6.5.tgz"},"gitHead":"eb03b7ad760791ebb727a393a1056aab490e45ba","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.6.5_1568758710901_0.00493985783646278"},"_hasShrinkwrap":false},"2.7.0":{"_id":"minipass@2.7.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.7.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap test/*.js --100","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.1","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"c01093a82287c8331f08f1075499fef124888796","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.7.0.tgz"},"gitHead":"6e1486f21bc805f98221d1ab07969b39a498a79d","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.7.0_1569134359593_0.6757777043008619"},"_hasShrinkwrap":false},"2.8.0":{"_id":"minipass@2.8.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"63eb51b46697cbaeb75158ae00cf4f95fb3d88e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.0.tgz"},"tap":{"check-coverage":true},"gitHead":"8cfe8502b45c48bdd3df7ced13a726f0e69f345a","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.0_1569196592923_0.383813049498406"},"_hasShrinkwrap":false},"2.8.1":{"_id":"minipass@2.8.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"a73bdc84cad62e8e6c8d56eba1302a5fe04c5910","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.1.tgz"},"tap":{"check-coverage":true},"gitHead":"f193f5cf35b3b04d434c0b1cea954928842b3770","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.1_1569197083493_0.4502391094175884"},"_hasShrinkwrap":false},"2.8.2":{"_id":"minipass@2.8.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"17ce3a7ecac3bdb8cafc9caf311e9176e6c840db","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.2.tgz"},"tap":{"check-coverage":true},"gitHead":"320eb57f38b3e03965e761efa878ef11ae6afea0","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.2_1569257837761_0.27577167683323145"},"_hasShrinkwrap":false},"2.8.3":{"_id":"minipass@2.8.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"aa87cf674150a1b3c8e278c5f5937d1d3d02b955","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.3.tgz"},"tap":{"check-coverage":true},"gitHead":"549cb9a7f8bad5346e5855ceb6d5e702a6e6049f","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.3_1569264510349_0.9347850990046873"},"_hasShrinkwrap":false},"2.8.4":{"_id":"minipass@2.8.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"490fe62adeb620c4a3373f62ee1c31cf2ef36385","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.4.tgz"},"tap":{"check-coverage":true},"gitHead":"b49a11897700937c425ec1439ec1af2c055b16a8","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.4_1569287012744_0.2723172970443315"},"_hasShrinkwrap":false},"2.8.5":{"_id":"minipass@2.8.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"072f3c67b1f05fe4703f58a3c38e186c03a17692","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.5.tgz"},"tap":{"check-coverage":true},"gitHead":"5718d456b6bc535febe3b3f52168fa8b2acada04","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.5_1569311764545_0.23634394433582018"},"_hasShrinkwrap":false},"2.8.6":{"_id":"minipass@2.8.6","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.8.6","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.4","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"main":"index.js","dist":{"shasum":"620d889ace26356391d010ecb9458749df9b6db5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.8.6.tgz"},"tap":{"check-coverage":true},"gitHead":"8243e5efd6a058d28479a66e40ab3aba0207cb76","_nodeVersion":"12.8.1","_npmVersion":"6.11.3","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_2.8.6_1569342147428_0.013183884532681267"},"_hasShrinkwrap":false},"2.9.0":{"_id":"minipass@2.9.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"2.9.0","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":null,"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"safe-buffer":"^5.1.2","yallist":"^3.0.0"},"files":["index.js"],"main":"index.js","dist":{"shasum":"e713762e7d3e32fed803115cf93e04bca9fcc9a6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-2.9.0.tgz"},"tap":{"check-coverage":true}},"3.0.0":{"_id":"minipass@3.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"adb830268348df8b32217ceda3fc48684faff232","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.0.0.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports pipe()ing (including multi-pipe() and backpressure\ntransmission), buffering data until either a `data` event handler or\n`pipe()` is added (so you don't lose the first chunk), and most other\ncases where PassThrough is a good idea.\n\nThere is a `read()` method, but it's much more efficient to consume\ndata from this stream via `'data'` events or by calling `pipe()` into\nsome other stream.  Calling `read()` requires the buffer to be\nflattened in some cases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is\nno stopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written\nwill be emitted.  Otherwise, it'll do a minimal amount of Buffer\ncopying to ensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform\nthe data, it just passes it right through.  If you want to transform\nthe data, extend the class, and override the `write()` method.  Once\nyou're done transforming the data however you want, call\n`super.write()` with the transform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap)\n- [treport](http://npm.im/tap)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with noode-core streams and\nintend to use Minipass streams in your programs.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nThe solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nstream.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you want.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in\n  \"flowing\" mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the\n  stream.  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is\n  all discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.\n  Some events are given special treatment, however.  (See below under\n  \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the\n  stream emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a\n  single Buffer object.  Will reject the returned promise if the stream is\n  in objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in\nplatforms that support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with\nno flattening, create the stream with the `{ objectMode: true }`\noption.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i --> 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      let parsed\n      try {\n        super.write(parsed)\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"76ac42b7ffa1bd3cc2f669d828ec5aedf74ad6f5","_nodeVersion":"12.8.1","_npmVersion":"6.12.0-next.0","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.0.0_1569874565676_0.7731705094606287"},"_hasShrinkwrap":false},"3.0.1":{"_id":"minipass@3.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"b4fec73bd61e8a40f0b374ddd04260ade2c8ec20","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.0.1.tgz"},"tap":{"check-coverage":true},"gitHead":"603b8116ea11af26b43f2f2d0888edad77696b4f","_nodeVersion":"12.8.1","_npmVersion":"6.12.0-next.0","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.0.1_1570034097465_0.9922015990068342"},"_hasShrinkwrap":false},"3.1.0":{"_id":"minipass@3.1.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"c08b140a0d5e8b6c6034056f7a168a3f5441df3b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.0.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports pipe()ing (including multi-pipe() and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is no\nstopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap)\n- [treport](http://npm.im/tap)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with noode-core streams and\nintend to use Minipass streams in your programs.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nThe solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nstream.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i --> 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      let parsed\n      try {\n        super.write(parsed)\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"4a5f1c26a1881fb3370d9c28ea9bdefc6a3eb402","_nodeVersion":"12.12.0","_npmVersion":"6.12.0","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.1.0_1571547208516_0.163407317672416"},"_hasShrinkwrap":false},"3.1.1":{"_id":"minipass@3.1.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"7607ce778472a185ad6d89082aa2070f79cedcd5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.1.tgz"},"tap":{"check-coverage":true},"gitHead":"0e866597838dadaf8dcfd7872ab8951f3c8ba3c0","_nodeVersion":"12.12.0","_npmVersion":"6.12.0","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"ahmad@ahmadnassri.com","name":"ahmadnassri"},{"email":"anne@npmjs.com","name":"annekimsey"},{"email":"billatnpm@gmail.com","name":"billatnpm"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"mike@mikecorp.ca","name":"mikemimik"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.1.1_1571952897280_0.4106563063011017"},"_hasShrinkwrap":false},"3.1.2":{"_id":"minipass@3.1.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"74bce7f1b9624236dc8d374a49910181f9eb3600","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.2.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports pipe()ing (including multi-pipe() and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is no\nstopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap)\n- [treport](http://npm.im/tap)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with noode-core streams and\nintend to use Minipass streams in your programs.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nThe solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nstream.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i --> 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      let parsed\n      try {\n        super.write(parsed)\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"41ec3d09cb8034cbfc471b802269dc4a684aa0c3","_nodeVersion":"14.2.0","_npmVersion":"6.14.4","maintainers":[{"email":"evilpacket@gmail.com","name":"adam_baldwin"},{"email":"cghr1990@gmail.com","name":"claudiahdz"},{"email":"darcy@darcyclarke.me","name":"darcyclarke"},{"email":"i@izs.me","name":"isaacs"},{"email":"ruyadorno@hotmail.com","name":"ruyadorno"}],"_npmUser":{"name":"isaacs","email":"i@izs.me"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.1.2_1589057952720_0.49020973461025363"},"_hasShrinkwrap":false},"3.1.3":{"_id":"minipass@3.1.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.3","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":null,"devDependencies":{"end-of-stream":"^1.4.0","tap":"^14.6.5","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"files":["index.js"],"main":"index.js","dist":{"shasum":"7d42ff1f39635482e15f9cdb53184deebd5815fd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.3.tgz"},"tap":{"check-coverage":true}},"3.1.4":{"_id":"minipass@3.1.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^15.0.9","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"bd5a9b097a326977e84a6ff1a824f322c516ab84","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.4.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is no\nstopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nThe solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"bb90f266f391b77b07c0a241384cbe0f705eb38e","_nodeVersion":"16.5.0","_npmVersion":"7.23.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"isaacs","email":"i@izs.me"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"ruyadorno","email":"ruyadorno@hotmail.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.1.4_1631630349451_0.8024518838544734"},"_hasShrinkwrap":false},"3.1.5":{"_id":"minipass@3.1.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^15.0.9","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"71f6251b0a33a49c01b3cf97ff77eda030dff732","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.5.tgz"},"tap":{"check-coverage":true},"gitHead":"9bfcf550f7f71667294c0f3a75458347020754ff","_nodeVersion":"16.5.0","_npmVersion":"7.23.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"isaacs","email":"i@izs.me"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"ruyadorno","email":"ruyadorno@hotmail.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.1.5_1631648199111_0.4963903964208507"},"_hasShrinkwrap":false},"3.1.6":{"_id":"minipass@3.1.6","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.1.6","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":null,"devDependencies":{"end-of-stream":"^1.4.0","tap":"^15.0.9","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"files":["index.js"],"main":"index.js","dist":{"shasum":"3b8150aa688a711a1521af5e8779c1d3bb4f45ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.1.6.tgz"},"tap":{"check-coverage":true}},"3.2.0":{"_id":"minipass@3.2.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.2.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^16.2.0","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"cee61ecabea6634b5706139b0195794103e70af9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.2.0.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is no\nstopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"b5962821660cfa51f570fa5c2aeb8373d98b2270","_nodeVersion":"18.2.0","_npmVersion":"8.9.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"ruyadorno","email":"ruyadorno@hotmail.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.2.0_1654708980407_0.8034251288290672"},"_hasShrinkwrap":false},"3.2.1":{"_id":"minipass@3.2.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.2.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"end-of-stream":"^1.4.0","tap":"^16.2.0","through2":"^2.0.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"12ac0ab289be638db0ad8887b28413b773355c13","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.2.1.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is no\nstopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  There is no way\n  to unpipe.  When data is emitted, it is immediately written to any and\n  all pipe destinations.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"readmeFilename":"README.md","gitHead":"547db2981c1c301c9552f3158ccad13c1a106cfc","_nodeVersion":"18.2.0","_npmVersion":"8.9.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"ruyadorno","email":"ruyadorno@hotmail.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.2.1_1654886549880_0.8924112603311831"},"_hasShrinkwrap":false},"3.3.0":{"_id":"minipass@3.3.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"9bb11578125d483c45c8debd14f2a1be8ea82bab","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.0.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n* `async` Defaults to `false`.  Set to `true` to defer data\n  emission until next tick.  This reduces performance slightly,\n  but makes Minipass streams use timing behavior closer to Node\n  core streams.  See [Timing](#timing) for more details.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  When\n  data is emitted, it is immediately written to any and all pipe\n  destinations.  (Or written on next tick in `async` mode.)\n* `unpipe(dest)` - Stop piping to the destination stream.  This\n  is immediate, meaning that any asynchronously queued data will\n  _not_ make it to the destination when running in `async` mode.\n    * `options.end` - Boolean, end the destination stream when\n      the source stream ends.  Default `true`.\n    * `options.proxyErrors` - Boolean, proxy `error` events from\n      the source stream to the destination stream.  Note that\n      errors are _not_ proxied after the pipeline terminates,\n      either due to the source emitting `'end'` or manually\n      unpiping with `src.unpipe(dest)`.  Default `false`.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"types":"./index.d.ts","readmeFilename":"README.md","gitHead":"80662a0ddf9e3795ec0e4d773aa2c9f34bc0dbd1","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.3.0_1655691362014_0.542472729959655"},"_hasShrinkwrap":false},"3.3.1":{"_id":"minipass@3.3.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"8959f676c7ed669334a2db4d8dd980c2c6d8e55c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.1.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n* `async` Defaults to `false`.  Set to `true` to defer data\n  emission until next tick.  This reduces performance slightly,\n  but makes Minipass streams use timing behavior closer to Node\n  core streams.  See [Timing](#timing) for more details.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  When\n  data is emitted, it is immediately written to any and all pipe\n  destinations.  (Or written on next tick in `async` mode.)\n* `unpipe(dest)` - Stop piping to the destination stream.  This\n  is immediate, meaning that any asynchronously queued data will\n  _not_ make it to the destination when running in `async` mode.\n    * `options.end` - Boolean, end the destination stream when\n      the source stream ends.  Default `true`.\n    * `options.proxyErrors` - Boolean, proxy `error` events from\n      the source stream to the destination stream.  Note that\n      errors are _not_ proxied after the pipeline terminates,\n      either due to the source emitting `'end'` or manually\n      unpiping with `src.unpipe(dest)`.  Default `false`.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"types":"./index.d.ts","readmeFilename":"README.md","gitHead":"d65917f5e5f592f0a9454b057f69c6abcff974ec","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.3.1_1655693530623_0.9527395009725081"},"_hasShrinkwrap":false},"3.3.2":{"_id":"minipass@3.3.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"7be1929b2963b08f889b8426098f9af92e08f279","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.2.tgz"},"tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"types":"./index.d.ts","gitHead":"3802694369561391f1908f93c56420e5a8b1cca5","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.3.2_1655693845957_0.25637305163514035"},"_hasShrinkwrap":false},"3.3.3":{"_id":"minipass@3.3.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"fd1f0e6c06449c10dadda72618b59c00f3d6378d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.3.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n* `async` Defaults to `false`.  Set to `true` to defer data\n  emission until next tick.  This reduces performance slightly,\n  but makes Minipass streams use timing behavior closer to Node\n  core streams.  See [Timing](#timing) for more details.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  When\n  data is emitted, it is immediately written to any and all pipe\n  destinations.  (Or written on next tick in `async` mode.)\n* `unpipe(dest)` - Stop piping to the destination stream.  This\n  is immediate, meaning that any asynchronously queued data will\n  _not_ make it to the destination when running in `async` mode.\n    * `options.end` - Boolean, end the destination stream when\n      the source stream ends.  Default `true`.\n    * `options.proxyErrors` - Boolean, proxy `error` events from\n      the source stream to the destination stream.  Note that\n      errors are _not_ proxied after the pipeline terminates,\n      either due to the source emitting `'end'` or manually\n      unpiping with `src.unpipe(dest)`.  Default `false`.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"types":"./index.d.ts","readmeFilename":"README.md","gitHead":"af6d2aeaa9254f547675f82cbde18aebf0126960","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.3.3_1655696330262_0.271118571703173"},"_hasShrinkwrap":false},"3.3.4":{"_id":"minipass@3.3.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.4","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":null,"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"files":["index.d.ts","index.js"],"main":"index.js","dist":{"shasum":"ca99f95dd77c43c7a76bf51e6d200025eee0ffae","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.4.tgz"},"tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"}},"3.3.5":{"_id":"minipass@3.3.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish --tag=next","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"6da7e53a48db8a856eeb9153d85b230a2119e819","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.5.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure transmission),\nbuffering data until either a `data` event handler or `pipe()` is added (so\nyou don't lose the first chunk), and most other cases where PassThrough is\na good idea.\n\nThere is a `read()` method, but it's much more efficient to consume data\nfrom this stream via `'data'` events or by calling `pipe()` into some other\nstream.  Calling `read()` requires the buffer to be flattened in some\ncases, which requires copying memory.\n\nIf you set `objectMode: true` in the options, then whatever is written will\nbe emitted.  Otherwise, it'll do a minimal amount of Buffer copying to\nensure proper Streams semantics when `read(n)` is called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`, or by\nwriting any non-string/non-buffer data.  `objectMode` cannot be set to\nfalse once it is set.\n\nThis is not a `through` or `through2` stream.  It doesn't transform the\ndata, it just passes it right through.  If you want to transform the data,\nextend the class, and override the `write()` method.  Once you're done\ntransforming the data however you want, call `super.write()` with the\ntransform output.\n\nFor some examples of streams that extend Minipass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core streams and\nintend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\nExample:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ async: true })\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\nconst Minipass = require('minipass')\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled.  Example:\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written all the way\nthrough the pipeline, and `write()` always returns true/false based on\nwhether the data was fully flushed, backpressure is communicated\nimmediately to the upstream caller.  This minimizes buffering.\n\nConsider this case:\n\n```js\nconst {PassThrough} = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage, and\nmultiple event deferrals happened, for an unblocked pipeline where it was\nperfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead someone reading\nthe code to think an advisory maximum of 1KiB is being set for the\npipeline.  However, the actual advisory buffering level is the _sum_ of\n`highWaterMark` values, since each one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data written,\nor _ever_ buffer data that can be flushed all the way through.  Neither\nnode-core streams nor Minipass ever fail to buffer written data, but\nnode-core streams do a lot of unnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less stuff and\nwaits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing any data\ninto it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't want to\npotentially happen immediately (for example, closing file descriptors,\nmoving on to the next entry in an archive parse stream, etc.) then be sure\nto call `stream.pause()` on creation, and then `stream.resume()` once you\nare ready to respond to the `end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not yet have had\na chance to add a listener.  In order to avoid this hazard, Minipass\nstreams safely re-emit the `'end'` event if a new listener is added after\n`'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will call the handler right away.  (You can think of\nthis somewhat like attaching a new `.then(fn)` to a previously-resolved\nPromise.)\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream.  If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data through the\npipeline when a new pipe destination is added, this can have surprising\neffects, especially when a stream comes in from some other function and may\nor may not have data in its buffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that pipes to\nboth locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners.  The first one\nadded will _immediately_ receive all of the data, leaving nothing for the\nsecond:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards.  Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream!  Use it like a stream and it'll most likely do what you\nwant.\n\n```js\nconst Minipass = require('minipass')\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n* `encoding` How would you like the data coming _out_ of the stream to be\n  encoded?  Accepts any values that can be passed to `Buffer.toString()`.\n* `objectMode` Emit data exactly as it comes in.  This will be flipped on\n  by default if you write() something other than a string or Buffer at any\n  point.  Setting `objectMode: true` will prevent setting any encoding\n  value.\n* `async` Defaults to `false`.  Set to `true` to defer data\n  emission until next tick.  This reduces performance slightly,\n  but makes Minipass streams use timing behavior closer to Node\n  core streams.  See [Timing](#timing) for more details.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and `Writable`\nstreams.\n\n### Methods\n\n* `write(chunk, [encoding], [callback])` - Put data in.  (Note that, in the\n  base Minipass class, the same data will come out.)  Returns `false` if\n  the stream will buffer the next write, or true if it's still in \"flowing\"\n  mode.\n* `end([chunk, [encoding]], [callback])` - Signal that you have no more\n  data to write.  This will queue an `end` event to be fired when all the\n  data has been consumed.\n* `setEncoding(encoding)` - Set the encoding for data coming of the stream.\n  This can only be done once.\n* `pause()` - No more data for a while, please.  This also prevents `end`\n  from being emitted for empty streams until the stream is resumed.\n* `resume()` - Resume the stream.  If there's data in the buffer, it is all\n  discarded.  Any buffered events are immediately emitted.\n* `pipe(dest)` - Send all output to the stream provided.  When\n  data is emitted, it is immediately written to any and all pipe\n  destinations.  (Or written on next tick in `async` mode.)\n* `unpipe(dest)` - Stop piping to the destination stream.  This\n  is immediate, meaning that any asynchronously queued data will\n  _not_ make it to the destination when running in `async` mode.\n    * `options.end` - Boolean, end the destination stream when\n      the source stream ends.  Default `true`.\n    * `options.proxyErrors` - Boolean, proxy `error` events from\n      the source stream to the destination stream.  Note that\n      errors are _not_ proxied after the pipeline terminates,\n      either due to the source emitting `'end'` or manually\n      unpiping with `src.unpipe(dest)`.  Default `false`.\n* `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are EventEmitters.  Some\n  events are given special treatment, however.  (See below under \"events\".)\n* `promise()` - Returns a Promise that resolves when the stream emits\n  `end`, or rejects if the stream emits `error`.\n* `collect()` - Return a Promise that resolves on `end` with an array\n  containing each chunk of data that was emitted, or rejects if the stream\n  emits `error`.  Note that this consumes the stream data.\n* `concat()` - Same as `collect()`, but concatenates the data into a single\n  Buffer object.  Will reject the returned promise if the stream is in\n  objectMode, or if it goes into objectMode by the end of the data.\n* `read(n)` - Consume `n` bytes of data out of the buffer.  If `n` is not\n  provided, then consume all of it.  If `n` bytes are not available, then\n  it returns null.  **Note** consuming streams in this way is less\n  efficient, and can lead to unnecessary Buffer copying.\n* `destroy([er])` - Destroy the stream.  If an error is provided, then an\n  `'error'` event is emitted.  If the stream has a `close()` method, and\n  has not emitted a `'close'` event yet, then `stream.close()` will be\n  called.  Any Promises returned by `.promise()`, `.collect()` or\n  `.concat()` will be rejected.  After being destroyed, writing to the\n  stream will emit an error.  No more data will be emitted if the stream is\n  destroyed, even if it was previously buffered.\n\n### Properties\n\n* `bufferLength` Read-only.  Total number of bytes buffered, or in the case\n  of objectMode, the total number of objects.\n* `encoding` The encoding that has been set.  (Setting this is equivalent\n  to calling `setEncoding(enc)` and has the same prohibition against\n  setting multiple times.)\n* `flowing` Read-only.  Boolean indicating whether a chunk written to the\n  stream will be immediately emitted.\n* `emittedEnd` Read-only.  Boolean indicating whether the end-ish events\n  (ie, `end`, `prefinish`, `finish`) have been emitted.  Note that\n  listening on any end-ish event will immediateyl re-emit it if it has\n  already been emitted.\n* `writable` Whether the stream is writable.  Default `true`.  Set to\n  `false` when `end()`\n* `readable` Whether the stream is readable.  Default `true`.\n* `buffer` A [yallist](http://npm.im/yallist) linked list of chunks written\n  to the stream that have not yet been emitted.  (It's probably a bad idea\n  to mess with this.)\n* `pipes` A [yallist](http://npm.im/yallist) linked list of streams that\n  this stream is piping into.  (It's probably a bad idea to mess with\n  this.)\n* `destroyed` A getter that indicates whether the stream was destroyed.\n* `paused` True if the stream has been explicitly paused, otherwise false.\n* `objectMode` Indicates whether the stream is in `objectMode`.  Once set\n  to `true`, it cannot be set to `false`.\n\n### Events\n\n* `data` Emitted when there's data to read.  Argument is the data to read.\n  This is never emitted while not flowing.  If a listener is attached, that\n  will resume the stream.\n* `end` Emitted when there's no more data to read.  This will be emitted\n  immediately for empty streams when `end()` is called.  If a listener is\n  attached, and `end` was already emitted, then it will be emitted again.\n  All listeners are removed when `end` is emitted.\n* `prefinish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'end'`.\n* `finish` An end-ish event that follows the same logic as `end` and is\n  emitted in the same conditions where `end` is emitted.  Emitted after\n  `'prefinish'`.\n* `close` An indication that an underlying resource has been released.\n  Minipass does not emit this event, but will defer it until after `end`\n  has been emitted, since it throws off some stream libraries otherwise.\n* `drain` Emitted when the internal buffer empties, and it is again\n  suitable to `write()` into the stream.\n* `readable` Emitted when data is buffered and ready to be read by a\n  consumer.\n* `resume` Emitted when stream changes state from buffering to flowing\n  mode.  (Ie, when `resume` is called, `pipe` is called, or a `data` event\n  listener is added.)\n\n### Static Methods\n\n* `Minipass.isStream(stream)` Returns `true` if the argument is a stream,\n  and false otherwise.  To be considered a stream, the object must be\n  either an instance of Minipass, or an EventEmitter that has either a\n  `pipe()` method, or both `write()` and `end()` methods.  (Pretty much any\n  stream in node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass streams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in platforms\nthat support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with no\nflattening, create the stream with the `{ objectMode: true }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write (chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end (chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(new (class extends Minipass {\n    emit (ev, ...data) {\n      // let's also log events, because debugging some weird thing\n      console.log('EMIT', ev)\n      return super.emit(ev, ...data)\n    }\n    write (chunk, encoding, callback) {\n      console.log('WRITE', chunk, encoding)\n      return super.write(chunk, encoding, callback)\n    }\n    end (chunk, encoding, callback) {\n      console.log('END', chunk, encoding)\n      return super.end(chunk, encoding, callback)\n    }\n  }))\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit (ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write (obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end (obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk))\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"readmeFilename":"README.md","gitHead":"e5b768d2b89c5a5be776362e913e35a6707c6df7","_nodeVersion":"18.4.0","_npmVersion":"8.13.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_3.3.5_1658701411484_0.19872163702440693"},"_hasShrinkwrap":false},"3.3.6":{"_id":"minipass@3.3.6","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"3.3.6","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":null,"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"files":["index.d.ts","index.js"],"main":"index.js","dist":{"shasum":"7bba384db3a1520d18c9c0e5251c3444e95dd94a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-3.3.6.tgz"},"types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"}},"4.0.0":{"_id":"minipass@4.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typescript":"^4.7.3"},"dependencies":{"yallist":"^4.0.0"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"7cebb0f9fa7d56f0c5b17853cbe28838a8dbbd3b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.0.0.tgz"},"types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"94124ea6c999e9f7ff76551950ff1ed79431151f","_nodeVersion":"18.12.0","_npmVersion":"9.1.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"fritzy","email":"fritzy@github.com"},{"name":"darcyclarke","email":"darcy@darcyclarke.me"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.0.0_1669508250476_0.8615478666925138"},"_hasShrinkwrap":false},"4.0.1":{"_id":"minipass@4.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"2b9408c6e81bb8b338d600fb3685e375a370a057","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.0.1.tgz"},"types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"7c89949841a2a7ee24909f5775a1fcdd5a7a4e22","_nodeVersion":"19.4.0","_npmVersion":"9.4.0","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.0.1_1675092453781_0.36220475255847173"},"_hasShrinkwrap":false},"4.0.2":{"_id":"minipass@4.0.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.0.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"26fc3364d5ea6cb971c6e5259eac67a0887510d1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.0.2.tgz"},"types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"c3ecced436ad9c884e45220454fc17df0db38daa","_nodeVersion":"18.14.0","_npmVersion":"9.3.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.0.2_1675619365690_0.8194046899768483"},"_hasShrinkwrap":false},"4.0.3":{"_id":"minipass@4.0.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.0.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"index.js","dist":{"shasum":"00bfbaf1e16e35e804f4aa31a7c1f6b8d9f0ee72","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.0.3.tgz"},"types":"index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"d9099429d9d1ee28e753e608d497a7f5d2300490","_nodeVersion":"18.14.0","_npmVersion":"9.3.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.0.3_1675807092995_0.583231517344913"},"_hasShrinkwrap":false},"4.1.0":{"_id":"minipass@4.1.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.1.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.mjs","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"572e5b64ffee9ff8abe7a48d01906160c1ce9e08","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.1.0.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"1eb74cf5efce01c555afe55a2c21afc09ea75a1a","_nodeVersion":"18.14.0","_npmVersion":"9.4.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.1.0_1677039608570_0.43776795906501187"},"_hasShrinkwrap":false},"4.2.0":{"_id":"minipass@4.2.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.mjs","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"4bf124d8c87c14e99846f9a27c3219d956998c0e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.0.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"0b77950c7b87a41e58aee0983429d23f51e77e08","_nodeVersion":"18.14.0","_npmVersion":"9.4.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.0_1677044293765_0.8526737717005475"},"_hasShrinkwrap":false},"4.2.1":{"_id":"minipass@4.2.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"084031141113657662d40f66f9c2329036892128","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.1.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"ef1f48933b9260b2664a942b1bc7ca9d8b640991","_nodeVersion":"18.14.0","_npmVersion":"9.5.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.1_1677214138419_0.3678700408590496"},"_hasShrinkwrap":false},"4.2.2":{"_id":"minipass@4.2.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"4f35a099272b23d0cfe26c0dcea2a7b772aeb809","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.2.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"16837bea69197dcfb3b3534d0747d062e17ac473","_nodeVersion":"18.14.0","_npmVersion":"9.5.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.2_1677395920672_0.6444427884982831"},"_hasShrinkwrap":false},"4.2.3":{"_id":"minipass@4.2.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"5ee9b1ad67dfc916ce7cec86e5260fc61da64376","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.3.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"3d63d733bdcb1eed77ed7947977d85643287af60","_nodeVersion":"18.14.0","_npmVersion":"9.5.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.3_1677397546259_0.8851282963016653"},"_hasShrinkwrap":false},"4.2.4":{"_id":"minipass@4.2.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.4","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"7d0d97434b6a19f59c5c3221698b48bbf3b2cd06","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.4.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"8a5e3921179c0ca58683678858f9496d30bddbcc","_nodeVersion":"18.14.0","_npmVersion":"9.5.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.4_1677397860387_0.5042330666279724"},"_hasShrinkwrap":false},"4.2.5":{"_id":"minipass@4.2.5","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.5","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"9e0e5256f1e3513f8c34691dd68549e85b2c8ceb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.5.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"e3b98a071233fd4f4054ab7437f1d9a3bab71ce3","_nodeVersion":"18.14.0","_npmVersion":"9.5.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.5_1678562849994_0.47969510867769394"},"_hasShrinkwrap":false},"4.2.6":{"_id":"minipass@4.2.6","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.6","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"43c56f3890214d24b5d63f70e8ee97b2fb632df3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.6.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"4f37bc74563af7f5c2ff131648112e5ed9e1d72d","_nodeVersion":"18.14.0","_npmVersion":"9.6.3","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.6_1681074010848_0.5148388380615421"},"_hasShrinkwrap":false},"4.2.7":{"_id":"minipass@4.2.7","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.7","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","dist":{"shasum":"14c6fc0dcab54d9c4dd64b2b7032fef04efec218","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.7.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"815a2efb09546d48f98c0817d0656aa7b6e83e99","_nodeVersion":"18.14.0","_npmVersion":"9.6.3","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.7_1681075459725_0.7272249058668407"},"_hasShrinkwrap":false},"4.2.8":{"_id":"minipass@4.2.8","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"4.2.8","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"main":"./index.js","publishConfig":{"tag":"legacy-v4"},"dist":{"shasum":"f0010f64393ecfc1d1ccb5f582bcaf45f48e1a3a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-4.2.8.tgz"},"readme":"# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1K_HR5oh3r80b8WVMWCPPjfuWXUgfkmhlX7FGI6JJ8tY/edit?usp=sharing)\nfor objects, strings, and buffers.\n\nSupports `pipe()`ing (including multi-`pipe()` and backpressure\ntransmission), buffering data until either a `data` event handler\nor `pipe()` is added (so you don't lose the first chunk), and\nmost other cases where PassThrough is a good idea.\n\nThere is a `read()` method, but it's much more efficient to\nconsume data from this stream via `'data'` events or by calling\n`pipe()` into some other stream. Calling `read()` requires the\nbuffer to be flattened in some cases, which requires copying\nmemory.\n\nIf you set `objectMode: true` in the options, then whatever is\nwritten will be emitted. Otherwise, it'll do a minimal amount of\nBuffer copying to ensure proper Streams semantics when `read(n)`\nis called.\n\n`objectMode` can also be set by doing `stream.objectMode = true`,\nor by writing any non-string/non-buffer data. `objectMode` cannot\nbe set to false once it is set.\n\nThis is not a `through` or `through2` stream. It doesn't\ntransform the data, it just passes it right through. If you want\nto transform the data, extend the class, and override the\n`write()` method. Once you're done transforming the data however\nyou want, call `super.write()` with the transform output.\n\nFor some examples of streams that extend Minipass in various\nways, check out:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap-parser)\n- [treport](http://npm.im/treport)\n- [minipass-fetch](http://npm.im/minipass-fetch)\n- [pacote](http://npm.im/pacote)\n- [make-fetch-happen](http://npm.im/make-fetch-happen)\n- [cacache](http://npm.im/cacache)\n- [ssri](http://npm.im/ssri)\n- [npm-registry-fetch](http://npm.im/npm-registry-fetch)\n- [minipass-json-stream](http://npm.im/minipass-json-stream)\n- [minipass-sized](http://npm.im/minipass-sized)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different\nfrom (and in some ways superior to) Node.js core streams.\n\nPlease read these caveats if you are familiar with node-core\nstreams and intend to use Minipass streams in your programs.\n\nYou can avoid most of these differences entirely (for a very\nsmall performance penalty) by setting `{async: true}` in the\nconstructor options.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.\nThus, data is emitted as soon as it is available, always. It is\nbuffered until read, but no longer. Another way to look at it is\nthat Minipass streams are exactly as synchronous as the logic\nthat writes into them.\n\nThis can be surprising if your code relies on\n`PassThrough.write()` always providing data on the next tick\nrather than the current one, or being able to call `resume()` and\nnot have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no\nway for Minipass to achieve the speeds it does, or support the\nsynchronous use cases that it does. Simply put, waiting takes\ntime.\n\nThis non-deferring approach makes Minipass streams much easier to\nreason about, especially in the context of Promises and other\nflow-control mechanisms.\n\nExample:\n\n```js\n// hybrid module, either works\nimport Minipass from 'minipass'\n// or:\nconst Minipass = require('minipass')\n\nconst stream = new Minipass()\nstream.on('data', () => console.log('data event'))\nconsole.log('before write')\nstream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// data event\n// after write\n```\n\n### Exception: Async Opt-In\n\nIf you wish to have a Minipass stream with behavior that more\nclosely mimics Node.js core streams, you can set the stream in\nasync mode either by setting `async: true` in the constructor\noptions, or by setting `stream.async = true` later on.\n\n```js\n// hybrid module, either works\nimport Minipass from 'minipass'\n// or:\nconst Minipass = require('minipass')\n\nconst asyncStream = new Minipass({ async: true })\nasyncStream.on('data', () => console.log('data event'))\nconsole.log('before write')\nasyncStream.write('hello')\nconsole.log('after write')\n// output:\n// before write\n// after write\n// data event <-- this is deferred until the next tick\n```\n\nSwitching _out_ of async mode is unsafe, as it could cause data\ncorruption, and so is not enabled. Example:\n\n```js\nimport Minipass from 'minipass'\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nsetStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!\nstream.write('world')\nconsole.log('after writes')\n// hypothetical output would be:\n// before writes\n// world\n// after writes\n// hello\n// NOT GOOD!\n```\n\nTo avoid this problem, once set into async mode, any attempt to\nmake the stream sync again will be ignored.\n\n```js\nconst Minipass = require('minipass')\nconst stream = new Minipass({ encoding: 'utf8' })\nstream.on('data', chunk => console.log(chunk))\nstream.async = true\nconsole.log('before writes')\nstream.write('hello')\nstream.async = false // <-- no-op, stream already async\nstream.write('world')\nconsole.log('after writes')\n// actual output:\n// before writes\n// after writes\n// hello\n// world\n```\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer,\nreturning `true` on all writes until the limit is hit, even if\nthe data has nowhere to go. Then, they will not attempt to draw\nmore data in until the buffer size dips below a minimum value.\n\nMinipass streams are much simpler. The `write()` method will\nreturn `true` if the data has somewhere to go (which is to say,\ngiven the timing guarantees, that the data is already there by\nthe time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and\nthe data sits in a buffer, to be drained out immediately as soon\nas anyone consumes it.\n\nSince nothing is ever buffered unnecessarily, there is much less\ncopying data, and less bookkeeping about buffer capacity levels.\n\n### Hazards of Buffering (or: Why Minipass Is So Fast)\n\nSince data written to a Minipass stream is immediately written\nall the way through the pipeline, and `write()` always returns\ntrue/false based on whether the data was fully flushed,\nbackpressure is communicated immediately to the upstream caller.\nThis minimizes buffering.\n\nConsider this case:\n\n```js\nconst { PassThrough } = require('stream')\nconst p1 = new PassThrough({ highWaterMark: 1024 })\nconst p2 = new PassThrough({ highWaterMark: 1024 })\nconst p3 = new PassThrough({ highWaterMark: 1024 })\nconst p4 = new PassThrough({ highWaterMark: 1024 })\n\np1.pipe(p2).pipe(p3).pipe(p4)\np4.on('data', () => console.log('made it through'))\n\n// this returns false and buffers, then writes to p2 on next tick (1)\n// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)\n// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)\n// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'\n// on next tick (4)\n// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and\n// 'drain' on next tick (5)\n// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)\n// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next\n// tick (7)\n\np1.write(Buffer.alloc(2048)) // returns false\n```\n\nAlong the way, the data was buffered and deferred at each stage,\nand multiple event deferrals happened, for an unblocked pipeline\nwhere it was perfectly safe to write all the way through!\n\nFurthermore, setting a `highWaterMark` of `1024` might lead\nsomeone reading the code to think an advisory maximum of 1KiB is\nbeing set for the pipeline. However, the actual advisory\nbuffering level is the _sum_ of `highWaterMark` values, since\neach one has its own bucket.\n\nConsider the Minipass case:\n\n```js\nconst m1 = new Minipass()\nconst m2 = new Minipass()\nconst m3 = new Minipass()\nconst m4 = new Minipass()\n\nm1.pipe(m2).pipe(m3).pipe(m4)\nm4.on('data', () => console.log('made it through'))\n\n// m1 is flowing, so it writes the data to m2 immediately\n// m2 is flowing, so it writes the data to m3 immediately\n// m3 is flowing, so it writes the data to m4 immediately\n// m4 is flowing, so it fires the 'data' event immediately, returns true\n// m4's write returned true, so m3 is still flowing, returns true\n// m3's write returned true, so m2 is still flowing, returns true\n// m2's write returned true, so m1 is still flowing, returns true\n// No event deferrals or buffering along the way!\n\nm1.write(Buffer.alloc(2048)) // returns true\n```\n\nIt is extremely unlikely that you _don't_ want to buffer any data\nwritten, or _ever_ buffer data that can be flushed all the way\nthrough. Neither node-core streams nor Minipass ever fail to\nbuffer written data, but node-core streams do a lot of\nunnecessary buffering and pausing.\n\nAs always, the faster implementation is the one that does less\nstuff and waits less time to do it.\n\n### Immediately emit `end` for empty streams (when not paused)\n\nIf a stream is not paused, and `end()` is called before writing\nany data into it, then it will emit `end` immediately.\n\nIf you have logic that occurs on the `end` event which you don't\nwant to potentially happen immediately (for example, closing file\ndescriptors, moving on to the next entry in an archive parse\nstream, etc.) then be sure to call `stream.pause()` on creation,\nand then `stream.resume()` once you are ready to respond to the\n`end` event.\n\nHowever, this is _usually_ not a problem because:\n\n### Emit `end` When Asked\n\nOne hazard of immediately emitting `'end'` is that you may not\nyet have had a chance to add a listener. In order to avoid this\nhazard, Minipass streams safely re-emit the `'end'` event if a\nnew listener is added after `'end'` has been emitted.\n\nIe, if you do `stream.on('end', someFunction)`, and the stream\nhas already emitted `end`, then it will call the handler right\naway. (You can think of this somewhat like attaching a new\n`.then(fn)` to a previously-resolved Promise.)\n\nTo prevent calling handlers multiple times who would not expect\nmultiple ends to occur, all listeners are removed from the\n`'end'` event whenever it is emitted.\n\n### Emit `error` When Asked\n\nThe most recent error object passed to the `'error'` event is\nstored on the stream. If a new `'error'` event handler is added,\nand an error was previously emitted, then the event handler will\nbe called immediately (or on `process.nextTick` in the case of\nasync streams).\n\nThis makes it much more difficult to end up trying to interact\nwith a broken stream, if the error handler is added after an\nerror was previously emitted.\n\n### Impact of \"immediate flow\" on Tee-streams\n\nA \"tee stream\" is a stream piping to multiple destinations:\n\n```js\nconst tee = new Minipass()\nt.pipe(dest1)\nt.pipe(dest2)\nt.write('foo') // goes to both destinations\n```\n\nSince Minipass streams _immediately_ process any pending data\nthrough the pipeline when a new pipe destination is added, this\ncan have surprising effects, especially when a stream comes in\nfrom some other function and may or may not have data in its\nbuffer.\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone\nsrc.pipe(dest2) // gets nothing!\n```\n\nOne solution is to create a dedicated tee-stream junction that\npipes to both locations, and then pipe to _that_ instead.\n\n```js\n// Safe example: tee to both places\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.pipe(dest1)\ntee.pipe(dest2)\nsrc.pipe(tee) // tee gets 'foo', pipes to both locations\n```\n\nThe same caveat applies to `on('data')` event listeners. The\nfirst one added will _immediately_ receive all of the data,\nleaving nothing for the second:\n\n```js\n// WARNING! WILL LOSE DATA!\nconst src = new Minipass()\nsrc.write('foo')\nsrc.on('data', handler1) // receives 'foo' right away\nsrc.on('data', handler2) // nothing to see here!\n```\n\nUsing a dedicated tee-stream can be used in this case as well:\n\n```js\n// Safe example: tee to both data handlers\nconst src = new Minipass()\nsrc.write('foo')\nconst tee = new Minipass()\ntee.on('data', handler1)\ntee.on('data', handler2)\nsrc.pipe(tee)\n```\n\nAll of the hazards in this section are avoided by setting `{\nasync: true }` in the Minipass constructor, or by setting\n`stream.async = true` afterwards. Note that this does add some\noverhead, so should only be done in cases where you are willing\nto lose a bit of performance in order to avoid having to refactor\nprogram logic.\n\n## USAGE\n\nIt's a stream! Use it like a stream and it'll most likely do what\nyou want.\n\n```js\nimport Minipass from 'minipass'\nconst mp = new Minipass(options) // optional: { encoding, objectMode }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### OPTIONS\n\n- `encoding` How would you like the data coming _out_ of the\n  stream to be encoded? Accepts any values that can be passed to\n  `Buffer.toString()`.\n- `objectMode` Emit data exactly as it comes in. This will be\n  flipped on by default if you write() something other than a\n  string or Buffer at any point. Setting `objectMode: true` will\n  prevent setting any encoding value.\n- `async` Defaults to `false`. Set to `true` to defer data\n  emission until next tick. This reduces performance slightly,\n  but makes Minipass streams use timing behavior closer to Node\n  core streams. See [Timing](#timing) for more details.\n- `signal` An `AbortSignal` that will cause the stream to unhook\n  itself from everything and become as inert as possible. Note\n  that providing a `signal` parameter will make `'error'` events\n  no longer throw if they are unhandled, but they will still be\n  emitted to handlers if any are attached.\n\n### API\n\nImplements the user-facing portions of Node.js's `Readable` and\n`Writable` streams.\n\n### Methods\n\n- `write(chunk, [encoding], [callback])` - Put data in. (Note\n  that, in the base Minipass class, the same data will come out.)\n  Returns `false` if the stream will buffer the next write, or\n  true if it's still in \"flowing\" mode.\n- `end([chunk, [encoding]], [callback])` - Signal that you have\n  no more data to write. This will queue an `end` event to be\n  fired when all the data has been consumed.\n- `setEncoding(encoding)` - Set the encoding for data coming of\n  the stream. This can only be done once.\n- `pause()` - No more data for a while, please. This also\n  prevents `end` from being emitted for empty streams until the\n  stream is resumed.\n- `resume()` - Resume the stream. If there's data in the buffer,\n  it is all discarded. Any buffered events are immediately\n  emitted.\n- `pipe(dest)` - Send all output to the stream provided. When\n  data is emitted, it is immediately written to any and all pipe\n  destinations. (Or written on next tick in `async` mode.)\n- `unpipe(dest)` - Stop piping to the destination stream. This is\n  immediate, meaning that any asynchronously queued data will\n  _not_ make it to the destination when running in `async` mode.\n  - `options.end` - Boolean, end the destination stream when the\n    source stream ends. Default `true`.\n  - `options.proxyErrors` - Boolean, proxy `error` events from\n    the source stream to the destination stream. Note that errors\n    are _not_ proxied after the pipeline terminates, either due\n    to the source emitting `'end'` or manually unpiping with\n    `src.unpipe(dest)`. Default `false`.\n- `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are\n  EventEmitters. Some events are given special treatment,\n  however. (See below under \"events\".)\n- `promise()` - Returns a Promise that resolves when the stream\n  emits `end`, or rejects if the stream emits `error`.\n- `collect()` - Return a Promise that resolves on `end` with an\n  array containing each chunk of data that was emitted, or\n  rejects if the stream emits `error`. Note that this consumes\n  the stream data.\n- `concat()` - Same as `collect()`, but concatenates the data\n  into a single Buffer object. Will reject the returned promise\n  if the stream is in objectMode, or if it goes into objectMode\n  by the end of the data.\n- `read(n)` - Consume `n` bytes of data out of the buffer. If `n`\n  is not provided, then consume all of it. If `n` bytes are not\n  available, then it returns null. **Note** consuming streams in\n  this way is less efficient, and can lead to unnecessary Buffer\n  copying.\n- `destroy([er])` - Destroy the stream. If an error is provided,\n  then an `'error'` event is emitted. If the stream has a\n  `close()` method, and has not emitted a `'close'` event yet,\n  then `stream.close()` will be called. Any Promises returned by\n  `.promise()`, `.collect()` or `.concat()` will be rejected.\n  After being destroyed, writing to the stream will emit an\n  error. No more data will be emitted if the stream is destroyed,\n  even if it was previously buffered.\n\n### Properties\n\n- `bufferLength` Read-only. Total number of bytes buffered, or in\n  the case of objectMode, the total number of objects.\n- `encoding` The encoding that has been set. (Setting this is\n  equivalent to calling `setEncoding(enc)` and has the same\n  prohibition against setting multiple times.)\n- `flowing` Read-only. Boolean indicating whether a chunk written\n  to the stream will be immediately emitted.\n- `emittedEnd` Read-only. Boolean indicating whether the end-ish\n  events (ie, `end`, `prefinish`, `finish`) have been emitted.\n  Note that listening on any end-ish event will immediateyl\n  re-emit it if it has already been emitted.\n- `writable` Whether the stream is writable. Default `true`. Set\n  to `false` when `end()`\n- `readable` Whether the stream is readable. Default `true`.\n- `pipes` An array of Pipe objects referencing streams that this\n  stream is piping into.\n- `destroyed` A getter that indicates whether the stream was\n  destroyed.\n- `paused` True if the stream has been explicitly paused,\n  otherwise false.\n- `objectMode` Indicates whether the stream is in `objectMode`.\n  Once set to `true`, it cannot be set to `false`.\n- `aborted` Readonly property set when the `AbortSignal`\n  dispatches an `abort` event.\n\n### Events\n\n- `data` Emitted when there's data to read. Argument is the data\n  to read. This is never emitted while not flowing. If a listener\n  is attached, that will resume the stream.\n- `end` Emitted when there's no more data to read. This will be\n  emitted immediately for empty streams when `end()` is called.\n  If a listener is attached, and `end` was already emitted, then\n  it will be emitted again. All listeners are removed when `end`\n  is emitted.\n- `prefinish` An end-ish event that follows the same logic as\n  `end` and is emitted in the same conditions where `end` is\n  emitted. Emitted after `'end'`.\n- `finish` An end-ish event that follows the same logic as `end`\n  and is emitted in the same conditions where `end` is emitted.\n  Emitted after `'prefinish'`.\n- `close` An indication that an underlying resource has been\n  released. Minipass does not emit this event, but will defer it\n  until after `end` has been emitted, since it throws off some\n  stream libraries otherwise.\n- `drain` Emitted when the internal buffer empties, and it is\n  again suitable to `write()` into the stream.\n- `readable` Emitted when data is buffered and ready to be read\n  by a consumer.\n- `resume` Emitted when stream changes state from buffering to\n  flowing mode. (Ie, when `resume` is called, `pipe` is called,\n  or a `data` event listener is added.)\n\n### Static Methods\n\n- `Minipass.isStream(stream)` Returns `true` if the argument is a\n  stream, and false otherwise. To be considered a stream, the\n  object must be either an instance of Minipass, or an\n  EventEmitter that has either a `pipe()` method, or both\n  `write()` and `end()` methods. (Pretty much any stream in\n  node-land will return `true` for this.)\n\n## EXAMPLES\n\nHere are some examples of things you can do with Minipass\nstreams.\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(\n  () => {\n    // stream is finished\n  },\n  er => {\n    // stream emitted an error\n  }\n)\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one\nchunk for you, but if you're going to do it yourself anyway, it's\nconvenient this way:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in\nplatforms that support it.\n\nSynchronous iteration will end when the currently available data\nis consumed, even if the `end` event has not been reached. In\nstring and buffer mode, the data is concatenated, so unless\nmultiple writes are occurring in the same tick as the `read()`,\nsync iteration loops will generally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written,\nwith no flattening, create the stream with the `{ objectMode:\ntrue }` option.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i-- > 0) mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume() {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n\n### subclass that `console.log()`s everything written into it\n\n```js\nclass Logger extends Minipass {\n  write(chunk, encoding, callback) {\n    console.log('WRITE', chunk, encoding)\n    return super.write(chunk, encoding, callback)\n  }\n  end(chunk, encoding, callback) {\n    console.log('END', chunk, encoding)\n    return super.end(chunk, encoding, callback)\n  }\n}\n\nsomeSource.pipe(new Logger()).pipe(someDest)\n```\n\n### same thing, but using an inline anonymous class\n\n```js\n// js classes are fun\nsomeSource\n  .pipe(\n    new (class extends Minipass {\n      emit(ev, ...data) {\n        // let's also log events, because debugging some weird thing\n        console.log('EMIT', ev)\n        return super.emit(ev, ...data)\n      }\n      write(chunk, encoding, callback) {\n        console.log('WRITE', chunk, encoding)\n        return super.write(chunk, encoding, callback)\n      }\n      end(chunk, encoding, callback) {\n        console.log('END', chunk, encoding)\n        return super.end(chunk, encoding, callback)\n      }\n    })()\n  )\n  .pipe(someDest)\n```\n\n### subclass that defers 'end' for some reason\n\n```js\nclass SlowEnd extends Minipass {\n  emit(ev, ...args) {\n    if (ev === 'end') {\n      console.log('going to end, hold on a sec')\n      setTimeout(() => {\n        console.log('ok, ready to end now')\n        super.emit('end', ...args)\n      }, 100)\n    } else {\n      return super.emit(ev, ...args)\n    }\n  }\n}\n```\n\n### transform that creates newline-delimited JSON\n\n```js\nclass NDJSONEncode extends Minipass {\n  write(obj, cb) {\n    try {\n      // JSON.stringify can throw, emit an error on that\n      return super.write(JSON.stringify(obj) + '\\n', 'utf8', cb)\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n  end(obj, cb) {\n    if (typeof obj === 'function') {\n      cb = obj\n      obj = undefined\n    }\n    if (obj !== undefined) {\n      this.write(obj)\n    }\n    return super.end(cb)\n  }\n}\n```\n\n### transform that parses newline-delimited JSON\n\n```js\nclass NDJSONDecode extends Minipass {\n  constructor (options) {\n    // always be in object mode, as far as Minipass is concerned\n    super({ objectMode: true })\n    this._jsonBuffer = ''\n  }\n  write (chunk, encoding, cb) {\n    if (typeof chunk === 'string' &&\n        typeof encoding === 'string' &&\n        encoding !== 'utf8') {\n      chunk = Buffer.from(chunk, encoding).toString()\n    } else if (Buffer.isBuffer(chunk)) {\n      chunk = chunk.toString()\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n    }\n    const jsonData = (this._jsonBuffer + chunk).split('\\n')\n    this._jsonBuffer = jsonData.pop()\n    for (let i = 0; i < jsonData.length; i++) {\n      try {\n        // JSON.parse can throw, emit an error on that\n        super.write(JSON.parse(jsonData[i]))\n      } catch (er) {\n        this.emit('error', er)\n        continue\n      }\n    }\n    if (cb)\n      cb()\n  }\n}\n```\n","module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"readmeFilename":"README.md","gitHead":"ceb8d68b7658039349a2bfc92ae95ae4ca822fbe","_nodeVersion":"18.14.0","_npmVersion":"9.6.4","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_4.2.8_1681228810954_0.6015072400739621"},"_hasShrinkwrap":false},"5.0.0":{"_id":"minipass@5.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"5.0.0","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":null,"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=8"},"files":["index.d.ts","index.js","index.mjs"],"main":"./index.js","dist":{"shasum":"3e9788ffb90b694a5d0ec94479a45b5d8738133d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-5.0.0.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"}},"6.0.0":{"_id":"minipass@6.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"6.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./index.js","dist":{"shasum":"3b000c121dd32da5dc56156381dc322b4f2ffaa0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-6.0.0.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"c2aa0b2196a5d622fdf08032753dd424f53a101b","_nodeVersion":"18.16.0","_npmVersion":"9.6.5","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_6.0.0_1684125669158_0.33282480463221487"},"_hasShrinkwrap":false},"6.0.1":{"_id":"minipass@6.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"6.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./index.js","dist":{"shasum":"315417c259cb32a1b2fc530c0e7f55c901a60a6d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-6.0.1.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"6125ceeddb721eb3f69749d4e71953adb48ad37d","_nodeVersion":"18.16.0","_npmVersion":"9.6.5","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_6.0.1_1684189575979_0.959831283268048"},"_hasShrinkwrap":false},"6.0.2":{"_id":"minipass@6.0.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"6.0.2","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"pretest":"npm run prepare","presnap":"npm run prepare","prepare":"node ./scripts/transpile-to-esm.js","snap":"tap","test":"tap","preversion":"npm test","postversion":"npm publish","postpublish":"git push origin --follow-tags","typedoc":"typedoc ./index.d.ts","format":"prettier --write . --loglevel warn"},"directories":{},"devDependencies":{"@types/node":"^17.0.41","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","tap":"^16.2.0","through2":"^2.0.3","ts-node":"^10.8.1","typedoc":"^0.23.24","typescript":"^4.7.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./index.js","dist":{"shasum":"542844b6c4ce95b202c0995b0a471f1229de4c81","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-6.0.2.tgz"},"module":"./index.mjs","types":"./index.d.ts","tap":{"check-coverage":true},"prettier":{"semi":false,"printWidth":80,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"15ab07809dab7a278f9c79027cf25a3a150b770a","_nodeVersion":"18.16.0","_npmVersion":"9.6.5","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_6.0.2_1684358210139_0.12283922254492419"},"_hasShrinkwrap":false},"7.0.0":{"_id":"minipass@7.0.0","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"7.0.0","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","preprepare":"rm -rf dist","prepare":"tsc -p tsconfig.json && tsc -p tsconfig-esm.json && bash ./scripts/fixup.sh","pretest":"npm run prepare","presnap":"npm run prepare","test":"c8 tap","snap":"c8 tap","format":"prettier --write . --loglevel warn","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts"},"directories":{},"devDependencies":{"@types/node":"^20.1.2","@types/tap":"^15.0.8","c8":"^7.13.0","prettier":"^2.6.2","tap":"^16.3.0","ts-node":"^10.9.1","typedoc":"^0.24.8","typescript":"^5.1.3","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","sync-content":"^1.0.2","through2":"^2.0.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./dist/cjs/index.js","dist":{"shasum":"164051d8c2881b7a47f21d9cb6661dcb8f4121f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-7.0.0.tgz"},"module":"./dist/mjs/index.js","types":"./dist/cjs/index.js","tap":{"coverage":false,"node-arg":["--enable-source-maps","--no-warnings","--loader","ts-node/esm"],"ts":false},"prettier":{"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"d63abffc8734d679177d2382ac1841caa82349f3","_nodeVersion":"18.16.0","_npmVersion":"9.7.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_7.0.0_1688775283609_0.8892298371891081"},"_hasShrinkwrap":false},"7.0.1":{"_id":"minipass@7.0.1","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"7.0.1","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","preprepare":"rm -rf dist","prepare":"tsc -p tsconfig.json && tsc -p tsconfig-esm.json && bash ./scripts/fixup.sh","pretest":"npm run prepare","presnap":"npm run prepare","test":"c8 tap","snap":"c8 tap","format":"prettier --write . --loglevel warn","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts"},"directories":{},"devDependencies":{"@types/node":"^20.1.2","@types/tap":"^15.0.8","c8":"^7.13.0","prettier":"^2.6.2","tap":"^16.3.0","ts-node":"^10.9.1","typedoc":"^0.24.8","typescript":"^5.1.3","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","sync-content":"^1.0.2","through2":"^2.0.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./dist/cjs/index.js","dist":{"shasum":"dff63464407cd8b83d7f008c0f116fa8c9b77ebf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-7.0.1.tgz"},"module":"./dist/mjs/index.js","types":"./dist/cjs/index.js","tap":{"coverage":false,"node-arg":["--enable-source-maps","--no-warnings","--loader","ts-node/esm"],"ts":false},"prettier":{"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"6baaade6726d1cac656426f89f15de631a56b3d1","_nodeVersion":"18.16.0","_npmVersion":"9.7.2","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"nlf","email":"quitlahok@gmail.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_7.0.1_1688775799416_0.7448468714465568"},"_hasShrinkwrap":false},"7.0.2":{"_id":"minipass@7.0.2","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"7.0.2","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"url":"https://github.com/isaacs/minipass"},"license":"ISC","scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","preprepare":"rm -rf dist","prepare":"tsc -p tsconfig.json && tsc -p tsconfig-esm.json && bash ./scripts/fixup.sh","pretest":"npm run prepare","presnap":"npm run prepare","test":"c8 tap","snap":"c8 tap","format":"prettier --write . --loglevel warn","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts"},"directories":null,"devDependencies":{"@types/node":"^20.1.2","@types/tap":"^15.0.8","c8":"^7.13.0","prettier":"^2.6.2","tap":"^16.3.0","ts-node":"^10.9.1","typedoc":"^0.24.8","typescript":"^5.1.3","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","sync-content":"^1.0.2","through2":"^2.0.3"},"engines":{"node":">=16 || 14 >=14.17"},"files":["dist"],"main":"./dist/cjs/index.js","dist":{"shasum":"58a82b7d81c7010da5bd4b2c0c85ac4b4ec5131e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-7.0.2.tgz"},"module":"./dist/mjs/index.js","types":"./dist/cjs/index.js","tap":{"coverage":false,"node-arg":["--enable-source-maps","--no-warnings","--loader","ts-node/esm"],"ts":false},"prettier":{"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"}},"7.0.3":{"_id":"minipass@7.0.3","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"7.0.3","keywords":["passthrough","stream"],"homepage":"https://github.com/isaacs/minipass#readme","author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"type":"git","url":"git+https://github.com/isaacs/minipass.git"},"bugs":{"url":"https://github.com/isaacs/minipass/issues"},"license":"ISC","scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","preprepare":"rm -rf dist","prepare":"tsc -p tsconfig.json && tsc -p tsconfig-esm.json && bash ./scripts/fixup.sh","pretest":"npm run prepare","presnap":"npm run prepare","test":"c8 tap","snap":"c8 tap","format":"prettier --write . --loglevel warn","typedoc":"typedoc --tsconfig tsconfig-esm.json ./src/*.ts"},"directories":{},"devDependencies":{"@types/node":"^20.1.2","@types/tap":"^15.0.8","c8":"^7.13.0","prettier":"^2.6.2","tap":"^16.3.0","ts-node":"^10.9.1","typedoc":"^0.24.8","typescript":"^5.1.3","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","sync-content":"^1.0.2","through2":"^2.0.3"},"engines":{"node":">=16 || 14 >=14.17"},"main":"./dist/cjs/index.js","dist":{"shasum":"05ea638da44e475037ed94d1c7efcc76a25e1974","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-7.0.3.tgz"},"module":"./dist/mjs/index.js","types":"./dist/cjs/index.js","tap":{"coverage":false,"node-arg":["--enable-source-maps","--no-warnings","--loader","ts-node/esm"],"ts":false},"prettier":{"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"gitHead":"8d95dcac2d3e769bbb8e66d721ce8359a1380d42","_nodeVersion":"18.16.0","_npmVersion":"9.8.1","_npmUser":{"name":"isaacs","email":"i@izs.me"},"maintainers":[{"name":"npm-cli-ops","email":"npm-cli+bot@github.com"},{"name":"saquibkhan","email":"saquibkhan@github.com"},{"name":"fritzy","email":"fritzy@github.com"},{"name":"gar","email":"gar+npm@danger.computer"},{"name":"lukekarrys","email":"luke@lukekarrys.com"},{"name":"isaacs","email":"i@izs.me"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/minipass_7.0.3_1691868603294_0.8818660773346114"},"_hasShrinkwrap":false},"7.0.4":{"_id":"minipass@7.0.4","name":"minipass","description":"minimal implementation of a PassThrough stream","version":"7.0.4","keywords":["passthrough","stream"],"author":{"name":"Isaac Z. Schlueter","email":"i@izs.me","url":"http://blog.izs.me/"},"repository":{"url":"https://github.com/isaacs/minipass"},"license":"ISC","scripts":{"preversion":"npm test","postversion":"npm publish","prepublishOnly":"git push origin --follow-tags","prepare":"tshy","pretest":"npm run prepare","presnap":"npm run prepare","test":"tap","snap":"tap","format":"prettier --write . --loglevel warn","typedoc":"typedoc --tsconfig .tshy/esm.json ./src/*.ts"},"directories":null,"devDependencies":{"@types/end-of-stream":"^1.4.2","@types/node":"^20.1.2","end-of-stream":"^1.4.0","node-abort-controller":"^3.1.1","prettier":"^2.6.2","sync-content":"^1.0.2","tap":"^18.3.0","through2":"^2.0.3","tshy":"^1.2.2","typedoc":"^0.25.1","typescript":"^5.2.2"},"engines":{"node":">=16 || 14 >=14.17"},"files":["dist"],"main":"./dist/commonjs/index.js","dist":{"shasum":"dbce03740f50a4786ba994c1fb908844d27b038c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/minipass/-/minipass-7.0.4.tgz"},"types":"./dist/commonjs/index.d.ts","type":"module","tshy":{"main":true,"exports":{"./package.json":"./package.json",".":"./src/index.ts"}},"prettier":{"semi":false,"printWidth":75,"tabWidth":2,"useTabs":false,"singleQuote":true,"jsxSingleQuote":false,"bracketSameLine":true,"arrowParens":"avoid","endOfLine":"lf"},"tap":{"include":["test/*.ts"]}}},"time":{"created":"2022-06-15T16:24:46Z","modified":"2024-01-02T18:53:07Z","1.0.0":"2022-06-15T16:24:46Z","1.0.1":"2022-06-15T16:24:46Z","1.0.2":"2022-06-15T16:24:46Z","1.1.0":"2022-06-15T16:24:46Z","1.1.1":"2022-06-15T16:24:46Z","1.1.2":"2022-06-15T16:24:46Z","1.1.3":"2022-06-15T16:24:46Z","1.1.4":"2022-06-15T16:24:46Z","1.1.5":"2022-06-15T16:24:46Z","1.1.6":"2022-06-15T16:24:46Z","1.1.7":"2022-06-15T16:24:46Z","1.1.8":"2022-06-15T16:24:46Z","1.1.9":"2022-06-15T16:24:46Z","1.1.10":"2022-06-15T16:24:46Z","1.1.11":"2022-06-15T16:24:46Z","1.2.0":"2022-06-15T16:24:46Z","2.0.0":"2022-06-15T16:24:46Z","2.0.1":"2022-06-15T16:24:46Z","2.0.2":"2022-06-15T16:24:46Z","2.1.0":"2022-06-15T16:24:46Z","2.1.1":"2022-06-15T16:24:46Z","2.2.0":"2022-06-15T16:24:46Z","2.2.1":"2022-06-15T16:24:46Z","2.2.2":"2022-06-15T16:24:46Z","2.2.3":"2022-06-15T16:24:46Z","2.2.4":"2022-06-15T16:24:46Z","2.3.0":"2022-06-15T16:24:46Z","2.3.1":"2022-06-15T16:24:46Z","2.3.2":"2022-06-15T16:24:46Z","2.3.3":"2022-06-15T16:24:46Z","2.3.4":"2022-06-15T16:24:46Z","2.3.5":"2022-06-15T16:24:46Z","2.4.0":"2022-06-15T16:24:46Z","2.5.0":"2022-06-15T16:24:46Z","2.5.1":"2022-06-15T16:24:46Z","2.6.0":"2022-06-15T16:24:46Z","2.6.1":"2022-06-15T16:24:46Z","2.6.2":"2022-06-15T16:24:46Z","2.6.3":"2022-06-15T16:24:46Z","2.6.4":"2022-06-15T16:24:46Z","2.6.5":"2022-06-15T16:24:46Z","2.7.0":"2022-06-15T16:24:46Z","2.8.0":"2022-06-15T16:24:46Z","2.8.1":"2022-06-15T16:24:46Z","2.8.2":"2022-06-15T16:24:46Z","2.8.3":"2022-06-15T16:24:46Z","2.8.4":"2022-06-15T16:24:46Z","2.8.5":"2022-06-15T16:24:46Z","2.8.6":"2022-06-15T16:24:46Z","2.9.0":"2022-06-15T16:34:20Z","3.0.0":"2022-06-15T16:24:46Z","3.0.1":"2022-06-15T16:24:46Z","3.1.0":"2022-06-15T16:24:46Z","3.1.1":"2022-06-15T16:24:46Z","3.1.2":"2022-06-15T16:24:46Z","3.1.3":"2022-06-15T16:34:50Z","3.1.4":"2022-06-15T16:24:46Z","3.1.5":"2022-06-15T16:24:46Z","3.1.6":"2022-08-24T21:03:00Z","3.2.0":"2022-06-15T16:24:46Z","3.2.1":"2022-06-15T16:24:46Z","3.3.0":"2022-06-20T02:41:09Z","3.3.1":"2022-06-20T05:40:01Z","3.3.2":"2022-06-20T05:40:01Z","3.3.3":"2022-06-20T05:40:01Z","3.3.4":"2022-08-22T21:32:20Z","3.3.5":"2022-07-24T23:39:59Z","3.3.6":"2024-01-02T18:53:07Z","4.0.0":"2022-11-27T02:46:15Z","4.0.1":"2023-01-30T17:45:18Z","4.0.2":"2023-02-05T17:56:13Z","4.0.3":"2023-02-07T23:56:51Z","4.1.0":"2023-02-22T05:48:47Z","4.2.0":"2023-02-22T05:48:47Z","4.2.1":"2023-02-24T05:45:10Z","4.2.2":"2023-02-26T08:52:17Z","4.2.3":"2023-02-26T08:52:17Z","4.2.4":"2023-02-26T08:52:17Z","4.2.5":"2023-03-11T20:47:12Z","4.2.6":"2023-04-09T23:44:04Z","4.2.7":"2023-04-09T23:44:04Z","4.2.8":"2023-04-11T17:48:14Z","5.0.0":"2024-01-02T18:53:07Z","6.0.0":"2023-05-15T05:51:56Z","6.0.1":"2023-05-15T23:44:15Z","6.0.2":"2023-05-17T23:53:08Z","7.0.0":"2023-07-08T02:48:51Z","7.0.1":"2023-07-08T02:48:51Z","7.0.2":"2023-07-17T23:38:58Z","7.0.3":"2023-08-12T20:48:47Z","7.0.4":"2023-12-19T06:18:52Z"}}
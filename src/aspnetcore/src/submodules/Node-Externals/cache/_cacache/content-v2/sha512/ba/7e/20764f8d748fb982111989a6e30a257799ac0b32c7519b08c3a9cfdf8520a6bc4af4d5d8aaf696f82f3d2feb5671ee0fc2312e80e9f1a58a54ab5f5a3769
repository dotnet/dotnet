{"_id":"tapable","_rev":"b729c071-74a9-4859-8ca1-f4c57c8a490b","name":"tapable","dist-tags":{"latest":"2.2.1","beta":"2.0.0-beta.11"},"versions":{"0.1.0":{"_id":"tapable@0.1.0","name":"tapable","description":"Just a little module for plugins.","version":"0.1.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"4b580abd8e4bfa8ff3af6da48a073d7b4f0b1cb8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.0.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_npmVersion":"1.1.65","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.1":{"_id":"tapable@0.1.1","name":"tapable","description":"Just a little module for plugins.","version":"0.1.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"b946d834c832ec85693f9f30bfdbd1dd1ddc9123","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.1.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_npmVersion":"1.1.65","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.2":{"_id":"tapable@0.1.2","name":"tapable","description":"Just a little module for plugins.","version":"0.1.2","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"61bf483a22fcb844783c0e69b22df59382f61ebd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.2.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_npmVersion":"1.1.61","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.3":{"_id":"tapable@0.1.3","name":"tapable","description":"Just a little module for plugins.","version":"0.1.3","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"ac6a31c4016e9a05824bfa156ee76e1b3c8da8f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.3.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_from":".","_npmVersion":"1.3.11","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.4":{"_id":"tapable@0.1.4","name":"tapable","description":"Just a little module for plugins.","version":"0.1.4","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"2482b44b21136ba6464ead9828677da4d2c163f6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.4.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_from":".","_npmVersion":"1.3.17","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.5":{"_id":"tapable@0.1.5","name":"tapable","description":"Just a little module for plugins.","version":"0.1.5","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"e232665c6eb496c590e4f53b684d8b62ea79960d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.5.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_from":".","_npmVersion":"1.3.21","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.6":{"_id":"tapable@0.1.6","name":"tapable","description":"Just a little module for plugins.","version":"0.1.6","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"a9e959cb7e57f019cd8262f88bba32c7ac251b77","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.6.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.7":{"_id":"tapable@0.1.7","name":"tapable","description":"Just a little module for plugins.","version":"0.1.7","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"4ae77c1a6402f58ae0bbc7b99d8000a0ffaf3ef8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.7.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"_from":".","_npmVersion":"1.4.3","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.8":{"_id":"tapable@0.1.8","name":"tapable","description":"Just a little module for plugins.","version":"0.1.8","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"1.3.x","should":"1.1.x"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"a943314bc86ac87602c93fbc8ac609dcb19c199e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.8.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"gitHead":"18ce8ffafc024daa804e57afcac2e3b65202d0dd","_from":".","_npmVersion":"1.4.16","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.9":{"_id":"tapable@0.1.9","name":"tapable","description":"Just a little module for plugins.","version":"0.1.9","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"1003d9499c344ba238cb32329c8d2c8babc92e54","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.9.tgz"},"licenses":[{"type":"MIT","url":"http://www.opensource.org/licenses/mit-license.php"}],"gitHead":"19fedb828e6195d10e2af9e133b54613ff413273","_from":".","_npmVersion":"2.7.4","_nodeVersion":"0.12.2","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.1.10":{"_id":"tapable@0.1.10","name":"tapable","description":"Just a little module for plugins.","version":"0.1.10","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"29c35707c2b70e50d07482b5d202e8ed446dafd4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.1.10.tgz"},"gitHead":"32371f464d721c81f803f7b9440a4c3ddf1dd2bb","_from":".","_npmVersion":"2.10.1","_nodeVersion":"0.12.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.2.1":{"_id":"tapable@0.2.1","name":"tapable","description":"Just a little module for plugins.","version":"0.2.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"b5755d8c561b66975791a1cfa5774b91f4fc5fef","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.1.tgz"},"gitHead":"4a87317ec1225c7b63ecc9f3343afd3d4b19d841","_from":".","_npmVersion":"2.10.1","_nodeVersion":"0.12.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.2.2":{"_id":"tapable@0.2.2","name":"tapable","description":"Just a little module for plugins.","version":"0.2.2","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"fd2f238db9b01ee026044433e274ef2f3dc42742","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.2.tgz"},"gitHead":"06b8aae027e81d42dd94b652c0ae8d923d00ee1b","_from":".","_npmVersion":"2.10.1","_nodeVersion":"0.12.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.2.3":{"_id":"tapable@0.2.3","name":"tapable","description":"Just a little module for plugins.","version":"0.2.3","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"c84cc96699e2c177d6d928dc6476d93115bc0507","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.3.tgz"},"gitHead":"e75cf5bb51c383158b0a377eff9284b94e0e5169","_from":".","_npmVersion":"3.3.3","_nodeVersion":"5.4.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.2.4":{"_id":"tapable@0.2.4","name":"tapable","description":"Just a little module for plugins.","version":"0.2.4","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"a7814605089d4ba896c33c7e3566e13dcd194aa5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.4.tgz"},"gitHead":"88ec6f4f23b2efb95488f4ad1cbd1df09b688fdf","_from":".","_npmVersion":"3.3.3","_nodeVersion":"5.4.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}]},"0.2.5":{"_id":"tapable@0.2.5","name":"tapable","description":"Just a little module for plugins.","version":"0.2.5","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"1ff6ce7ade58e734ca9bfe36ba342304b377a4d0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.5.tgz"},"gitHead":"b8a78d5b70e1c75bd2dcff355c7dda3cbfbf37c6","_from":".","_npmVersion":"3.10.8","_nodeVersion":"6.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"packages-12-west.internal.npmjs.com","tmp":"tmp/tapable-0.2.5.tgz_1480971694096_0.4875433600973338"}},"0.2.6":{"_id":"tapable@0.2.6","name":"tapable","description":"Just a little module for plugins.","version":"0.2.6","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"files":["lib"],"main":"lib/Tapable.js","dist":{"shasum":"206be8e188860b514425375e6f1ae89bfb01fd8d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.6.tgz"},"gitHead":"5bcfb8bfb6e6bdf3a6ec3b891d7dd81f758ba7f6","_from":".","_npmVersion":"3.10.8","_nodeVersion":"6.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"packages-18-east.internal.npmjs.com","tmp":"tmp/tapable-0.2.6.tgz_1484129131595_0.5442721091676503"}},"0.2.7":{"_id":"tapable@0.2.7","name":"tapable","description":"Just a little module for plugins.","version":"0.2.7","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"files":["lib"],"main":"lib/Tapable.js","dist":{"shasum":"e46c0daacbb2b8a98b9b0cea0f4052105817ed5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.7.tgz"},"gitHead":"48d7ef28de3ae77065b04065fdf08f8cf28eb8bf","_from":".","_npmVersion":"3.10.10","_nodeVersion":"6.11.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-0.2.7.tgz_1500529250387_0.9573970471974462"}},"0.2.8":{"_id":"tapable@0.2.8","name":"tapable","description":"Just a little module for plugins.","version":"0.2.8","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"files":["lib"],"main":"lib/Tapable.js","dist":{"shasum":"99372a5c999bf2df160afc0d74bed4f47948cd22","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.8.tgz"},"gitHead":"004df5643c1ac002a16de3ae8962330e1df3599d","_from":".","_npmVersion":"3.10.10","_nodeVersion":"6.11.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-0.2.8.tgz_1501661484636_0.9703884306363761"}},"0.2.9":{"_id":"tapable@0.2.9","name":"tapable","description":"Just a little module for plugins.","version":"0.2.9","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"mocha --reporter spec"},"directories":{},"devDependencies":{"mocha":"^2.2.4","should":"^5.2.0"},"engines":{"node":">=0.6"},"main":"lib/Tapable.js","dist":{"shasum":"af2d8bbc9b04f74ee17af2b4d9048f807acd18a8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-0.2.9.tgz"},"gitHead":"b5eed4c2ce20d9394746cb9a74660e75df490d28","_npmVersion":"5.6.0","_nodeVersion":"8.11.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_0.2.9_1543309817875_0.8941063194920646"},"_hasShrinkwrap":false},"1.0.0-beta.0":{"_id":"tapable@1.0.0-beta.0","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=4.3"},"files":["lib"],"main":"lib/Tapable.js","dist":{"shasum":"214faaa5c38faf34089da57206ff04d39a43302d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.0.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"acb6b2b9d045d481786ef7b8fbd55929941c0da9","_npmVersion":"5.3.0","_nodeVersion":"8.5.0","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.0.tgz_1508164170462_0.8744393973611295"}},"1.0.0-beta.1":{"_id":"tapable@1.0.0-beta.1","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=4.3"},"files":["lib"],"main":"lib/Tapable.js","dist":{"shasum":"393ba614d35909b6ad486102a2f0d437f5f855bc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.1.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"fadf027a001e8c888fc4a6cd5f23e25c9e0f568f","_npmVersion":"5.3.0","_nodeVersion":"8.5.0","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.1.tgz_1508250227439_0.4306126427836716"}},"1.0.0-beta.2":{"_id":"tapable@1.0.0-beta.2","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.2","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=4.3"},"files":["lib"],"main":"lib/index.js","dist":{"shasum":"7510992f5bff47dfad97b58bfe14938391831c28","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.2.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"42b520760e138c23e7808881cb4322557e878307","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.2.tgz_1511795881424_0.9473249402362853"}},"1.0.0-beta.3":{"_id":"tapable@1.0.0-beta.3","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.3","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=4.3"},"files":["lib"],"main":"lib/index.js","dist":{"shasum":"1f56bb6fec924ac9570cd8f6ff788e5bcf4808f1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.3.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"a42da48cc61143f579764e79dc6d1cc1de49e9d0","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.3.tgz_1511796842192_0.35019846027716994"}},"1.0.0-beta.4":{"_id":"tapable@1.0.0-beta.4","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.4","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=6"},"files":["lib"],"main":"lib/index.js","dist":{"shasum":"0b32094cbb6eb217f5dd049fc27c3a7e99705b9e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.4.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"855dfcd3845a3351b0af85becc6aa9942c528180","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.4.tgz_1511967565293_0.9066612883470953"}},"1.0.0-beta.5":{"_id":"tapable@1.0.0-beta.5","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0-beta.5","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=6"},"files":["lib"],"main":"lib/index.js","dist":{"shasum":"9bc844b856487e03345b7d3361288aefd97f8303","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0-beta.5.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"6b91ca9e94cf032420a57a2d0b82b627462b5c1c","_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable-1.0.0-beta.5.tgz_1513081769509_0.8237415389157832"}},"1.0.0":{"_id":"tapable@1.0.0","name":"tapable","description":"Just a little module for plugins.","version":"1.0.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4"},"engines":{"node":">=6"},"files":["lib"],"main":"lib/index.js","dist":{"shasum":"cbb639d9002eed9c6b5975eb20598d7936f1f9f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.0.0.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"f2718e63bfede29cbc81cda3ee79a6933ec5af8d","_npmVersion":"5.6.0","_nodeVersion":"8.9.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_1.0.0_1519286232237_0.7789554413074959"},"_hasShrinkwrap":false},"1.1.0":{"_id":"tapable@1.1.0","name":"tapable","description":"Just a little module for plugins.","version":"1.1.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"0d076a172e3d9ba088fd2272b2668fb8d194b78c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.1.0.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"4b736473267a7634696697c3eab26774ab018286","_npmVersion":"5.6.0","_nodeVersion":"8.11.2","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_1.1.0_1536749586290_0.13956392119105243"},"_hasShrinkwrap":false},"1.1.1":{"_id":"tapable@1.1.1","name":"tapable","description":"Just a little module for plugins.","version":"1.1.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"4d297923c5a72a42360de2ab52dadfaaec00018e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.1.1.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"de0704c4a068e726633313ec41078d68cf55264b","_npmVersion":"5.6.0","_nodeVersion":"8.11.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_1.1.1_1543309855570_0.5950404723215823"},"_hasShrinkwrap":false},"1.1.2":{"_id":"tapable@1.1.2","name":"tapable","description":"Just a little module for plugins.","version":"1.1.2","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"fb6e59d0a436f29bd505388e2185d55ba350d0c6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.1.2.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"2210ed4e50cb67f2936921a0170ee73340c30921","_npmVersion":"6.4.1","_nodeVersion":"10.15.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_1.1.2_1555054341790_0.5937222728326765"},"_hasShrinkwrap":false},"1.1.3":{"_id":"tapable@1.1.3","name":"tapable","description":"Just a little module for plugins.","version":"1.1.3","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra","email":"","url":""},"repository":{"type":"git","url":"http://github.com/webpack/tapable.git"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":null,"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"files":["lib","!lib/__tests__"],"main":"lib/index.js","dist":{"shasum":"a1fccc06b58db61fd7a45da2da44f5f3a3e67ba2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-1.1.3.tgz"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}}},"2.0.0-beta.0":{"_id":"tapable@2.0.0-beta.0","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"46a59f80ca5bd8b3ba13a668afc87f160c32cc15","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.0.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\n\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/* ... */\n\n\tsetSpeed(newSpeed) {\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then(() => {\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"c9d5458cd5199b0980d67e0596ef4e71c9e750c5","_npmVersion":"5.6.0","_nodeVersion":"8.11.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.0_1543310153587_0.6394106684070264"},"_hasShrinkwrap":false},"2.0.0-beta.1":{"_id":"tapable@2.0.0-beta.1","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"d8cc07eb4d215a33c957284ff79120e2f54d20aa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.1.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\n\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/* ... */\n\n\tsetSpeed(newSpeed) {\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then(() => {\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"4a133b8b80a3cd81ce7f5e9b131d9d867f24607e","_npmVersion":"5.6.0","_nodeVersion":"8.11.4","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.1_1544880011706_0.27553903246175504"},"_hasShrinkwrap":false},"2.0.0-beta.2":{"_id":"tapable@2.0.0-beta.2","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.2","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"a12a84c61770ab8536abf8ae3efee108390ab3a2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.2.tgz"},"types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"0d8613c72b6082f4ea7ad690f660ec9a5dd7ec23","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.2_1545381977364_0.4381383095389666"},"_hasShrinkwrap":false},"2.0.0-beta.3":{"_id":"tapable@2.0.0-beta.3","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.3","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"fda2711d315db1c242ac558032548d221dc66418","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.3.tgz"},"types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"b121017afad244fe603be7d2133f1a37c716ce3c","_npmVersion":"6.4.1","_nodeVersion":"10.12.0","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.3_1546593482394_0.07035947454007663"},"_hasShrinkwrap":false},"2.0.0-beta.4":{"_id":"tapable@2.0.0-beta.4","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.4","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"jest --coverage && codecov","pretty":"prettier --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"babel-core":"^6.26.0","babel-jest":"^21.0.2","babel-polyfill":"^6.26.0","babel-preset-env":"^1.6.0","codecov":"^2.3.0","jest":"^21.0.4","prettier":"^1.13.2"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"26a7acfdaa064768020ee909fc5cb7fc8778fb02","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.4.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"d784d4a49bbd3ba3b0a1ba2382d64665d6f61f99","_npmVersion":"6.4.1","_nodeVersion":"10.15.1","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.4_1555054717580_0.40048541949403305"},"_hasShrinkwrap":false},"2.0.0-beta.5":{"_id":"tapable@2.0.0-beta.5","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.5","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"51def4d94c58ad8fadf00cac7661216502fe9c70","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.5.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"30efca93a53143eb1f7708673377be6e6a068034","_nodeVersion":"12.4.0","_npmVersion":"6.9.0","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.5_1560517283910_0.1812510084607073"},"_hasShrinkwrap":false},"2.0.0-beta.6":{"_id":"tapable@2.0.0-beta.6","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.6","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"d7f122ec617747806294bc44386b959476ee90a9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.6.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"577543a01c331023db67cf8d2da4c7ca7dc19866","_nodeVersion":"12.4.0","_npmVersion":"6.9.0","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.6_1562676107801_0.12615982687360372"},"_hasShrinkwrap":false},"2.0.0-beta.7":{"_id":"tapable@2.0.0-beta.7","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.7","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"b290366cf8a4486b9c5db3ba3f16daa3daf34013","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.7.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"e225fbaf8cbd1fea381290edc6384e3dae2b5cb0","_nodeVersion":"12.4.0","_npmVersion":"6.9.0","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.7_1562677187582_0.704341253368407"},"_hasShrinkwrap":false},"2.0.0-beta.8":{"_id":"tapable@2.0.0-beta.8","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.8","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"0a8d42f6895d43d5a895de15d9a9e3e425f72a0a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.8.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.tap(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.tapAsync(\"some-key\", \"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.tapPromise(\"some-key\", \"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\ttap: (key: any, name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (key: any, name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (key: any, name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"14fbef85bef0b6682ebf24f5b241ab19c617e158","_nodeVersion":"12.4.0","_npmVersion":"6.9.0","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.8_1562679924778_0.2288356709884427"},"_hasShrinkwrap":false},"2.0.0-beta.9":{"_id":"tapable@2.0.0-beta.9","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.9","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"638496fb27b53e69c21a0e6a4435afbe805845cb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.9.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.for(\"some-key\").tap(\"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapAsync(\"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapPromise(\"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean,\n\tbefore?: string | Array\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"747a66766f8be92eead47f312f39dc84c00ff054","_nodeVersion":"12.13.0","_npmVersion":"6.12.0","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.9_1576855818256_0.6189577538314641"},"_hasShrinkwrap":false},"2.0.0-beta.10":{"_id":"tapable@2.0.0-beta.10","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.10","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"54a95a1f6be6c65d2d8aa4eda2562325ff6c2a1e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.10.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.for(\"some-key\").tap(\"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapAsync(\"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapPromise(\"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean,\n\tbefore?: string | Array\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"75fcb00e84922de8cb0ecb9840c59b68c5ced0d3","_nodeVersion":"13.7.0","_npmVersion":"6.13.6","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.10_1583862141444_0.6298353164822188"},"_hasShrinkwrap":false},"2.0.0-beta.11":{"_id":"tapable@2.0.0-beta.11","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0-beta.11","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"5a6bd5e0353fad4da9e94942206bb596639e8cf7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0-beta.11.tgz"},"readme":"# Tapable\n\nThe tapable package expose many Hook classes, which can be used to create hooks for plugins.\n\n``` javascript\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tSyncLoopHook,\n\tAsyncParallelHook,\n\tAsyncParallelBailHook,\n\tAsyncSeriesHook,\n\tAsyncSeriesBailHook,\n\tAsyncSeriesWaterfallHook\n } = require(\"tapable\");\n```\n\n## Installation\n\n``` shell\nnpm install --save tapable\n```\n\n## Usage\n\nAll Hook constructors take one optional argument, which is a list of argument names as strings.\n\n``` js\nconst hook = new SyncHook([\"arg1\", \"arg2\", \"arg3\"]);\n```\n\nThe best practice is to expose all hooks of a class in a `hooks` property:\n\n``` js\nclass Car {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\taccelerate: new SyncHook([\"newSpeed\"]),\n\t\t\tbrake: new SyncHook(),\n\t\t\tcalculateRoutes: new AsyncParallelHook([\"source\", \"target\", \"routesList\"])\n\t\t};\n\t}\n\n\t/* ... */\n}\n```\n\nOther people can now use these hooks:\n\n``` js\nconst myCar = new Car();\n\n// Use the tap method to add a consument\nmyCar.hooks.brake.tap(\"WarningLampPlugin\", () => warningLamp.on());\n```\n\nIt's required to pass a name to identify the plugin/reason.\n\nYou may receive arguments:\n\n``` js\nmyCar.hooks.accelerate.tap(\"LoggerPlugin\", newSpeed => console.log(`Accelerating to ${newSpeed}`));\n```\n\nFor sync hooks, `tap` is the only valid method to add a plugin. Async hooks also support async plugins:\n\n``` js\nmyCar.hooks.calculateRoutes.tapPromise(\"GoogleMapsPlugin\", (source, target, routesList) => {\n\t// return a promise\n\treturn google.maps.findRoute(source, target).then(route => {\n\t\troutesList.add(route);\n\t});\n});\nmyCar.hooks.calculateRoutes.tapAsync(\"BingMapsPlugin\", (source, target, routesList, callback) => {\n\tbing.findRoute(source, target, (err, route) => {\n\t\tif(err) return callback(err);\n\t\troutesList.add(route);\n\t\t// call the callback\n\t\tcallback();\n\t});\n});\n\n// You can still use sync plugins\nmyCar.hooks.calculateRoutes.tap(\"CachedRoutesPlugin\", (source, target, routesList) => {\n\tconst cachedRoute = cache.get(source, target);\n\tif(cachedRoute)\n\t\troutesList.add(cachedRoute);\n})\n```\nThe class declaring these hooks need to call them:\n\n``` js\nclass Car {\n\t/**\n\t  * You won't get returned value from SyncHook or AsyncParallelHook,\n\t  * to do that, use SyncWaterfallHook and AsyncSeriesWaterfallHook respectively\n\t **/\n\n\tsetSpeed(newSpeed) {\n\t\t// following call returns undefined even when you returned values\n\t\tthis.hooks.accelerate.call(newSpeed);\n\t}\n\n\tuseNavigationSystemPromise(source, target) {\n\t\tconst routesList = new List();\n\t\treturn this.hooks.calculateRoutes.promise(source, target, routesList).then((res) => {\n\t\t\t// res is undefined for AsyncParallelHook\n\t\t\treturn routesList.getRoutes();\n\t\t});\n\t}\n\n\tuseNavigationSystemAsync(source, target, callback) {\n\t\tconst routesList = new List();\n\t\tthis.hooks.calculateRoutes.callAsync(source, target, routesList, err => {\n\t\t\tif(err) return callback(err);\n\t\t\tcallback(null, routesList.getRoutes());\n\t\t});\n\t}\n}\n```\n\nThe Hook will compile a method with the most efficient way of running your plugins. It generates code depending on:\n* The number of registered plugins (none, one, many)\n* The kind of registered plugins (sync, async, promise)\n* The used call method (sync, async, promise)\n* The number of arguments\n* Whether interception is used\n\nThis ensures fastest possible execution.\n\n## Hook types\n\nEach hook can be tapped with one or several functions. How they are executed depends on the hook type:\n\n* Basic hook (without “Waterfall”, “Bail” or “Loop” in its name). This hook simply calls every function it tapped in a row.\n\n* __Waterfall__. A waterfall hook also calls each tapped function in a row. Unlike the basic hook, it passes a return value from each function to the next function.\n\n* __Bail__. A bail hook allows exiting early. When any of the tapped function returns anything, the bail hook will stop executing the remaining ones.\n\n* __Loop__. TODO\n\nAdditionally, hooks can be synchronous or asynchronous. To reflect this, there’re “Sync”, “AsyncSeries”, and “AsyncParallel” hook classes:\n\n* __Sync__. A sync hook can only be tapped with synchronous functions (using `myHook.tap()`).\n\n* __AsyncSeries__. An async-series hook can be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). They call each async method in a row.\n\n* __AsyncParallel__. An async-parallel hook can also be tapped with synchronous, callback-based and promise-based functions (using `myHook.tap()`, `myHook.tapAsync()` and `myHook.tapPromise()`). However, they run each async method in parallel.\n\nThe hook type is reflected in its class name. E.g., `AsyncSeriesWaterfallHook` allows asynchronous functions and runs them in series, passing each function’s return value into the next function.\n\n\n## Interception\n\nAll Hooks offer an additional interception API:\n\n``` js\nmyCar.hooks.calculateRoutes.intercept({\n\tcall: (source, target, routesList) => {\n\t\tconsole.log(\"Starting to calculate routes\");\n\t},\n\tregister: (tapInfo) => {\n\t\t// tapInfo = { type: \"promise\", name: \"GoogleMapsPlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing its job`);\n\t\treturn tapInfo; // may return a new tapInfo object\n\t}\n})\n```\n\n**call**: `(...args) => void` Adding `call` to your interceptor will trigger when hooks are triggered. You have access to the hooks arguments.\n\n**tap**: `(tap: Tap) => void` Adding `tap` to your interceptor will trigger when a plugin taps into a hook. Provided is the `Tap` object. `Tap` object can't be changed.\n\n**loop**: `(...args) => void` Adding `loop` to your interceptor will trigger for each loop of a looping hook.\n\n**register**: `(tap: Tap) => Tap | undefined` Adding `register` to your interceptor will trigger for each added `Tap` and allows to modify it.\n\n## Context\n\nPlugins and interceptors can opt-in to access an optional `context` object, which can be used to pass arbitrary values to subsequent plugins and interceptors.\n\n``` js\nmyCar.hooks.accelerate.intercept({\n\tcontext: true,\n\ttap: (context, tapInfo) => {\n\t\t// tapInfo = { type: \"sync\", name: \"NoisePlugin\", fn: ... }\n\t\tconsole.log(`${tapInfo.name} is doing it's job`);\n\n\t\t// `context` starts as an empty object if at least one plugin uses `context: true`.\n\t\t// If no plugins use `context: true`, then `context` is undefined.\n\t\tif (context) {\n\t\t\t// Arbitrary properties can be added to `context`, which plugins can then access.\n\t\t\tcontext.hasMuffler = true;\n\t\t}\n\t}\n});\n\nmyCar.hooks.accelerate.tap({\n\tname: \"NoisePlugin\",\n\tcontext: true\n}, (context, newSpeed) => {\n\tif (context && context.hasMuffler) {\n\t\tconsole.log(\"Silence...\");\n\t} else {\n\t\tconsole.log(\"Vroom!\");\n\t}\n});\n```\n\n## HookMap\n\nA HookMap is a helper class for a Map with Hooks\n\n``` js\nconst keyedHook = new HookMap(key => new SyncHook([\"arg\"]))\n```\n\n``` js\nkeyedHook.for(\"some-key\").tap(\"MyPlugin\", (arg) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapAsync(\"MyPlugin\", (arg, callback) => { /* ... */ });\nkeyedHook.for(\"some-key\").tapPromise(\"MyPlugin\", (arg) => { /* ... */ });\n```\n\n``` js\nconst hook = keyedHook.get(\"some-key\");\nif(hook !== undefined) {\n\thook.callAsync(\"arg\", err => { /* ... */ });\n}\n```\n\n## Hook/HookMap interface\n\nPublic:\n\n``` ts\ninterface Hook {\n\ttap: (name: string | Tap, fn: (context?, ...args) => Result) => void,\n\ttapAsync: (name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) => void) => void) => void,\n\ttapPromise: (name: string | Tap, fn: (context?, ...args) => Promise<Result>) => void,\n\tintercept: (interceptor: HookInterceptor) => void\n}\n\ninterface HookInterceptor {\n\tcall: (context?, ...args) => void,\n\tloop: (context?, ...args) => void,\n\ttap: (context?, tap: Tap) => void,\n\tregister: (tap: Tap) => Tap,\n\tcontext: boolean\n}\n\ninterface HookMap {\n\tfor: (key: any) => Hook,\n\tintercept: (interceptor: HookMapInterceptor) => void\n}\n\ninterface HookMapInterceptor {\n\tfactory: (key: any, hook: Hook) => Hook\n}\n\ninterface Tap {\n\tname: string,\n\ttype: string\n\tfn: Function,\n\tstage: number,\n\tcontext: boolean,\n\tbefore?: string | Array\n}\n```\n\nProtected (only for the class containing the hook):\n\n``` ts\ninterface Hook {\n\tisUsed: () => boolean,\n\tcall: (...args) => Result,\n\tpromise: (...args) => Promise<Result>,\n\tcallAsync: (...args, callback: (err, result: Result) => void) => void,\n}\n\ninterface HookMap {\n\tget: (key: any) => Hook | undefined,\n\tfor: (key: any) => Hook\n}\n```\n\n## MultiHook\n\nA helper Hook-like class to redirect taps to multiple other hooks:\n\n``` js\nconst { MultiHook } = require(\"tapable\");\n\nthis.hooks.allHooks = new MultiHook([this.hooks.hookA, this.hooks.hookB]);\n```\n","types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"readmeFilename":"README.md","gitHead":"2e61d77a22cde4e8899a473ec7a625897287acde","_nodeVersion":"14.0.0","_npmVersion":"6.14.4","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0-beta.11_1589549440739_0.8880069714665995"},"_hasShrinkwrap":false},"2.0.0":{"_id":"tapable@2.0.0","name":"tapable","description":"Just a little module for plugins.","version":"2.0.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"a49c3d6a8a2bb606e7db372b82904c970d537a08","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.0.0.tgz"},"types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"fa54822199203163a13b5bf7e403abc118ce3a87","_nodeVersion":"14.9.0","_npmVersion":"6.14.8","maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.0.0_1600382878136_0.801814746317927"},"_hasShrinkwrap":false},"2.1.0":{"_id":"tapable@2.1.0","name":"tapable","description":"Just a little module for plugins.","version":"2.1.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"5a9701fe2ce5602c9899f41f6bfbc944c8b2f209","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.1.0.tgz"},"types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"0c4aacb0578d82e02434e8d6e390cc462174d2d6","_nodeVersion":"14.9.0","_npmVersion":"6.14.8","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.1.0_1604914163114_0.36694484012036366"},"_hasShrinkwrap":false},"2.1.1":{"_id":"tapable@2.1.1","name":"tapable","description":"Just a little module for plugins.","version":"2.1.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra"},"repository":{"type":"git","url":"git+ssh://git@github.com/webpack/tapable.git"},"bugs":{"url":"https://github.com/webpack/tapable/issues"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":{},"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"main":"lib/index.js","dist":{"shasum":"b01cc1902d42a7bb30514e320ce21c456f72fd3f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.1.1.tgz"},"types":"./tapable.d.ts","jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}},"gitHead":"a3cb3ae77035012a470ca5b5ac8ec627550d4700","_nodeVersion":"14.9.0","_npmVersion":"6.14.8","_npmUser":{"name":"sokra","email":"tobias.koppers@googlemail.com"},"maintainers":[{"name":"sokra","email":"tobias.koppers@googlemail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/tapable_2.1.1_1604917749685_0.2597182598451029"},"_hasShrinkwrap":false},"2.2.0":{"_id":"tapable@2.2.0","name":"tapable","description":"Just a little module for plugins.","version":"2.2.0","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra","email":"","url":""},"repository":{"type":"git","url":"http://github.com/webpack/tapable.git"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":null,"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"files":["lib","!lib/__tests__","tapable.d.ts"],"main":"lib/index.js","dist":{"shasum":"5c373d281d9c672848213d0e037d1c4165ab426b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.2.0.tgz"},"types":"./tapable.d.ts","browser":{"util":"./lib/util-browser.js"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}}},"2.2.1":{"_id":"tapable@2.2.1","name":"tapable","description":"Just a little module for plugins.","version":"2.2.1","homepage":"https://github.com/webpack/tapable","author":{"name":"Tobias Koppers @sokra","email":"","url":""},"repository":{"type":"git","url":"http://github.com/webpack/tapable.git"},"license":"MIT","scripts":{"test":"jest","travis":"yarn pretty-lint && jest --coverage && codecov","pretty-lint":"prettier --check lib/*.js lib/__tests__/*.js","pretty":"prettier --loglevel warn --write lib/*.js lib/__tests__/*.js"},"directories":null,"devDependencies":{"@babel/core":"^7.4.4","@babel/preset-env":"^7.4.4","babel-jest":"^24.8.0","codecov":"^3.5.0","jest":"^24.8.0","prettier":"^1.17.1"},"engines":{"node":">=6"},"files":["lib","!lib/__tests__","tapable.d.ts"],"main":"lib/index.js","dist":{"shasum":"1967a73ef4060a82f12ab96af86d52fdb76eeca0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/tapable/-/tapable-2.2.1.tgz"},"types":"./tapable.d.ts","browser":{"util":"./lib/util-browser.js"},"jest":{"transform":{"__tests__[\\\\/].+\\.js$":"babel-jest"}}}},"time":{"created":"2022-06-15T16:25:17Z","modified":"2022-08-17T01:12:41Z","0.1.0":"2022-06-15T16:25:17Z","0.1.1":"2022-06-15T16:25:17Z","0.1.2":"2022-06-15T16:25:17Z","0.1.3":"2022-06-15T16:25:17Z","0.1.4":"2022-06-15T16:25:17Z","0.1.5":"2022-06-15T16:25:17Z","0.1.6":"2022-06-15T16:25:17Z","0.1.7":"2022-06-15T16:25:17Z","0.1.8":"2022-06-15T16:25:17Z","0.1.9":"2022-06-15T16:25:17Z","0.1.10":"2022-06-15T16:25:17Z","0.2.1":"2022-06-15T16:25:17Z","0.2.2":"2022-06-15T16:25:17Z","0.2.3":"2022-06-15T16:25:17Z","0.2.4":"2022-06-15T16:25:17Z","0.2.5":"2022-06-15T16:25:17Z","0.2.6":"2022-06-15T16:25:17Z","0.2.7":"2022-06-15T16:25:17Z","0.2.8":"2022-06-15T16:25:17Z","0.2.9":"2022-06-15T16:25:17Z","1.0.0-beta.0":"2022-06-15T16:25:17Z","1.0.0-beta.1":"2022-06-15T16:25:17Z","1.0.0-beta.2":"2022-06-15T16:25:17Z","1.0.0-beta.3":"2022-06-15T16:25:17Z","1.0.0-beta.4":"2022-06-15T16:25:17Z","1.0.0-beta.5":"2022-06-15T16:25:17Z","1.0.0":"2022-06-15T16:25:17Z","1.1.0":"2022-06-15T16:25:17Z","1.1.1":"2022-06-15T16:25:17Z","1.1.2":"2022-06-15T16:25:17Z","1.1.3":"2022-06-15T16:33:55Z","2.0.0-beta.0":"2022-06-15T16:25:17Z","2.0.0-beta.1":"2022-06-15T16:25:17Z","2.0.0-beta.2":"2022-06-15T16:25:17Z","2.0.0-beta.3":"2022-06-15T16:25:17Z","2.0.0-beta.4":"2022-06-15T16:25:17Z","2.0.0-beta.5":"2022-06-15T16:25:17Z","2.0.0-beta.6":"2022-06-15T16:25:17Z","2.0.0-beta.7":"2022-06-15T16:25:17Z","2.0.0-beta.8":"2022-06-15T16:25:17Z","2.0.0-beta.9":"2022-06-15T16:25:17Z","2.0.0-beta.10":"2022-06-15T16:25:17Z","2.0.0-beta.11":"2022-06-15T16:25:17Z","2.0.0":"2022-06-15T16:25:17Z","2.1.0":"2022-06-15T16:25:17Z","2.1.1":"2022-06-15T16:25:17Z","2.2.0":"2022-08-17T01:12:41Z","2.2.1":"2022-06-28T23:23:57Z"}}
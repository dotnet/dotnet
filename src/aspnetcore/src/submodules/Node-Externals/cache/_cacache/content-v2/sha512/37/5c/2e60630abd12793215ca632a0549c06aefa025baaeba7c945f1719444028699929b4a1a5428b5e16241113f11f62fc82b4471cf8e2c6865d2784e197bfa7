{"_id":"jest-worker","_rev":"bbe89c84-7633-4fbd-a05a-b1c9957fd1cc","name":"jest-worker","dist-tags":{"latest":"29.7.0","next":"30.0.0-alpha.3"},"versions":{"0.0.0":{"_id":"jest-worker@0.0.0","name":"jest-worker","version":"0.0.0","directories":{},"dist":{"shasum":"734cb5626b50b7d9b4ad88f35a93c22a47c0515b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-0.0.0.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-0.0.0.tgz_1507029176458_0.6641926621086895"}},"21.2.1":{"_id":"jest-worker@21.2.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.2.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"231a24007e73f5faa647d7bc02761d8fad957d73","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.2.1.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.2.1.tgz_1509493688681_0.9927847944200039"}},"21.3.0-beta.1":{"_id":"jest-worker@21.3.0-beta.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"a2192b160c3791ed60a72f6459eed436b581c0b2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.1.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.1.tgz_1507114114509_0.4065683470107615"}},"21.3.0-beta.2":{"_id":"jest-worker@21.3.0-beta.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"05eba2afe4bffffdba6fb0a49016b628382b8234","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.2.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.2.tgz_1507888444113_0.31019993452355266"}},"21.3.0-beta.3":{"_id":"jest-worker@21.3.0-beta.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"c318d690f7d264c736bae919d853403cfc0fab4c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.3.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.3.tgz_1508960043873_0.7625195428263396"}},"21.3.0-beta.4":{"_id":"jest-worker@21.3.0-beta.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"be04b3cc77e8eecddeb9fba66a863d2ba1012f15","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.4.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.4.tgz_1509024413898_0.5665347420144826"}},"21.3.0-beta.5":{"_id":"jest-worker@21.3.0-beta.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"ca603413fa37f7ff0979411c88c9a26500eb9fcf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.5.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.5.tgz_1509628646954_0.8366929683834314"}},"21.3.0-beta.6":{"_id":"jest-worker@21.3.0-beta.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"519de691e5ea9d6b6ef0c93c6808a55d86fdc39d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.6.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.6.tgz_1509726090239_0.1286516182590276"}},"21.3.0-beta.7":{"_id":"jest-worker@21.3.0-beta.7","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.7","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"87eab35587bda9482f0a6290a524876140e723a0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.7.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.7.tgz_1509961184877_0.7800029458012432"}},"21.3.0-beta.8":{"_id":"jest-worker@21.3.0-beta.8","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.8","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"c8109f1e0f916e4f5f9c27a027dd339cb7952b5e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.8.tgz"},"_npmVersion":"5.3.0","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.8.tgz_1510076616801_0.11614330834709108"}},"21.3.0-beta.9":{"_id":"jest-worker@21.3.0-beta.9","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.9","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"0be9bf38ea7e77a22d21d01098e90e0ce8a7867f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.9.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.9.tgz_1511356651408_0.722123100887984"}},"21.3.0-beta.10":{"_id":"jest-worker@21.3.0-beta.10","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.10","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"326bfe0ba591a398bfeb4a590925ddc206747e13","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.10.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.10.tgz_1511613563790_0.9269310683012009"}},"21.3.0-beta.11":{"_id":"jest-worker@21.3.0-beta.11","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.11","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"b29cf211f7cad6316a93c5b7c698c770a5ff459e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.11.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.11.tgz_1511965878104_0.7202728148549795"}},"21.3.0-beta.12":{"_id":"jest-worker@21.3.0-beta.12","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.12","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"cfd3400df18bee0f8d038b0d15d9125089d939c3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.12.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.12.tgz_1512499714269_0.6539331250824034"}},"21.3.0-beta.13":{"_id":"jest-worker@21.3.0-beta.13","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.13","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"17c467b8e9711cf50240e3dfdc5bbaf2d2125100","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.13.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.13.tgz_1512571027944_0.11341526359319687"}},"21.3.0-beta.14":{"_id":"jest-worker@21.3.0-beta.14","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.14","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"4247db4f55903612eb41b609d16663c864946e74","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.14.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.2.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.14.tgz_1513075954573_0.14793565426953137"}},"21.3.0-beta.15":{"_id":"jest-worker@21.3.0-beta.15","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"21.3.0-beta.15","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"bef2fccaff63712bcbc1b9e3087cb4ff989b7ae7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-21.3.0-beta.15.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.2.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"name":"cpojer","email":"christoph.pojer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-21.3.0-beta.15.tgz_1513344457178_0.4429902534466237"}},"22.0.0":{"_id":"jest-worker@22.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"4a276938a2077e1d72b6a2acd1d43826a9fd07f8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.0.0.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.0.0.tgz_1513595003541_0.27948045008815825"}},"22.0.1":{"_id":"jest-worker@22.0.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.0.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"6f9353e91a624ac44ee0b14f38bf43a62e5aa34e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.0.1.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.2.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.0.1.tgz_1513628964125_0.5104117873124778"}},"22.0.2":{"_id":"jest-worker@22.0.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.0.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"b93c2a06dfa38ec026dbde041ac60901c05ab6d6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.0.2.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.2.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.0.2.tgz_1513691584130_0.6812368561513722"}},"22.0.3":{"_id":"jest-worker@22.0.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.0.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"30433faca67814a8f80559f75ab2ceaa61332fd2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.0.3.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.2.1","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.0.3.tgz_1513695534162_0.375342208892107"}},"22.0.6":{"_id":"jest-worker@22.0.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.0.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"1998ac7ab24a6eee4deddec76efe7742f2651504","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.0.6.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.3.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.0.6.tgz_1515664004493_0.058518264908343554"}},"22.1.0":{"_id":"jest-worker@22.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"0987832fe58fbdc205357f4c19b992446368cafb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.1.0.tgz"},"_npmVersion":"5.6.0","_nodeVersion":"9.4.0","_npmUser":{"name":"cpojer","email":"christoph.pojer@gmail.com"},"maintainers":[{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"christoph.pojer@gmail.com","name":"cpojer"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker-22.1.0.tgz_1516017434237_0.7194203475955874"}},"22.2.0":{"_id":"jest-worker@22.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.2.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"d88d6ee176d6409f206cbbf7b485250793264262","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.2.0.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_22.2.0_1517999159676_0.2637796202018099"},"_hasShrinkwrap":false},"22.2.2":{"_id":"jest-worker@22.2.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.2.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"c1f5dc39976884b81f68ec50cb8532b2cbab3390","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.2.2.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_22.2.2_1518193692981_0.36704386466582917"},"_hasShrinkwrap":false},"22.4.3":{"_id":"jest-worker@22.4.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"22.4.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"5c421417cba1c0abf64bf56bd5fb7968d79dd40b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-22.4.3.tgz"},"_npmVersion":"5.5.1","_nodeVersion":"8.9.1","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_22.4.3_1521648488870_0.18498585957563685"},"_hasShrinkwrap":false},"23.0.0-alpha.0":{"_id":"jest-worker@23.0.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"7f8db5e97d4f6cdff199d726585daadde52a4694","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.0.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.0_1521125735690_0.3681409112796552"},"_hasShrinkwrap":false},"23.0.0-alpha.1":{"_id":"jest-worker@23.0.0-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"489e47641b7f360f1a305eeda38642d6874d7660","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.1_1521648014071_0.6960559003266771"},"_hasShrinkwrap":false},"23.0.0-alpha.2":{"_id":"jest-worker@23.0.0-alpha.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.2","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"ad16c80e3b73822f22319ef323ac12fecb66d9b9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.2_1522060847156_0.5509658409029636"},"_hasShrinkwrap":false},"23.0.0-alpha.4":{"_id":"jest-worker@23.0.0-alpha.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.4","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"e16bee22d0f6b0187ff13c5093edd6807b02c868","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.4_1522067499337_0.9032334426184534"},"_hasShrinkwrap":false},"23.0.0-alpha.5":{"_id":"jest-worker@23.0.0-alpha.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.5","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"003d3b106b126070c5c563b20d48cf2141df0f44","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.5.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.5_1523387898706_0.20845530536284618"},"_hasShrinkwrap":false},"23.0.0-alpha.7":{"_id":"jest-worker@23.0.0-alpha.7","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.7","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"d58131933610cfea2daaafb2d4afea7f9ad63c87","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.7.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.7_1523991310864_0.893980803381144"},"_hasShrinkwrap":false},"23.0.0-alpha.3r":{"_id":"jest-worker@23.0.0-alpha.3r","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.3r","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"a88b777a30b978828e8e67390e1587f02270bbdc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.3r.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.3r_1525093811702_0.7366269195950377"},"_hasShrinkwrap":false},"23.0.0-alpha.5r":{"_id":"jest-worker@23.0.0-alpha.5r","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.5r","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"20ab007ec743d886d843b3da4f23a5f8441ba18a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.5r.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.5r_1523425969034_0.7713974098971996"},"_hasShrinkwrap":false},"23.0.0-alpha.6r":{"_id":"jest-worker@23.0.0-alpha.6r","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-alpha.6r","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"26cd8c2e37a2209788c673d71ad4cbbaec717b2f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-alpha.6r.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-alpha.6r_1523516494677_0.8680124888922869"},"_hasShrinkwrap":false},"23.0.0-beta.0":{"_id":"jest-worker@23.0.0-beta.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-beta.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"adabe2cd458cf88a06530ba731f60138a6f0db30","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-beta.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-beta.0_1524219033272_0.009274239883118485"},"_hasShrinkwrap":false},"23.0.0-beta.1":{"_id":"jest-worker@23.0.0-beta.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-beta.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"2e3f815a0dc947f283138115bf06707c24c71043","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-beta.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-beta.1_1524325463703_0.3765296828270117"},"_hasShrinkwrap":false},"23.0.0-beta.2":{"_id":"jest-worker@23.0.0-beta.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-beta.2","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"40ef277824e9f1a1cac47c127a6193c0f0c4f95f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-beta.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-beta.2_1524777456320_0.6331109426207158"},"_hasShrinkwrap":false},"23.0.0-beta.3r":{"_id":"jest-worker@23.0.0-beta.3r","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-beta.3r","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"80c8894131de793a7be6ff7aa91ecaf53f947533","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-beta.3r.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-beta.3r_1525094094507_0.860665422353958"},"_hasShrinkwrap":false},"23.0.0-charlie.0":{"_id":"jest-worker@23.0.0-charlie.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-charlie.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"b4e328a1cd4bbcea460e76f2d304112ad4d1a407","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-charlie.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-charlie.0_1525258583596_0.9557692703093459"},"_hasShrinkwrap":false},"23.0.0-charlie.1":{"_id":"jest-worker@23.0.0-charlie.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-charlie.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"ac8212ee454808a21b617a72a3c7678a3b29b0e6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-charlie.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-charlie.1_1525349415052_0.16603752126685078"},"_hasShrinkwrap":false},"23.0.0-charlie.2":{"_id":"jest-worker@23.0.0-charlie.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-charlie.2","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"b9c5843cb659bcd724ba872666edef327c9893cb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-charlie.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-charlie.2_1526377885834_0.7860545292282195"},"_hasShrinkwrap":false},"23.0.0-charlie.3":{"_id":"jest-worker@23.0.0-charlie.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-charlie.3","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"851a8e15e1891cf32f89653a222ce3ea1bc0ab83","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-charlie.3.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-charlie.3_1527001139088_0.2619355062458322"},"_hasShrinkwrap":false},"23.0.0-charlie.4":{"_id":"jest-worker@23.0.0-charlie.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0-charlie.4","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"606b9181425db8c5924b9af6761c4002f55adc48","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0-charlie.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","readmeFilename":"README.md","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0-charlie.4_1527072137074_0.17914931157823255"},"_hasShrinkwrap":false},"23.0.0":{"_id":"jest-worker@23.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"e6b1378b81f8e6a108f3be33a1faa830c22ea450","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.0.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.0_1527182785049_0.8521930410306562"},"_hasShrinkwrap":false},"23.0.1":{"_id":"jest-worker@23.0.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.0.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"9e649dd963ff4046026f91c4017f039a6aa4a7bc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.0.1.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.0.1_1527435055492_0.47630399545728186"},"_hasShrinkwrap":false},"23.2.0":{"_id":"jest-worker@23.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"23.2.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"faf706a8da36fae60eb26957257fa7b5d8ea02b9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-23.2.0.tgz"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_23.2.0_1529935514523_0.06039057485118593"},"_hasShrinkwrap":false},"24.0.0-alpha.0":{"_id":"jest-worker@24.0.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"61d5c79479dc174e1f88d9979ae75cee2130fdd2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"22f67d49ffcce7a5b6d6891438b837b3b26ba9db","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.0_1539951161616_0.7814093350008589"},"_hasShrinkwrap":false},"24.0.0-alpha.1":{"_id":"jest-worker@24.0.0-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"7b82ab2e534cf66640c42715d0a8f16b1ad5cdeb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"4954f46708415174c48a58f296a605fbe1244a31","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"mjesun@hotmail.com","name":"mjesun"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.1_1540222548747_0.7561586816865975"},"_hasShrinkwrap":false},"24.0.0-alpha.2":{"_id":"jest-worker@24.0.0-alpha.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"d376b328094dd5f1e0c6156b4f41b308a99a35bd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.2.tgz"},"gitHead":"c5e36835cff4b241327db9cf58c8f6f7227ed1f7","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.2_1540464657246_0.6694456870838097"},"_hasShrinkwrap":false},"24.0.0-alpha.4":{"_id":"jest-worker@24.0.0-alpha.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"6766d11b66e7b2d61f79711d159125657084d021","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"e41f0bb257c6652c3100b97a1087f9f812fbea0d","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.4_1540571594503_0.5234640823029466"},"_hasShrinkwrap":false},"24.0.0-alpha.5":{"_id":"jest-worker@24.0.0-alpha.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"82c3d64274f5134ec9df03d1a159ee4dd710c03d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.5.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"2c18a53e8ff2437bba5fcb8076b754ac5f79f9f8","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.5_1541769164930_0.617883942264494"},"_hasShrinkwrap":false},"24.0.0-alpha.6":{"_id":"jest-worker@24.0.0-alpha.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"463681b92c117c57107135c14b9b9d6cd51d80ce","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.6.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"49d08403a941e596eda1279c07a1eaf4d4a73dad","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.6_1541785780717_0.49043937866079834"},"_hasShrinkwrap":false},"24.0.0-alpha.7":{"_id":"jest-worker@24.0.0-alpha.7","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.7","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"main":"build/index.js","dist":{"shasum":"1c593cba7530c2a1c66460692fd1f891b01e60fa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.7.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"4954f46708415174c48a58f296a605fbe1244a31","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.7_1544544469882_0.4194998533265395"},"_hasShrinkwrap":false},"24.0.0-alpha.8":{"_id":"jest-worker@24.0.0-alpha.8","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.8","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"95fac45db2dc1f40654012ce1acac83d4d31fec6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.8.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n","gitHead":"700e0dadb85f5dc8ff5dac6c7e98956690049734","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.10.0","_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.8_1544730472581_0.04718290546743309"},"_hasShrinkwrap":false},"24.0.0-alpha.9":{"_id":"jest-worker@24.0.0-alpha.9","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.9","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^5.5.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"2d8a35687744461b5aa8ed553dc4d5a5da2ceab8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.9.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"c7caa7ba5904d0c61e586694cde5f536639e4afc","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.9_1545229550308_0.9967062755230511"},"_hasShrinkwrap":false},"24.0.0-alpha.10":{"_id":"jest-worker@24.0.0-alpha.10","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.10","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^5.5.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"046702c758ae3214cd279e602055a26b066122be","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.10.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"722049ccd66947d48296dcb666bc99fccab86065","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.10_1547053460870_0.3169135777345684"},"_hasShrinkwrap":false},"24.0.0-alpha.11":{"_id":"jest-worker@24.0.0-alpha.11","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.11","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^5.5.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"3cae89bb8ffcd52a2859164bbd8697fcc160456d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.11.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"6a066c6afe2ae08669a27d3b703a6cf0d898e7b7","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.11_1547145298337_0.30812601552155683"},"_hasShrinkwrap":false},"24.0.0-alpha.12":{"_id":"jest-worker@24.0.0-alpha.12","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.12","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^5.5.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"b7ca1fb774b4eddc342768b7a63d89be5e6a762f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.12.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"4f2bcb861d1f0fb150c05970362e52a38c31f67e","readmeFilename":"README.md","_npmVersion":"5.6.0","_nodeVersion":"8.11.3","_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.12_1547218867535_0.10605551597684992"},"_hasShrinkwrap":false},"24.0.0-alpha.13":{"_id":"jest-worker@24.0.0-alpha.13","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.13","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"388d2136af6bdda63e27d5f0f5a09c671cccda3e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.13.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nWe will use worker threads where available. To enable in Node 10+, run the Node process with the `--experimental-worker` flag.\n\nYou can explicitly opt-out of this by passing `disableWorkerThreads: true`.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `disableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available and use them. However, running under threads comes with [some caveats](https://nodejs.org/api/worker_threads.html#worker_threads_class_worker), and is still experimental, so you can `opt-out` of this and use `disableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"6de22dde9a10f775adc7b6f80080bdd224f6ae31","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.13_1548256528478_0.23551729449690217"},"_hasShrinkwrap":false},"24.0.0-alpha.14":{"_id":"jest-worker@24.0.0-alpha.14","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.14","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"c3b76400d9d9dce866a308916a9f290a2bed6634","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.14.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"28971c5f794330e8acc6861288e6daafcd32238e","readmeFilename":"README.md","_nodeVersion":"8.10.0","_npmVersion":"lerna/3.10.5/node@v8.10.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"mjesun","email":"mjesun@hotmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.14_1548347358226_0.14356972200221718"},"_hasShrinkwrap":false},"24.0.0-alpha.15":{"_id":"jest-worker@24.0.0-alpha.15","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.15","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"8c48e8679060fe475557a5b6a36c9901900ce722","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.15.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"28971c5f794330e8acc6861288e6daafcd32238e","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.15_1548352352327_0.6685603072560629"},"_hasShrinkwrap":false},"24.0.0-alpha.16":{"_id":"jest-worker@24.0.0-alpha.16","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0-alpha.16","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"141607e0232fd88fe7885624d97000449210fb1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0-alpha.16.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","gitHead":"634e5a54f46b2a62d1dc81a170562e6f4e55ad60","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0-alpha.16_1548423721727_0.987057463312466"},"_hasShrinkwrap":false},"24.0.0":{"_id":"jest-worker@24.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","dist":{"shasum":"3d3483b077bf04f412f47654a27bba7e947f8b6d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.0.0.tgz"},"gitHead":"634e5a54f46b2a62d1dc81a170562e6f4e55ad60","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.10.5/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.0.0_1548428694596_0.820475996143643"},"_hasShrinkwrap":false},"24.2.0-alpha.0":{"_id":"jest-worker@24.2.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.2.0-alpha.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"453b893808267de70dba32403e93022f7f7d4457","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.2.0-alpha.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"build/index.d.ts","gitHead":"800f2f803d01c8ae194d71b251e4965dd70e5bf2","readmeFilename":"README.md","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.2.0-alpha.0_1551797188489_0.5843905950684194"},"_hasShrinkwrap":false},"24.3.0":{"_id":"jest-worker@24.3.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.3.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"2e02eea58f8e43d32e5d82e42aa411dee127dc2d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.3.0.tgz"},"types":"build/index.d.ts","gitHead":"3a7a4f3a3f5489ac8e07dcddf76bb949c482ec87","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.3.0_1551963566982_0.5771391109280639"},"_hasShrinkwrap":false},"24.3.1":{"_id":"jest-worker@24.3.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.3.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"c1759dd2b1d5541b09a2e5e1bc3288de6c9d8632","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.3.1.tgz"},"types":"build/index.d.ts","gitHead":"65c6e9d5e398711c011078bb72648c77fc8a8cb3","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.3.1_1552000338861_0.8865384131060525"},"_hasShrinkwrap":false},"24.4.0":{"_id":"jest-worker@24.4.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.4.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^4.1.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fbc452b0120bb5c2a70cdc88fa132b48eeb11dd0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.4.0.tgz"},"types":"build/index.d.ts","gitHead":"a018000fc162db3cfd0ebf9f23fdb734f05821a6","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.4.0_1552316269093_0.5011234739501604"},"_hasShrinkwrap":false},"24.6.0":{"_id":"jest-worker@24.6.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.6.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^4.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^1.0.1","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7f81ceae34b7cde0c9827a6980c35b7cdc0161b3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.6.0.tgz"},"types":"build/index.d.ts","gitHead":"04e6a66d2ba8b18bee080bb28547db74a255d2c7","_nodeVersion":"8.11.3","_npmVersion":"lerna/3.13.1/node@v8.11.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"rubennorte","email":"rubennorte@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.6.0_1554157576832_0.5693082911800758"},"_hasShrinkwrap":false},"24.9.0":{"_id":"jest-worker@24.9.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"24.9.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^4.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^6.1.0"},"engines":{"node":">= 6"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5dbfdb5b2d322e98567898238a9697bcce67b3e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-24.9.0.tgz"},"types":"build/index.d.ts","gitHead":"9ad0f4bc6b8bdd94989804226c28c9960d9da7d1","_nodeVersion":"11.12.0","_npmVersion":"lerna/3.15.0/node@v11.12.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_24.9.0_1565934946613_0.29555343853323257"},"_hasShrinkwrap":false},"25.0.0":{"_id":"jest-worker@25.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"6475262f808c852df3fe570a133e007314f92938","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.0.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `workerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is available on `process.env.JEST_WORKER_ID`\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"build/index.d.ts","gitHead":"ff9269be05fd8316e95232198fce3463bf2f270e","readmeFilename":"README.md","_nodeVersion":"11.12.0","_npmVersion":"lerna/3.16.4/node@v11.12.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.0.0_1566444224329_0.12563833115291612"},"_hasShrinkwrap":false},"25.1.0":{"_id":"jest-worker@25.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"75d038bad6fdf58eba0d2ec1835856c497e3907a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.1.0.tgz"},"types":"build/index.d.ts","gitHead":"170eee11d03b0ed5c60077982fdbc3bafd403638","_nodeVersion":"10.16.0","_npmVersion":"lerna/3.20.2/node@v10.16.0+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"}],"_npmUser":{"name":"davidzilburg","email":"davidzilburg@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.1.0_1579654784560_0.4353547814972194"},"_hasShrinkwrap":false},"25.2.0-alpha.86":{"_id":"jest-worker@25.2.0-alpha.86","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.0-alpha.86","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9ef61eed265922014bb38ec740b6e382bee6ce91","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.0-alpha.86.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\n### Methods\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"build/index.d.ts","gitHead":"cd98198c9397d8b69c55155d7b224d62ef117a90","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.0-alpha.86_1585156571171_0.5735065090299345"},"_hasShrinkwrap":false},"25.2.0":{"_id":"jest-worker@25.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"2716fbf74fcae7d713778f60187fd1f96fa09d1a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.0.tgz"},"types":"build/index.d.ts","gitHead":"9f0339c1c762e39f869f7df63e88470287728b93","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"mjesun@hotmail.com","name":"mjesun"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.0_1585159074465_0.9310836133836751"},"_hasShrinkwrap":false},"25.2.1-alpha.1":{"_id":"jest-worker@25.2.1-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.1-alpha.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"27f4d6e52f52f4a519a832fb13ecdded20a4266f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.1-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\n### Methods\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"build/index.d.ts","typesVersions":{"<3.8":{"*":["ts3.4/*"]}},"gitHead":"5cc2ccdacb1b2433581222252e43cb5a1f6861a9","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.1-alpha.1_1585209253670_0.15103644471364586"},"_hasShrinkwrap":false},"25.2.1-alpha.2":{"_id":"jest-worker@25.2.1-alpha.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.1-alpha.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5963acc06c2807ce2b954731d76e83baa8bb5f9b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.1-alpha.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## Worker\n\n### Methods\n\nThe returned `Worker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"79b7ab67c63d3708f9689e25fbc0e8b0094bd019","readmeFilename":"README.md","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.1-alpha.2_1585210221782_0.32600001909308607"},"_hasShrinkwrap":false},"25.2.1":{"_id":"jest-worker@25.2.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"209617015c768652646aa33a7828cc2ab472a18a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.1.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"a679390828b6c30aeaa547d8c4dc9aed6531e357","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"jean@lauliac.com","name":"jeanlauliac"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.1_1585213264600_0.5747888296400028"},"_hasShrinkwrap":false},"25.2.6":{"_id":"jest-worker@25.2.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.2.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d1292625326794ce187c38f51109faced3846c58","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.2.6.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"43207b743df164e9e58bd483dd9167b9084da18b","_nodeVersion":"12.14.1","_npmVersion":"lerna/3.20.2/node@v12.14.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.2.6_1585823355244_0.4700168075827742"},"_hasShrinkwrap":false},"25.4.0":{"_id":"jest-worker@25.4.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.4.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ee0e2ceee5a36ecddf5172d6d7e0ab00df157384","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.4.0.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"5b129d714cadb818be28afbe313cbeae8fbb1dde","_nodeVersion":"12.16.1","_npmVersion":"lerna/3.20.2/node@v12.16.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.4.0_1587333019575_0.5823781031819089"},"_hasShrinkwrap":false},"25.5.0":{"_id":"jest-worker@25.5.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"25.5.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 8.3"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"2611d071b79cea0f43ee57a3d118593ac1547db1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-25.5.0.tgz"},"types":"build/index.d.ts","typesVersions":{"<3.8":{"build/*":["build/ts3.4/*"]}},"gitHead":"ddd73d18adfb982b9b0d94bad7d41c9f78567ca7","_nodeVersion":"12.16.1","_npmVersion":"lerna/3.20.2/node@v12.16.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_25.5.0_1588103113084_0.2436621066397966"},"_hasShrinkwrap":false},"26.0.0-alpha.0":{"_id":"jest-worker@26.0.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.0.0-alpha.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"b8d9bd339b4871f2d3bc2f86451e3b51c474b6c0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.0.0-alpha.0.tgz"},"types":"build/index.d.ts","gitHead":"ba962e7e9669a4a2f723c2536c97462c8ddfff2d","_nodeVersion":"12.16.3","_npmVersion":"lerna/3.20.2/node@v12.16.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.0.0-alpha.0_1588421571522_0.4057372207739385"},"_hasShrinkwrap":false},"26.0.0":{"_id":"jest-worker@26.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"4920c7714f0a96c6412464718d0c58a3df3fb066","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.0.0.tgz"},"types":"build/index.d.ts","gitHead":"343532a21f640ac2709c4076eef57e52279542e1","_nodeVersion":"12.16.3","_npmVersion":"lerna/3.20.2/node@v12.16.3+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.0.0_1588614777205_0.9850545113958091"},"_hasShrinkwrap":false},"26.1.0":{"_id":"jest-worker@26.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/node":"*","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"65d5641af74e08ccd561c240e7db61284f82f33d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.1.0.tgz"},"types":"build/index.d.ts","gitHead":"817d8b6aca845dd4fcfd7f8316293e69f3a116c5","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.20.2/node@v12.18.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.1.0_1592925303718_0.4316340426929288"},"_hasShrinkwrap":false},"26.2.0":{"_id":"jest-worker@26.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.2.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9b25ad542e3b812e388796efae214a0ee79f4a35","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.2.0.tgz"},"types":"build/index.d.ts","gitHead":"4a716811a309dae135b780a87dc1647b285800eb","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.20.2/node@v12.18.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.2.0_1596103896901_0.5535750396303447"},"_hasShrinkwrap":false},"26.2.1":{"_id":"jest-worker@26.2.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.2.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.14.2"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5d630ab93f666b53f911615bc13e662b382bd513","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.2.1.tgz"},"types":"build/index.d.ts","gitHead":"da61421faee6fdbf2a2b355b10d4e6eb1a842233","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.20.2/node@v12.18.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.2.1_1596108919698_0.6228837811902372"},"_hasShrinkwrap":false},"26.3.0":{"_id":"jest-worker@26.3.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.3.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^5.1.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.13.0"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7c8a97e4f4364b4f05ed8bca8ca0c24de091871f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.3.0.tgz"},"types":"build/index.d.ts","gitHead":"3a7e06fe855515a848241bb06a6f6e117847443d","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.22.1/node@v12.18.1+x64 (darwin)","maintainers":[{"email":"christoph.pojer@gmail.com","name":"cpojer"},{"email":"davidzilburg@gmail.com","name":"davidzilburg"},{"email":"opensource+npm@fb.com","name":"fb"},{"email":"rubennorte@gmail.com","name":"rubennorte"},{"email":"scott.hovestadt@gmail.com","name":"scotthovestadt"},{"email":"sbekkhus91@gmail.com","name":"simenb"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.3.0_1597059101699_0.8255749392463096"},"_hasShrinkwrap":false},"26.5.0":{"_id":"jest-worker@26.5.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.5.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.13.0"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"87deee86dbbc5f98d9919e0dadf2c40e3152fa30","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.5.0.tgz"},"types":"build/index.d.ts","gitHead":"68d1b1b638bc7464c2794a957c1b894de7da2ee3","_nodeVersion":"12.18.1","_npmVersion":"lerna/3.22.1/node@v12.18.1+x64 (darwin)","maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.5.0_1601890086531_0.3615726104089676"},"_hasShrinkwrap":false},"26.6.1":{"_id":"jest-worker@26.6.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"26.6.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^5.3.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.13.0"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"c2ae8cde6802cc14056043f997469ec170d9c32a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.6.1.tgz"},"types":"build/index.d.ts","gitHead":"f6366db60e32f1763e612288bf3984bcfa7a0a15","_nodeVersion":"12.19.0","_npmVersion":"lerna/3.22.1/node@v12.19.0+x64 (darwin)","maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_26.6.1_1603443935236_0.4175677960016828"},"_hasShrinkwrap":false},"26.6.2":{"_id":"jest-worker@26.6.2","name":"jest-worker","version":"26.6.2","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^7.0.0"},"engines":{"node":">= 10.13.0"},"main":"build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7f72cbc4d643c365e27b9fd775f9d0eaa9c7a8ed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-26.6.2.tgz"},"types":"build/index.d.ts","gitHead":"4c46930615602cbf983fb7e8e82884c282a624d5"},"27.0.0-next.0":{"_id":"jest-worker@27.0.0-next.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"595dcff841bc261b9f38151724d7a55b750562b2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"4f77c70602cab8419794f10fa39510f13baafef8","readmeFilename":"README.md","_nodeVersion":"14.15.0","_npmVersion":"lerna/3.22.1/node@v14.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.0_1607189107172_0.8294230700029115"},"_hasShrinkwrap":false},"27.0.0-next.2":{"_id":"jest-worker@27.0.0-next.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9812082b23d1e4b253922cb0fa20f5f7817e2e67","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"0006b152354237416ffbbc26d78c0b10375c0a49","readmeFilename":"README.md","_nodeVersion":"14.15.0","_npmVersion":"lerna/3.22.1/node@v14.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.2_1607351744747_0.3561989783797255"},"_hasShrinkwrap":false},"27.0.0-next.3":{"_id":"jest-worker@27.0.0-next.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"bfca9ad032441f1d69fb040337038905146e1879","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.3.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"2e34f2cfaf9b6864c3ad4bdca05d3097d3108a41","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/3.22.1/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.3_1613686182201_0.40121796396196907"},"_hasShrinkwrap":false},"27.0.0-next.4":{"_id":"jest-worker@27.0.0-next.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fb068a865f16b909c1037a411683f058e1f39f4f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"941c414f0b757fdc619778c46c21fda26b3e5504","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/4.0.0/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.4_1615211107496_0.9101297466879048"},"_hasShrinkwrap":false},"27.0.0-next.5":{"_id":"jest-worker@27.0.0-next.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.5","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5985ee29b12a4e191f4aae4bb73b97971d86ec28","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.5.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"0a2b94282170b6d4cc26c2d2003cc04ffebe5e3f","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/4.0.0/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.5_1615813397190_0.09077202372318482"},"_hasShrinkwrap":false},"27.0.0-next.6":{"_id":"jest-worker@27.0.0-next.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"13d2c48350a87a59c25ad1fb34295b151fb9ef07","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.6.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"974d2f22b7deeb4f683fb38dd1ee3a0e984916df","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/4.0.0/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.6_1616701196956_0.33543352263449266"},"_hasShrinkwrap":false},"27.0.0-next.7":{"_id":"jest-worker@27.0.0-next.7","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.7","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.7","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"2d76116ef03f6e0ac80cb2636b48f6e3f8768e24","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.7.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"28c763e6be8f57bda89238b95dc801460c2d6601","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/4.0.0/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"cpojer","email":"christoph.pojer@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.7_1617371268616_0.8055073076307999"},"_hasShrinkwrap":false},"27.0.0-next.8":{"_id":"jest-worker@27.0.0-next.8","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.8","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.8","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"70656d41d50d2563ff7f4b54ab8f7605518a36f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.8.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"d7ba5030e274b52f029179dfdb860349a36eea37","readmeFilename":"README.md","_nodeVersion":"14.15.3","_npmVersion":"lerna/4.0.0/node@v14.15.3+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.8_1618267343476_0.8567630000746782"},"_hasShrinkwrap":false},"27.0.0-next.9":{"_id":"jest-worker@27.0.0-next.9","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.9","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^7.2.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.9","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"66056ca63f0bd32563f6a22e581dade95d44b01e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.9.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"d836f33f98845794b4eae8149548a81ddcfc6521","readmeFilename":"README.md","_nodeVersion":"14.16.1","_npmVersion":"lerna/4.0.0/node@v14.16.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.9_1620109501933_0.6231860640907045"},"_hasShrinkwrap":false},"27.0.0-next.10":{"_id":"jest-worker@27.0.0-next.10","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.10","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.10","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"e9235e14ad67a7473309fecd3b34762f8a86e9c7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.10.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"6f44529270310b7dbdf9a0b72b21b5cd50fda4b1","readmeFilename":"README.md","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.10_1621519872249_0.9822625982275239"},"_hasShrinkwrap":false},"27.0.0-next.11":{"_id":"jest-worker@27.0.0-next.11","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0-next.11","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0-next.11","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"1d422f2f0de070036ce5b3e3055bfe499a4d73aa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0-next.11.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. Files relative to a node module are also accepted. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./Worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode 10 shipped with [worker-threads](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses SharedArrayBuffers to communicate between the main process and its child threads. This experimental Node feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nSince `worker_threads` are considered experimental in Node, you have to opt-in to this behavior by passing `enableWorkerThreads: true` when instantiating the worker. While the feature was unflagged in Node 11.7.0, you'll need to run the Node process with the `--experimental-worker` flag for Node 10.\n\n## API\n\nThe only exposed method is a constructor (`JestWorker`) that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `setupArgs: Array<mixed>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `WorkerPool: (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom worker pool to be used for spawning child processes. By default, Jest will use a node thread pool if available and fall back to child process threads.\n\n#### `enableWorkerThreads: boolean` (optional)\n\n`jest-worker` will automatically detect if `worker_threads` are available, but will not use them unless passed `enableWorkerThreads: true`.\n\n### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n### `taskQueue`: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `1`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport JestWorker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./Worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"e2eb9aeee8aacd441f1c8ac992c698ac4d303f60","readmeFilename":"README.md","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0-next.11_1621549722285_0.35689237840768495"},"_hasShrinkwrap":false},"27.0.0":{"_id":"jest-worker@27.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ff8bac62347659f06889838b31b433f649f08578","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.0.tgz"},"types":"./build/index.d.ts","gitHead":"be16e47afcc9f64653b9a47782cb48a5ca243e65","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.0_1621930503997_0.9356265511107593"},"_hasShrinkwrap":false},"27.0.1":{"_id":"jest-worker@27.0.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"b255fcbb40fb467295010c628474b1185cab4f9e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.1.tgz"},"types":"./build/index.d.ts","gitHead":"2cb20e945a26b2c9867b30b787e81f6317e59aa1","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.1_1621937184060_0.4135301928984665"},"_hasShrinkwrap":false},"27.0.2":{"_id":"jest-worker@27.0.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.0.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"4ebeb56cef48b3e7514552f80d0d80c0129f0b05","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.2.tgz"},"types":"./build/index.d.ts","gitHead":"7ca8a22b8453e95c63842ee6aa4d8d8d8b4f9612","_nodeVersion":"14.17.0","_npmVersion":"lerna/4.0.0/node@v14.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.0.2_1622290027772_0.3115783328499193"},"_hasShrinkwrap":false},"27.0.6":{"_id":"jest-worker@27.0.6","name":"jest-worker","version":"27.0.6","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.0.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a5fdb1e14ad34eb228cfe162d9f729cdbfa28aed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.0.6.tgz"},"types":"./build/index.d.ts","gitHead":"d257d1c44ba62079bd4307ae78ba226d47c56ac9"},"27.1.0":{"_id":"jest-worker@27.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.1.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"65f4a88e37148ed984ba8ca8492d6b376938c0aa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.1.0.tgz"},"types":"./build/index.d.ts","gitHead":"5ef792e957e83428d868a18618b8629e32719993","_nodeVersion":"14.17.5","_npmVersion":"lerna/4.0.0/node@v14.17.5+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.1.0_1630058370490_0.3803683921432499"},"_hasShrinkwrap":false},"27.1.1":{"_id":"jest-worker@27.1.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.1.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.1.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"eb5f05c4657fdcb702c36c48b20d785bd4599378","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.1.1.tgz"},"types":"./build/index.d.ts","gitHead":"111198b62dbfc3a730f7b1693e311608e834fe1d","_nodeVersion":"14.17.5","_npmVersion":"lerna/4.0.0/node@v14.17.5+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.1.1_1631095928042_0.9543975372436013"},"_hasShrinkwrap":false},"27.2.0":{"_id":"jest-worker@27.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.2.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.2.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"11eef39f1c88f41384ca235c2f48fe50bc229bc0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.2.0.tgz"},"types":"./build/index.d.ts","gitHead":"b05635c539f8f673dfed5bf05ea727a8d5d7bbe2","_nodeVersion":"14.17.5","_npmVersion":"lerna/4.0.0/node@v14.17.5+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.2.0_1631520395017_0.8766271203575662"},"_hasShrinkwrap":false},"27.2.2":{"_id":"jest-worker@27.2.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.2.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.2.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"636deeae8068abbf2b34b4eb9505f8d4e5bd625c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.2.2.tgz"},"types":"./build/index.d.ts","gitHead":"f54d96fec55518640b900d6994b2c4153316d1ed","_nodeVersion":"14.17.6","_npmVersion":"lerna/4.0.0/node@v14.17.6+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.2.2_1632576907630_0.4936313802143313"},"_hasShrinkwrap":false},"27.2.3":{"_id":"jest-worker@27.2.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.2.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.2.3","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"396e83d04ca575230a9bcb255c2b66aec07cb931","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.2.3.tgz"},"types":"./build/index.d.ts","gitHead":"ae53efe274dee5464d11f1b574d2d825685cd031","_nodeVersion":"14.17.6","_npmVersion":"lerna/4.0.0/node@v14.17.6+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.2.3_1632823879797_0.3956543902033458"},"_hasShrinkwrap":false},"27.2.4":{"_id":"jest-worker@27.2.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.2.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.2.4","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"881455df75e22e7726a53f43703ab74d6b36f82d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.2.4.tgz"},"types":"./build/index.d.ts","gitHead":"5886f6c4d681aa9fc9bfc2517efd2b7f6035a4cd","_nodeVersion":"14.17.6","_npmVersion":"lerna/4.0.0/node@v14.17.6+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.2.4_1632924286556_0.08060569557364738"},"_hasShrinkwrap":false},"27.2.5":{"_id":"jest-worker@27.2.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.2.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.2.5","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ed42865661959488aa020e8a325df010597c36d4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.2.5.tgz"},"types":"./build/index.d.ts","gitHead":"251b8014e8e3ac8da2fca88b5a1bc401f3b92326","_nodeVersion":"14.17.6","_npmVersion":"lerna/4.0.0/node@v14.17.6+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.2.5_1633700358606_0.47419812324526966"},"_hasShrinkwrap":false},"27.3.0":{"_id":"jest-worker@27.3.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.3.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.3.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"6b636b63b6672208b91b92d8dcde112d1d4dba2d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.3.0.tgz"},"types":"./build/index.d.ts","gitHead":"14b0c2c1d6f81b64adf8b827649ece80a4448cfc","_nodeVersion":"14.17.6","_npmVersion":"lerna/4.0.0/node@v14.17.6+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.3.0_1634495685741_0.537208926487684"},"_hasShrinkwrap":false},"27.3.1":{"_id":"jest-worker@27.3.1","name":"jest-worker","version":"27.3.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.3.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"0def7feae5b8042be38479799aeb7b5facac24b2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.3.1.tgz"},"types":"./build/index.d.ts","gitHead":"4f3328f3227aa0668486f819b3353af5b6cc797b"},"27.4.0":{"_id":"jest-worker@27.4.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.4.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fa10dddc611cbb47a4153543dd16a0c7e7fd745c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.0.tgz"},"types":"./build/index.d.ts","gitHead":"0dc6dde296550370ade2574d6665748fed37f9c9","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.4.0_1638193014648_0.035626821695394106"},"_hasShrinkwrap":false},"27.4.1":{"_id":"jest-worker@27.4.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.4.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"b4e77bd2effb9245171f342bd06c372054b67108","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.1.tgz"},"types":"./build/index.d.ts","gitHead":"fa4a3982766b107ff604ba54081d9e4378f318a9","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.4.1_1638261423193_0.6325438023665828"},"_hasShrinkwrap":false},"27.4.2":{"_id":"jest-worker@27.4.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.4.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"0fb123d50955af1a450267787f340a1bf7e12bc4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.2.tgz"},"types":"./build/index.d.ts","gitHead":"7965591f785e936ada194f9d58f852735b50ab1c","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.4.2_1638273213572_0.7835163197035273"},"_hasShrinkwrap":false},"27.4.4":{"_id":"jest-worker@27.4.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.4.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9390a97c013a54d07f5c2ad2b5f6109f30c4966d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.4.tgz"},"types":"./build/index.d.ts","gitHead":"e2316126b2e4b9b4272e5a0b651c3cb5b0306369","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.4.4_1639111386901_0.12012614282645973"},"_hasShrinkwrap":false},"27.4.5":{"_id":"jest-worker@27.4.5","name":"jest-worker","version":"27.4.5","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d696e3e46ae0f24cff3fa7195ffba22889262242","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.5.tgz"},"types":"./build/index.d.ts","gitHead":"73f3a5743b9e5b16c9b7a69e2705f07ba7a010ea"},"27.4.6":{"_id":"jest-worker@27.4.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.4.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.4.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"5d2d93db419566cb680752ca0792780e71b3273e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.4.6.tgz"},"types":"./build/index.d.ts","gitHead":"644d2d3e53536b0d67e395c0f35f8555a67beb1e","_nodeVersion":"16.13.0","_npmVersion":"lerna/4.0.0/node@v16.13.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.4.6_1641337411581_0.48958288162379904"},"_hasShrinkwrap":false},"27.5.0":{"_id":"jest-worker@27.5.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"27.5.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.5.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"99ee77e4d06168107c27328bd7f54e74c3a48d59","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.5.0.tgz"},"types":"./build/index.d.ts","gitHead":"247cbe6026a590deaf0d23edecc7b2779a4aace9","_nodeVersion":"16.13.2","_npmVersion":"lerna/4.0.0/node@v16.13.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_27.5.0_1644055157828_0.19170112922657911"},"_hasShrinkwrap":false},"27.5.1":{"_id":"jest-worker@27.5.1","name":"jest-worker","version":"27.5.1","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^27.5.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":">= 10.13.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"8d146f0900e8973b106b6f73cc1e9a8cb86f8db0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-27.5.1.tgz"},"types":"./build/index.d.ts","gitHead":"67c1aa20c5fec31366d733e901fee2b981cb1850"},"28.0.0-alpha.0":{"_id":"jest-worker@28.0.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7792a9c3d60b82982b481720711a132062219d62","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"89275b08977065d98e42ad71fcf223f4ad169f09","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.0_1644517046406_0.8770687766661727"},"_hasShrinkwrap":false},"28.0.0-alpha.1":{"_id":"jest-worker@28.0.0-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d8244c5f703a82865479d544ef913874652e5ab6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"d30164dde1847166fa0faec98d20abffd85e6ffd","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.1_1644960409254_0.06588631679319801"},"_hasShrinkwrap":false},"28.0.0-alpha.2":{"_id":"jest-worker@28.0.0-alpha.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.2","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"f1ab0ae43f7033d326dcd4824db3fa0dc2b7e083","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"694d6bfea56f9cb49d0c7309cdbfff032da198c2","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.2_1645035117302_0.4398803279230663"},"_hasShrinkwrap":false},"28.0.0-alpha.3":{"_id":"jest-worker@28.0.0-alpha.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.3","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"f1ec4297f97478f72beab6bb6df06bca220ce8a2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.3.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"fc30b27bd94bb7ebeaadc72626ebbdba535150d2","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.3_1645112540768_0.7222916804822315"},"_hasShrinkwrap":false},"28.0.0-alpha.4":{"_id":"jest-worker@28.0.0-alpha.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.4","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"327e27cd12b432390bac113b189a6350b2b35f8e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"c13dab19491ba6b57c2d703e7d7c4b20189e1e17","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.4_1645532034462_0.5726474561895478"},"_hasShrinkwrap":false},"28.0.0-alpha.5":{"_id":"jest-worker@28.0.0-alpha.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.5","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"2e6a6f3b24702bbe8e7f83a257f90d0f0735f030","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.5.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"46fb19b2628bd87676c10730ba19592c30b05478","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.5_1645736237889_0.37682331672133884"},"_hasShrinkwrap":false},"28.0.0-alpha.6":{"_id":"jest-worker@28.0.0-alpha.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"1f0aee9417506882f98c30f5baec12a99e2ffee1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.6.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"6284ada4adb7008f5f8673b1a7b1c789d2e508fb","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.6_1646123542369_0.5811610245597727"},"_hasShrinkwrap":false},"28.0.0-alpha.7":{"_id":"jest-worker@28.0.0-alpha.7","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.7","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.7","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"119f0a3f325742d78a592f1d492c26b36772bf17","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.7.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"06f58f8ca70abc9c09d554967935b58ce85c48d6","readmeFilename":"README.md","_nodeVersion":"16.14.0","_npmVersion":"lerna/4.0.0/node@v16.14.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.7_1646560959594_0.013584128255585082"},"_hasShrinkwrap":false},"28.0.0-alpha.8":{"_id":"jest-worker@28.0.0-alpha.8","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.8","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.8","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"25a9436c5a8f009dcf38a3a1d068ea1ac137441f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.8.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"d915e7df92b220dbe6e124585ba6459838a6c41c","readmeFilename":"README.md","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.8_1649170779602_0.8379601442580333"},"_hasShrinkwrap":false},"28.0.0-alpha.9":{"_id":"jest-worker@28.0.0-alpha.9","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.9","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.9","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"6e435b24e2813f35873443dfe0d9ebbee9dff625","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.9.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env` and `execArgv`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_processforkmodulepath-args-options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"7c63f5981eb20d4b89a4c04f3675e0050d8d7887","readmeFilename":"README.md","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.9_1650365953922_0.44682217621189246"},"_hasShrinkwrap":false},"28.0.0-alpha.11":{"_id":"jest-worker@28.0.0-alpha.11","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0-alpha.11","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0-alpha.9","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"1a473675e67a8ee9ee4b912640d54c878e9dbd0c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0-alpha.11.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"8b4b78759d255746f11e396efe7d06ac93dbd05b","readmeFilename":"README.md","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0-alpha.11_1650461457760_0.687697128208606"},"_hasShrinkwrap":false},"28.0.0":{"_id":"jest-worker@28.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a45b9ed5d7cabc49e463fdb0f47d60af86bca479","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.0.tgz"},"types":"./build/index.d.ts","gitHead":"8f9b812faf8e4d241d560a8574f0c6ed20a89365","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.0_1650888482277_0.7470449633210638"},"_hasShrinkwrap":false},"28.0.1":{"_id":"jest-worker@28.0.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.13.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7abc005335a5937e6a4f8d24c980c7630a849012","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.1.tgz"},"types":"./build/index.d.ts","gitHead":"0a08639e4299f07becf1020a761adfec83536018","_nodeVersion":"16.14.2","_npmVersion":"lerna/4.0.0/node@v16.14.2+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.1_1650967352890_0.4348692646135568"},"_hasShrinkwrap":false},"28.0.2":{"_id":"jest-worker@28.0.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.0.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.6.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.0.2","tsd-lite":"^0.5.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"75f7e5126541289ba02e9c1a67e46349ddb8141d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.0.2.tgz"},"types":"./build/index.d.ts","gitHead":"279ee6658d763f024d51f340fab6a37c17d94502","_nodeVersion":"16.15.0","_npmVersion":"lerna/4.0.0/node@v16.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.0.2_1651045440168_0.5777805788374517"},"_hasShrinkwrap":false},"28.1.0":{"_id":"jest-worker@28.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.6.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.1.0","tsd-lite":"^0.5.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ced54757a035e87591e1208253a6e3aac1a855e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.1.0.tgz"},"types":"./build/index.d.ts","gitHead":"f5db241312f46528389e55c38221e6b6968622cf","_nodeVersion":"16.15.0","_npmVersion":"lerna/4.0.0/node@v16.15.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.1.0_1651834133206_0.4367739708306524"},"_hasShrinkwrap":false},"28.1.1":{"_id":"jest-worker@28.1.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"28.1.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.3","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.1.1","tsd-lite":"^0.5.1","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"3480c73247171dfd01eda77200f0063ab6a3bf28","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.1.1.tgz"},"types":"./build/index.d.ts","gitHead":"eb954f8874960920ac50a8f976bb333fbb06ada9","_nodeVersion":"16.15.1","_npmVersion":"lerna/4.0.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_28.1.1_1654582175387_0.6767192198321987"},"_hasShrinkwrap":false},"28.1.3":{"_id":"jest-worker@28.1.3","name":"jest-worker","version":"28.1.3","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^28.1.3","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^12.13.0 || ^14.15.0 || ^16.10.0 || >=17.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7e3c4ce3fa23d1bb6accb169e7f396f98ed4bb98","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-28.1.3.tgz"},"types":"./build/index.d.ts","gitHead":"2cce069800dab3fc8ca7c469b32d2e2b2f7e2bb1"},"29.0.0-alpha.0":{"_id":"jest-worker@29.0.0-alpha.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.0","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"74d4134961bc077b06b980e03a8f681fcf48eb2e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.0.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"6862afb00307b52f32eedee977a9b3041355f184","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/4.0.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.0_1658095625925_0.7072032940983612"},"_hasShrinkwrap":false},"29.0.0-alpha.1":{"_id":"jest-worker@29.0.0-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.1","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"85337070255194ff2c6814d8426a1565197a867a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"10f1e7f52d9f876e6fb7f20c1903fdcddd8db8b1","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/4.0.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.1_1659601408611_0.617705817055465"},"_hasShrinkwrap":false},"29.0.0-alpha.3":{"_id":"jest-worker@29.0.0-alpha.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.3","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"ab3929ffe377908cb2115768707283448176ffca","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.3.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/facebook/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"09981873c55442e5e494d42012f518b7d3d41fbd","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.10.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.3_1659879699128_0.287452577232439"},"_hasShrinkwrap":false},"29.0.0-alpha.4":{"_id":"jest-worker@29.0.0-alpha.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.4","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.4","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"806ecd6b486590467400d595beecee4076d226e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.4.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/facebook/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"98a833bd4bc0bdcfcee5d4f04c2833400c4e2933","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.10.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.4_1659963937495_0.6815103898427783"},"_hasShrinkwrap":false},"29.0.0-alpha.5":{"_id":"jest-worker@29.0.0-alpha.5","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.5","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.4","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"72ac6c2c0f157008a11b58ac31d02c951e0fa285","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.5.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/facebook/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"63e506b5d1558a9132a8fa65151407b0a40be3a5","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.10.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.5_1660225257154_0.8123488041166989"},"_hasShrinkwrap":false},"29.0.0-alpha.6":{"_id":"jest-worker@29.0.0-alpha.6","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0-alpha.6","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0-alpha.6","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"59d82e84a0da3275d47dc8737ff78c12b86fed93","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0-alpha.6.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child processes. Use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/facebook/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a Promise that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"4def94b073cad300e99de378ba900e6ba9b7032f","readmeFilename":"README.md","_nodeVersion":"16.15.1","_npmVersion":"lerna/1.10.0/node@v16.15.1+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0-alpha.6_1660917472567_0.6999195194494563"},"_hasShrinkwrap":false},"29.0.0":{"_id":"jest-worker@29.0.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.0","tsd-lite":"^0.5.6","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a1c7b67b2d9ce057383999b32d8b71794efcd0b9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.0.tgz"},"types":"./build/index.d.ts","gitHead":"75006e46c76f6fda14bbc0548f86edb2ba087cd2","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.10.0/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.0_1661430811197_0.41161831791089076"},"_hasShrinkwrap":false},"29.0.1":{"_id":"jest-worker@29.0.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.7.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.1","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fb42ff7e05e0573f330ec0cf781fc545dcd11a31","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.1.tgz"},"types":"./build/index.d.ts","gitHead":"b959a3d3bdf324ed1c7358f76ab238a8b0b0cf93","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.10.0/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.1_1661520884711_0.4802079853376138"},"_hasShrinkwrap":false},"29.0.2":{"_id":"jest-worker@29.0.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.2","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"46c9f2cb9a19663d22babbacf998e4b5d7c46574","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.2.tgz"},"types":"./build/index.d.ts","gitHead":"616fcf56bb8481d29ba29cc34be32a92b1cf85e5","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.10.0/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.2_1662202102391_0.2706606058632144"},"_hasShrinkwrap":false},"29.0.3":{"_id":"jest-worker@29.0.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.0.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.0.3","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"c2ba0aa7e41eec9eb0be8e8a322ae6518df72647","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.0.3.tgz"},"types":"./build/index.d.ts","gitHead":"77f865da39af5b3e1c114dc347e49257eb3dcfd1","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.10.0/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.0.3_1662820905549_0.8669018445773511"},"_hasShrinkwrap":false},"29.1.0":{"_id":"jest-worker@29.1.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.1.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.1.0","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"374d741b976a868e39141d63fb401abacc07a8c9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.1.0.tgz"},"types":"./build/index.d.ts","gitHead":"51f10300daf90db003a1749ceaed1084c4f74811","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.1.0_1664350662642_0.10641773948634348"},"_hasShrinkwrap":false},"29.1.2":{"_id":"jest-worker@29.1.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.1.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.1.2","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.1.2","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"a68302af61bce82b42a9a57285ca7499d29b2afc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.1.2.tgz"},"types":"./build/index.d.ts","gitHead":"3c31dd619e8c022cde53f40fa12ea2a67f4752ce","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.1.2_1664522570098_0.49252976126169434"},"_hasShrinkwrap":false},"29.2.0":{"_id":"jest-worker@29.2.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.2.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.2.0","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.2.0","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"b2bd1a81fc7a1ae79a500b05f5feb0d1c0b1a19e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.2.0.tgz"},"types":"./build/index.d.ts","gitHead":"ee5b37a4f4433afcfffb0356cea47739d8092287","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.2.0_1665738831765_0.6765740700720222"},"_hasShrinkwrap":false},"29.2.1":{"_id":"jest-worker@29.2.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.2.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.2.1","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.2.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"8ba68255438252e1674f990f0180c54dfa26a3b1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.2.1.tgz"},"types":"./build/index.d.ts","gitHead":"4551c0fdd4d25b7206824957c7bcc6baf61e63bf","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.2.1_1666108814626_0.0019998292650091898"},"_hasShrinkwrap":false},"29.3.0":{"_id":"jest-worker@29.3.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.3.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.2.1","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.2.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"240a1cd731c7d6645e8bcc37a3d584f122afb44a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.3.0.tgz"},"types":"./build/index.d.ts","gitHead":"84b8de987b33e2da20dc833aeb65f23d72a673cd","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.3.0_1667843746191_0.3988249669282702"},"_hasShrinkwrap":false},"29.3.1":{"_id":"jest-worker@29.3.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.3.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"~4.8.2","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.3.1","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.3.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"e9462161017a9bb176380d721cab022661da3d6b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.3.1.tgz"},"types":"./build/index.d.ts","gitHead":"05deb8393c4ad71e19be2567b704dfd3a2ab5fc9","_nodeVersion":"16.17.0","_npmVersion":"lerna/1.11.3/node@v16.17.0+x64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.3.1_1667948184489_0.21464768734454198"},"_hasShrinkwrap":false},"29.4.0":{"_id":"jest-worker@29.4.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.4.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"^4.9.0","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.4.0","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.4.0","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fbf6d700c3366c555765938da75990c1e7fdcdcd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.4.0.tgz"},"types":"./build/index.d.ts","gitHead":"4bc0e8acaf990e6618a7bed1dca67760c20bb12a","_nodeVersion":"16.19.0","_npmVersion":"lerna/1.13.0/node@v16.19.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.4.0_1674557754070_0.2919955672114307"},"_hasShrinkwrap":false},"29.4.1":{"_id":"jest-worker@29.4.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.4.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@tsd/typescript":"^4.9.0","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.4.1","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.4.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7cb4a99a38975679600305650f86f4807460aab1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.4.1.tgz"},"types":"./build/index.d.ts","gitHead":"bc84c8a15649aaaefdd624dc83824518c17467ed","_nodeVersion":"16.19.0","_npmVersion":"lerna/1.13.0/node@v16.19.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.4.1_1674745718255_0.07169915889953238"},"_hasShrinkwrap":false},"29.4.2":{"_id":"jest-worker@29.4.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.4.2","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^4.9.0","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.4.2","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.4.2","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d9b2c3bafc69311d84d94e7fb45677fc8976296f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.4.2.tgz"},"types":"./build/index.d.ts","gitHead":"f0fc92e8443f09546c7ec0472bf9bce44fe5898f","_nodeVersion":"16.19.0","_npmVersion":"lerna/1.13.0/node@v16.19.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.4.2_1675777530435_0.32339297870946315"},"_hasShrinkwrap":false},"29.4.3":{"_id":"jest-worker@29.4.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.4.3","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^4.9.0","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.4.3","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.4.3","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"9a4023e1ea1d306034237c7133d7da4240e8934e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.4.3.tgz"},"types":"./build/index.d.ts","gitHead":"a49c88610e49a3242576160740a32a2fe11161e1","_nodeVersion":"18.14.0","_npmVersion":"lerna/1.13.0/node@v18.14.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.4.3_1676462244037_0.5269105471236717"},"_hasShrinkwrap":false},"29.5.0":{"_id":"jest-worker@29.5.0","name":"jest-worker","version":"29.5.0","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^4.9.0","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.5.0","tsd-lite":"^0.6.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.5.0","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"bdaefb06811bd3384d93f009755014d8acb4615d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.5.0.tgz"},"types":"./build/index.d.ts","gitHead":"39f3beda6b396665bebffab94e8d7c45be30454c"},"29.6.0":{"_id":"jest-worker@29.6.0","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.6.0","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.6.0","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.6.0","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"e0c40226d073fdb8f0dfe87d7f90f8fd987d8ba3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.6.0.tgz"},"types":"./build/index.d.ts","gitHead":"c1e5b8a38ef54bb138409f89831942ebf6a7a67e","_nodeVersion":"18.16.1","_npmVersion":"lerna/1.13.0/node@v18.16.1+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.6.0_1688484348395_0.45499529964001195"},"_hasShrinkwrap":false},"29.6.1":{"_id":"jest-worker@29.6.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.6.1","homepage":"https://github.com/facebook/jest#readme","repository":{"type":"git","url":"git+https://github.com/facebook/jest.git"},"bugs":{"url":"https://github.com/facebook/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.6.1","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.6.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"64b015f0e985ef3a8ad049b61fe92b3db74a5319","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.6.1.tgz"},"types":"./build/index.d.ts","gitHead":"1f019afdcdfc54a6664908bb45f343db4e3d0848","_nodeVersion":"18.16.1","_npmVersion":"lerna/1.13.0/node@v18.16.1+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.6.1_1688653107973_0.12333332132624664"},"_hasShrinkwrap":false},"29.6.2":{"_id":"jest-worker@29.6.2","name":"jest-worker","version":"29.6.2","repository":{"type":"git","url":"https://github.com/facebook/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.6.2","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.6.2","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"682fbc4b6856ad0aa122a5403c6d048b83f3fb44","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.6.2.tgz"},"types":"./build/index.d.ts","gitHead":"0fd5b1c37555f485c56a6ad2d6b010a72204f9f6"},"29.6.3":{"_id":"jest-worker@29.6.3","name":"jest-worker","version":"29.6.3","repository":{"type":"git","url":"https://github.com/jestjs/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.6.3","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.6.3","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"7b1a47bbb6559f3c0882d16595938590e63915d5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.6.3.tgz"},"types":"./build/index.d.ts","gitHead":"fb7d95c8af6e0d65a8b65348433d8a0ea0725b5b"},"29.6.4":{"_id":"jest-worker@29.6.4","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"29.6.4","homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.6.3","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.6.3","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"f34279f4afc33c872b470d4af21b281ac616abd3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.6.4.tgz"},"types":"./build/index.d.ts","gitHead":"55cd6a0aaf6f9178199dfa7af7a00fcaa7c421fd","_nodeVersion":"20.5.1","_npmVersion":"lerna/1.13.0/node@v20.5.1+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_29.6.4_1692875426655_0.26543931902486273"},"_hasShrinkwrap":false},"29.7.0":{"_id":"jest-worker@29.7.0","name":"jest-worker","version":"29.7.0","repository":{"type":"git","url":"https://github.com/jestjs/jest.git"},"license":"MIT","directories":null,"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"^29.7.0","tsd-lite":"^0.7.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"^29.7.0","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^14.15.0 || ^16.10.0 || >=18.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"acad073acbbaeb7262bd5389e1bcf43e10058d4a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-29.7.0.tgz"},"types":"./build/index.d.ts","gitHead":"4e56991693da7cd4c3730dc3579a1dd1403ee630"},"30.0.0-alpha.1":{"_id":"jest-worker@30.0.0-alpha.1","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"30.0.0-alpha.1","homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"30.0.0-alpha.1","tsd-lite":"^0.8.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"30.0.0-alpha.1","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"cb3bf0381f493c5daf789e9c4e183dc5cea82b69","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-30.0.0-alpha.1.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string | URL` (required)\n\nNode module name or absolute path or file URL of the file to be loaded in the child processes. You can use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/jestjs/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `start()`\n\nStarts up every worker and calls their `setup` function, if it exists. Returns a `Promise` which resolves when all workers are running and have completed their `setup`.\n\nThis is useful if you want to start up all your workers eagerly before they are used to call any other functions.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a `Promise` that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10_000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"d005cb2505c041583e0c5636d006e08666a54b63","readmeFilename":"README.md","_nodeVersion":"20.9.0","_npmVersion":"lerna/1.13.0/node@v20.9.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_30.0.0-alpha.1_1698672793367_0.8332594434306044"},"_hasShrinkwrap":false},"30.0.0-alpha.2":{"_id":"jest-worker@30.0.0-alpha.2","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"30.0.0-alpha.2","homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"30.0.0-alpha.2","tsd-lite":"^0.8.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"30.0.0-alpha.2","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"d8e9dc386b31bb8bc6fdbdcc19dfbb7effccaeca","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-30.0.0-alpha.2.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string | URL` (required)\n\nNode module name or absolute path or file URL of the file to be loaded in the child processes. You can use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/jestjs/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `start()`\n\nStarts up every worker and calls their `setup` function, if it exists. Returns a `Promise` which resolves when all workers are running and have completed their `setup`.\n\nThis is useful if you want to start up all your workers eagerly before they are used to call any other functions.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a `Promise` that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10_000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"c04d13d7abd22e47b0997f6027886aed225c9ce4","readmeFilename":"README.md","_nodeVersion":"20.9.0","_npmVersion":"lerna/2.7.0/node@v20.9.0+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_30.0.0-alpha.2_1700126909887_0.4201886936125685"},"_hasShrinkwrap":false},"30.0.0-alpha.3":{"_id":"jest-worker@30.0.0-alpha.3","name":"jest-worker","description":"Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.","version":"30.0.0-alpha.3","homepage":"https://github.com/jestjs/jest#readme","repository":{"type":"git","url":"git+https://github.com/jestjs/jest.git"},"bugs":{"url":"https://github.com/jestjs/jest/issues"},"license":"MIT","directories":{},"devDependencies":{"@babel/core":"^7.11.6","@tsd/typescript":"^5.0.4","@types/merge-stream":"^1.1.2","@types/supports-color":"^8.1.0","get-stream":"^6.0.0","jest-leak-detector":"30.0.0-alpha.3","tsd-lite":"^0.8.0","worker-farm":"^1.6.0"},"dependencies":{"@types/node":"*","jest-util":"30.0.0-alpha.3","merge-stream":"^2.0.0","supports-color":"^8.0.0"},"engines":{"node":"^16.10.0 || ^18.12.0 || >=20.0.0"},"main":"./build/index.js","publishConfig":{"access":"public"},"dist":{"shasum":"fb6be6cb4e45cc00dfba739686818701eda97681","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/jest-worker/-/jest-worker-30.0.0-alpha.3.tgz"},"readme":"# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all forked processes. All methods are exposed on the parent process as promises, so they can be `await`'ed. Child (worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means that, based on certain parameters, the same task will always be executed by the same worker. The way bound workers work is by using the returned string of the `computeWorkerKey` method. If the string was used before for a task, the call will be queued to the related worker that processed the task earlier; if not, it will be executed by the first available worker, then sticked to the worker that executed it; so the next time it will be processed by the same worker. If you have no preference on the worker executing the task, but you have defined a `computeWorkerKey` method because you want _some_ of the tasks to be sticked, you can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods` option. If it is not provided, it will be obtained by requiring the child module into the main process, and analyzed via reflection. Check the \"minimal example\" section for a valid one.\n\n## Install\n\n```sh\nyarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const worker = new JestWorker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function hello(param) {\n  return `Hello, ${param}`;\n}\n```\n\n## Experimental worker\n\nNode shipped with [`worker_threads`](https://nodejs.org/api/worker_threads.html), a \"threading API\" that uses `SharedArrayBuffers` to communicate between the main process and its child threads. This feature can significantly improve the communication time between parent and child processes in `jest-worker`.\n\nTo use `worker_threads` instead of default `child_process` you have to pass `enableWorkerThreads: true` when instantiating the worker.\n\n## API\n\nThe `Worker` export is a constructor that is initialized by passing the worker path, plus an options object.\n\n### `workerPath: string | URL` (required)\n\nNode module name or absolute path or file URL of the file to be loaded in the child processes. You can use `require.resolve` to transform a relative path into an absolute one.\n\n### `options: Object` (optional)\n\n#### `computeWorkerKey: (method: string, ...args: Array<unknown>) => string | null` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also called in order to bound the call to a worker. This is useful for workers that are able to cache the result or part of it. You bound calls to a worker by making `computeWorkerKey` return the same identifier for all different calls. If you do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of the arguments of the call. Thus, you have full control to decide what to return. Check a practical example on bound workers under the \"bound worker usage\" section.\n\nBy default, no process is bound to any worker.\n\n#### `enableWorkerThreads: boolean` (optional)\n\nBy default, `jest-worker` will use `child_process` threads to spawn new Node.js processes. If you prefer [`worker_threads`](https://nodejs.org/api/worker_threads.html) instead, pass `enableWorkerThreads: true`.\n\n#### `exposedMethods: ReadonlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent process. You cannot expose any method named like a public `Worker` method, or starting with `_`. If you use method auto-discovery, then these methods will not be exposed, even if they exist.\n\n#### `forkOptions: ForkOptions` (optional)\n\nAllow customizing all options passed to `child_process.fork`. By default, some values are set (`cwd`, `env`, `execArgv` and `serialization`), but you can override them and customize the rest. For a list of valid values, check [the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `idleMemoryLimit: number` (optional)\n\nSpecifies the memory limit for workers before they are recycled and is primarily a work-around for [this issue](https://github.com/jestjs/jest/issues/11956);\n\nAfter the worker has executed a task the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. If no limit is set this process does not occur. The limit can be specified in 2 ways:\n\n- `<= 1` - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n- `\\> 1` - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use `1.1`.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults to `3`, pass `Infinity` to allow endless retries.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `resourceLimits: ResourceLimits` (optional)\n\nThe `resourceLimits` option which will be passed to `worker_threads` workers.\n\n#### `silent: Boolean` (optional)\n\nSet to false for `stdout` and `stderr` to be logged to console.\n\nBy default this is true.\n\n#### `setupArgs: Array<unknown>` (optional)\n\nThe arguments that will be passed to the `setup` method during initialization.\n\n#### `taskQueue: TaskQueue` (optional)\n\nThe task queue defines in which order tasks (method calls) are processed by the workers. `jest-worker` ships with a `FifoQueue` and `PriorityQueue`:\n\n- `FifoQueue` (default): Processes the method calls (tasks) in the call order.\n- `PriorityQueue`: Processes the method calls by a computed priority in natural ordering (lower priorities first). Tasks with the same priority are processed in any order (FIFO not guaranteed). The constructor accepts a single argument, the function that is passed the name of the called function and the arguments and returns a numerical value for the priority: `new require('jest-worker').PriorityQueue((method, filename) => filename.length)`.\n\n#### `WorkerPool: new (workerPath: string, options?: WorkerPoolOptions) => WorkerPoolInterface` (optional)\n\nProvide a custom WorkerPool class to be used for spawning child processes.\n\n#### `workerSchedulingPolicy: 'round-robin' | 'in-order'` (optional)\n\nSpecifies the policy how tasks are assigned to workers if multiple workers are _idle_:\n\n- `round-robin` (default): The task will be sequentially distributed onto the workers. The first task is assigned to the worker 1, the second to the worker 2, to ensure that the work is distributed across workers.\n- `in-order`: The task will be assigned to the first free worker starting with worker 1 and only assign the work to worker 2 if the worker 1 is busy.\n\nTasks are always assigned to the first free worker as soon as tasks start to queue up. The scheduling policy does not define the task scheduling which is always first-in, first-out.\n\n## JestWorker\n\n### Methods\n\nThe returned `JestWorker` instance has all the exposed methods, plus some additional ones to interact with the workers itself:\n\n#### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped. Note that the `silent` option of the child workers must be set to `true` to make it work. This is the default set by `jest-worker`, but keep it in mind when overriding options through `forkOptions`.\n\n#### `start()`\n\nStarts up every worker and calls their `setup` function, if it exists. Returns a `Promise` which resolves when all workers are running and have completed their `setup`.\n\nThis is useful if you want to start up all your workers eagerly before they are used to call any other functions.\n\n#### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the `Worker` instance.\n\nReturns a `Promise` that resolves with `{ forceExited: boolean }` once all workers are dead. If `forceExited` is `true`, at least one of the workers did not exit gracefully, which likely happened because it executed a leaky task that left handles open. This should be avoided, force exiting workers is a last resort to prevent creating lots of orphans.\n\n**Note:**\n\n`await`ing the `end()` Promise immediately after the workers are no longer needed before proceeding to do other useful things in your program may not be a good idea. If workers have to be force exited, `jest-worker` may go through multiple stages of force exiting (e.g. SIGTERM, later SIGKILL) and give the worker overall around 1 second time to exit on its own. During this time, your program will wait, even though it may not be necessary that all workers are dead before continuing execution.\n\nConsider deliberately leaving this Promise floating (unhandled resolution). After your program has done the rest of its work and is about to exit, the Node process will wait for the Promise to resolve after all workers are dead as the last event loop task. That way you parallelized computation time of your program and waiting time and you didn't delay the outputs of your program unnecessarily.\n\n### Worker IDs\n\nEach worker has a unique id (index that starts with `'1'`), which is available inside the worker as `process.env.JEST_WORKER_ID`.\n\n## Setting up and tearing down the child process\n\nThe child process can define two special methods (both of them can be asynchronous):\n\n- `setup()`: If defined, it's executed before the first call to any method in the child.\n- `teardown()`: If defined, it's executed when the farm ends.\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nexport function foo(param) {\n  return `Hello from foo: ${param}`;\n}\n\nexport function bar(param) {\n  return `Hello from bar: ${param}`;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```js\nimport {Worker as JestWorker} from 'jest-worker';\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10_000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  const {forceExited} = await myWorker.end();\n  if (forceExited) {\n    console.error('Workers failed to exit gracefully');\n  }\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```js\nimport babel from '@babel/core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return babel.transformFileAsync(filename).then(result => {\n    cache[filename] = result;\n\n    return result;\n  });\n}\n```\n","types":"./build/index.d.ts","gitHead":"e267aff33d105399f2134bad7c8f82285104f3da","readmeFilename":"README.md","_nodeVersion":"20.11.1","_npmVersion":"lerna/3.2.1/node@v20.11.1+arm64 (darwin)","_npmUser":{"name":"simenb","email":"sbekkhus91@gmail.com"},"maintainers":[{"name":"scotthovestadt","email":"scott.hovestadt@gmail.com"},{"name":"rubennorte","email":"rubennorte@gmail.com"},{"name":"simenb","email":"sbekkhus91@gmail.com"},{"name":"fb","email":"opensource+npm@fb.com"},{"name":"davidzilburg","email":"davidzilburg@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/jest-worker_30.0.0-alpha.3_1708427350501_0.9253036914515578"},"_hasShrinkwrap":false}},"time":{"created":"2022-06-28T23:23:38Z","modified":"2024-02-20T14:46:24Z","0.0.0":"2022-06-28T23:23:38Z","21.2.1":"2022-06-28T23:23:38Z","21.3.0-beta.1":"2022-06-28T23:23:38Z","21.3.0-beta.2":"2022-06-28T23:23:38Z","21.3.0-beta.3":"2022-06-28T23:23:38Z","21.3.0-beta.4":"2022-06-28T23:23:38Z","21.3.0-beta.5":"2022-06-28T23:23:38Z","21.3.0-beta.6":"2022-06-28T23:23:38Z","21.3.0-beta.7":"2022-06-28T23:23:38Z","21.3.0-beta.8":"2022-06-28T23:23:38Z","21.3.0-beta.9":"2022-06-28T23:23:38Z","21.3.0-beta.10":"2022-06-28T23:23:38Z","21.3.0-beta.11":"2022-06-28T23:23:38Z","21.3.0-beta.12":"2022-06-28T23:23:38Z","21.3.0-beta.13":"2022-06-28T23:23:38Z","21.3.0-beta.14":"2022-06-28T23:23:38Z","21.3.0-beta.15":"2022-06-28T23:23:38Z","22.0.0":"2022-06-28T23:23:38Z","22.0.1":"2022-06-28T23:23:38Z","22.0.2":"2022-06-28T23:23:38Z","22.0.3":"2022-06-28T23:23:38Z","22.0.6":"2022-06-28T23:23:38Z","22.1.0":"2022-06-28T23:23:38Z","22.2.0":"2022-06-28T23:23:38Z","22.2.2":"2022-06-28T23:23:38Z","22.4.3":"2022-06-28T23:23:38Z","23.0.0-alpha.0":"2022-06-28T23:23:38Z","23.0.0-alpha.1":"2022-06-28T23:23:38Z","23.0.0-alpha.2":"2022-06-28T23:23:38Z","23.0.0-alpha.4":"2022-06-28T23:23:38Z","23.0.0-alpha.5":"2022-06-28T23:23:38Z","23.0.0-alpha.7":"2022-06-28T23:23:38Z","23.0.0-alpha.3r":"2022-06-28T23:23:38Z","23.0.0-alpha.5r":"2022-06-28T23:23:38Z","23.0.0-alpha.6r":"2022-06-28T23:23:38Z","23.0.0-beta.0":"2022-06-28T23:23:38Z","23.0.0-beta.1":"2022-06-28T23:23:38Z","23.0.0-beta.2":"2022-06-28T23:23:38Z","23.0.0-beta.3r":"2022-06-28T23:23:38Z","23.0.0-charlie.0":"2022-06-28T23:23:38Z","23.0.0-charlie.1":"2022-06-28T23:23:38Z","23.0.0-charlie.2":"2022-06-28T23:23:38Z","23.0.0-charlie.3":"2022-06-28T23:23:38Z","23.0.0-charlie.4":"2022-06-28T23:23:38Z","23.0.0":"2022-06-28T23:23:38Z","23.0.1":"2022-06-28T23:23:38Z","23.2.0":"2022-06-28T23:23:38Z","24.0.0-alpha.0":"2022-06-28T23:23:38Z","24.0.0-alpha.1":"2022-06-28T23:23:38Z","24.0.0-alpha.2":"2022-06-28T23:23:38Z","24.0.0-alpha.4":"2022-06-28T23:23:38Z","24.0.0-alpha.5":"2022-06-28T23:23:38Z","24.0.0-alpha.6":"2022-06-28T23:23:38Z","24.0.0-alpha.7":"2022-06-28T23:23:38Z","24.0.0-alpha.8":"2022-06-28T23:23:38Z","24.0.0-alpha.9":"2022-06-28T23:23:38Z","24.0.0-alpha.10":"2022-06-28T23:23:38Z","24.0.0-alpha.11":"2022-06-28T23:23:38Z","24.0.0-alpha.12":"2022-06-28T23:23:38Z","24.0.0-alpha.13":"2022-06-28T23:23:38Z","24.0.0-alpha.14":"2022-06-28T23:23:38Z","24.0.0-alpha.15":"2022-06-28T23:23:38Z","24.0.0-alpha.16":"2022-06-28T23:23:38Z","24.0.0":"2022-06-28T23:23:38Z","24.2.0-alpha.0":"2022-06-28T23:23:38Z","24.3.0":"2022-06-28T23:23:38Z","24.3.1":"2022-06-28T23:23:38Z","24.4.0":"2022-06-28T23:23:38Z","24.6.0":"2022-06-28T23:23:38Z","24.9.0":"2022-06-28T23:23:38Z","25.0.0":"2022-06-28T23:23:38Z","25.1.0":"2022-06-28T23:23:38Z","25.2.0-alpha.86":"2022-06-28T23:23:38Z","25.2.0":"2022-06-28T23:23:38Z","25.2.1-alpha.1":"2022-06-28T23:23:38Z","25.2.1-alpha.2":"2022-06-28T23:23:38Z","25.2.1":"2022-06-28T23:23:38Z","25.2.6":"2022-06-28T23:23:38Z","25.4.0":"2022-06-28T23:23:38Z","25.5.0":"2022-06-28T23:23:38Z","26.0.0-alpha.0":"2022-06-28T23:23:38Z","26.0.0":"2022-06-28T23:23:38Z","26.1.0":"2022-06-28T23:23:38Z","26.2.0":"2022-06-28T23:23:38Z","26.2.1":"2022-06-28T23:23:38Z","26.3.0":"2022-06-28T23:23:38Z","26.5.0":"2022-06-28T23:23:38Z","26.6.1":"2022-06-28T23:23:38Z","26.6.2":"2022-06-29T18:20:19Z","27.0.0-next.0":"2022-06-28T23:23:38Z","27.0.0-next.2":"2022-06-28T23:23:38Z","27.0.0-next.3":"2022-06-28T23:23:38Z","27.0.0-next.4":"2022-06-28T23:23:38Z","27.0.0-next.5":"2022-06-28T23:23:38Z","27.0.0-next.6":"2022-06-28T23:23:38Z","27.0.0-next.7":"2022-06-28T23:23:38Z","27.0.0-next.8":"2022-06-28T23:23:38Z","27.0.0-next.9":"2022-06-28T23:23:38Z","27.0.0-next.10":"2022-06-28T23:23:38Z","27.0.0-next.11":"2022-06-28T23:23:38Z","27.0.0":"2022-06-28T23:23:38Z","27.0.1":"2022-06-28T23:23:38Z","27.0.2":"2022-06-28T23:23:38Z","27.0.6":"2022-08-17T01:12:42Z","27.1.0":"2022-06-28T23:23:38Z","27.1.1":"2022-06-28T23:23:38Z","27.2.0":"2022-06-28T23:23:38Z","27.2.2":"2022-06-28T23:23:38Z","27.2.3":"2022-06-28T23:23:38Z","27.2.4":"2022-06-28T23:23:38Z","27.2.5":"2022-06-28T23:23:38Z","27.3.0":"2022-06-28T23:23:38Z","27.3.1":"2022-07-15T17:00:30Z","27.4.0":"2022-06-28T23:23:38Z","27.4.1":"2022-06-28T23:23:38Z","27.4.2":"2022-06-28T23:23:38Z","27.4.4":"2022-06-28T23:23:38Z","27.4.5":"2022-06-29T18:21:41Z","27.4.6":"2022-06-28T23:23:38Z","27.5.0":"2022-06-28T23:23:38Z","27.5.1":"2022-06-28T23:23:51Z","28.0.0-alpha.0":"2022-06-28T23:23:38Z","28.0.0-alpha.1":"2022-06-28T23:23:38Z","28.0.0-alpha.2":"2022-06-28T23:23:38Z","28.0.0-alpha.3":"2022-06-28T23:23:38Z","28.0.0-alpha.4":"2022-06-28T23:23:38Z","28.0.0-alpha.5":"2022-06-28T23:23:38Z","28.0.0-alpha.6":"2022-06-28T23:23:38Z","28.0.0-alpha.7":"2022-06-28T23:23:38Z","28.0.0-alpha.8":"2022-06-28T23:23:38Z","28.0.0-alpha.9":"2022-06-28T23:23:38Z","28.0.0-alpha.11":"2022-06-28T23:23:38Z","28.0.0":"2022-06-28T23:23:38Z","28.0.1":"2022-06-28T23:23:38Z","28.0.2":"2022-06-28T23:23:38Z","28.1.0":"2022-06-28T23:23:38Z","28.1.1":"2022-06-28T23:23:38Z","28.1.3":"2023-01-13T12:59:39Z","29.0.0-alpha.0":"2022-07-17T23:39:41Z","29.0.0-alpha.1":"2022-08-04T08:40:18Z","29.0.0-alpha.3":"2022-08-07T14:44:04Z","29.0.0-alpha.4":"2022-08-08T14:44:07Z","29.0.0-alpha.5":"2022-08-11T14:42:01Z","29.0.0-alpha.6":"2022-08-19T14:43:10Z","29.0.0":"2022-08-25T14:43:40Z","29.0.1":"2022-08-26T14:42:54Z","29.0.2":"2022-09-03T11:39:29Z","29.0.3":"2022-09-10T14:44:42Z","29.1.0":"2022-09-28T08:38:54Z","29.1.2":"2022-09-30T08:42:45Z","29.2.0":"2022-10-14T11:38:35Z","29.2.1":"2022-10-18T17:43:13Z","29.3.0":"2022-11-07T20:43:44Z","29.3.1":"2022-11-08T23:42:32Z","29.4.0":"2023-01-24T11:52:10Z","29.4.1":"2023-01-26T17:54:16Z","29.4.2":"2023-02-07T14:44:57Z","29.4.3":"2023-02-15T14:55:09Z","29.5.0":"2023-03-24T16:54:55Z","29.6.0":"2023-07-04T17:52:45Z","29.6.1":"2023-07-06T14:42:25Z","29.6.2":"2023-08-07T20:04:55Z","29.6.3":"2023-08-22T22:36:41Z","29.6.4":"2023-08-24T11:58:36Z","29.7.0":"2023-12-19T06:18:56Z","30.0.0-alpha.1":"2023-10-30T17:39:54Z","30.0.0-alpha.2":"2023-11-16T14:46:00Z","30.0.0-alpha.3":"2024-02-20T14:46:24Z"}}
{"_id":"@sinclair/typebox","_rev":"8e209da0-c1ae-493d-bb39-e438a5a42748","name":"@sinclair/typebox","dist-tags":{"latest":"0.32.18","dev":"0.32.0-dev-28"},"versions":{"0.8.0":{"_id":"@sinclair/typebox@0.8.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.8.0","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"npm run spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"b075e04c6e1eb3c997ce50f4638606b0a44f3515","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.8.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.8.0.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.8.0_1583359911043_0.034058186348479236"},"_hasShrinkwrap":false},"0.8.1":{"_id":"@sinclair/typebox@0.8.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.8.1","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e891f05bb706e0feedf5a09b6e3e4592114b2495","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.8.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.8.1.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.8.1_1583363401145_0.2970624065230636"},"_hasShrinkwrap":false},"0.9.0":{"_id":"@sinclair/typebox@0.9.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.0","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5aabed0a3a2205f5dad9f0a88b104752d7c02eed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.0.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.0_1583375400842_0.6495084434058633"},"_hasShrinkwrap":false},"0.9.1":{"_id":"@sinclair/typebox@0.9.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.1","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"59169451613fee4d4fc97754f6632cbf35774a7a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.1.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.1_1583375876361_0.4468361164738972"},"_hasShrinkwrap":false},"0.9.2":{"_id":"@sinclair/typebox@0.9.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.2","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"fbc48a03e5125398731d1bd9e59ac250095da54d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.2.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.2.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.2_1583468250488_0.44867105115684347"},"_hasShrinkwrap":false},"0.9.3":{"_id":"@sinclair/typebox@0.9.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.3","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"228b5aa00fc839ae9865a890ce2a36d4f7605ad1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.3.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.3.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.3_1583491102475_0.5985503932480156"},"_hasShrinkwrap":false},"0.9.4":{"_id":"@sinclair/typebox@0.9.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.4","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"80c8ed73682f59a0ece23430f87fc72beb11adcf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.4.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.4.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.4_1583498609810_0.9033757547056813"},"_hasShrinkwrap":false},"0.9.5":{"_id":"@sinclair/typebox@0.9.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.5","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"261591913fe6a76de36e478c39b640c3c7783335","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.5.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.5.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.5_1583509471723_0.6820419851638333"},"_hasShrinkwrap":false},"0.9.6":{"_id":"@sinclair/typebox@0.9.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.6","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5135f299ef19fa63dbd148ea9d60d6d6387ff74b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.6.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.6.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.6_1583514677014_0.9003093816850498"},"_hasShrinkwrap":false},"0.9.7":{"_id":"@sinclair/typebox@0.9.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.7","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"3c029f03bc6da4c34f989779e3f9c23a30cac9d3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.7.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.7.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.7_1583563424129_0.8510498241402402"},"_hasShrinkwrap":false},"0.9.8":{"_id":"@sinclair/typebox@0.9.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.8","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"48ddf8dd686702d2635146193347ddfe3860b102","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.8.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.8.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.8_1583644980404_0.25037394753850983"},"_hasShrinkwrap":false},"0.9.9":{"_id":"@sinclair/typebox@0.9.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.9","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e4c74ac66eff8f86127eaa8e7e8645117d7e5a13","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.9.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.9.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.9_1584007727813_0.24434255104374758"},"_hasShrinkwrap":false},"0.9.10":{"_id":"@sinclair/typebox@0.9.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.10","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"42d7c39b605f679c96806cdb6c201eb3832dd6c5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.10.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.10.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.10_1585637031786_0.391635058577644"},"_hasShrinkwrap":false},"0.9.11":{"_id":"@sinclair/typebox@0.9.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.11","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e00974e013da43226bb0691d6a24b7e61e72926a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.11.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.11.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.11_1585637875266_0.47547938982304805"},"_hasShrinkwrap":false},"0.9.12":{"_id":"@sinclair/typebox@0.9.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.12","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"2e2edaa783a3a3734fd87ba3fd59a6e3d3e798e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.12.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.12.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.12_1585662121351_0.37525665927037877"},"_hasShrinkwrap":false},"0.9.13":{"_id":"@sinclair/typebox@0.9.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.13","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"1536ae77fe3980d84922d95b51168529efb17b0f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.13.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.13.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.13_1585838194388_0.057461177993584966"},"_hasShrinkwrap":false},"0.9.14":{"_id":"@sinclair/typebox@0.9.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.14","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"057e285ba686047a03a90a09045d3b01680a91f0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.14.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.14.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.14_1588575403097_0.9387609837301745"},"_hasShrinkwrap":false},"0.9.15":{"_id":"@sinclair/typebox@0.9.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.15","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"748db23ef34c81bdee56de3a8ebafa55ad12b083","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.15.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.15.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.15_1588994004640_0.015289996197237032"},"_hasShrinkwrap":false},"0.9.16":{"_id":"@sinclair/typebox@0.9.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.16","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"804b1a4b08f545ea98593c6e7e682679cf8fd5fc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.16.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.16.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.16_1589535296147_0.4033076836931868"},"_hasShrinkwrap":false},"0.10.0":{"_id":"@sinclair/typebox@0.10.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.10.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"ad83b7fc17cb6910f22ca80d96bbfd5106e35c72","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.10.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.10.0.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.10.0_1589783662994_0.4001287125325905"},"_hasShrinkwrap":false},"0.10.1":{"_id":"@sinclair/typebox@0.10.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.10.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5239a7f3b3e51bab3c2838550639350126746079","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.10.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.10.1.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.10.1_1590414990008_0.87007409594856"},"_hasShrinkwrap":false},"0.11.0":{"_id":"@sinclair/typebox@0.11.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.11.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"9e85f2dd1753d3e464582060d5f6a0f3b0b29b7b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.11.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.11.0.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.5","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.11.0_1602908743141_0.8280791332792752"},"_hasShrinkwrap":false},"0.12.0":{"_id":"@sinclair/typebox@0.12.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"72b742796487a8ad911f048a37f2b55dbc07625a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.0.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.0_1604170116743_0.7477237969510224"},"_hasShrinkwrap":false},"0.12.1":{"_id":"@sinclair/typebox@0.12.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"70a97c29498550279586d128185809e17e66f291","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.1.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.1_1604171665021_0.051200586153316685"},"_hasShrinkwrap":false},"0.12.2":{"_id":"@sinclair/typebox@0.12.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"7462ff99916fd8bb7c9c8abd81b44f71e590e172","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.2.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.2.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.2_1604227112292_0.4495630449154575"},"_hasShrinkwrap":false},"0.12.3":{"_id":"@sinclair/typebox@0.12.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"0add73c83ae77649fe9a5445efd89754c7138fd6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.3.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.3.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.3_1604582711962_0.9065093403811142"},"_hasShrinkwrap":false},"0.12.4":{"_id":"@sinclair/typebox@0.12.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"8d81f5e842da78b1ad860a9c6230dad95252d4de","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.4.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.4.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.4_1605120798397_0.4285299812299943"},"_hasShrinkwrap":false},"0.12.5":{"_id":"@sinclair/typebox@0.12.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e77b76db44b878b40bf598f913fd62a501194926","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.5.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.5.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.5_1605439356050_0.36491103310682504"},"_hasShrinkwrap":false},"0.12.6":{"_id":"@sinclair/typebox@0.12.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"80273dc4e6fdaac53074b06a7e28db0cc804c00e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.6.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.6.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.6_1605490754173_0.4171287343015093"},"_hasShrinkwrap":false},"0.12.7":{"_id":"@sinclair/typebox@0.12.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4ff89150cabd1395fd8a7dc30c8a613fb6c626e1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.7.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.7.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.7_1605809372330_0.03457435847785506"},"_hasShrinkwrap":false},"0.12.8":{"_id":"@sinclair/typebox@0.12.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a54bed6c7730d9c40b077c14310cd32d73e3ac5b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bJ/ZCkGKRW55pg3bkMfr4N7XDWQVTjPNhjXXAoEetpD+Sf/8ODUNTuqxHXjDSCDv+2EtDgyaE0kp7YNvXqcLVQ==","_from":"file:sinclair-typebox-0.12.8.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.8_1613870104931_0.6218090880840199"},"_hasShrinkwrap":false},"0.12.9":{"_id":"@sinclair/typebox@0.12.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.9","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4444c9bb2f98fcee693cbcb69256bd3dde8b4543","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-JQzO2wlZ2wJdCft30wRMmxPcTEz4cDS4Hi2izVoFgGzTo5/eJKxCpklc2WTa7K24s7f3L5DKvhlC6RKcf2WNhA==","_from":"file:sinclair-typebox-0.12.9.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.9_1614241022383_0.9309834514913089"},"_hasShrinkwrap":false},"0.14.0":{"_id":"@sinclair/typebox@0.14.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.14.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"83277e5fad5294d607cf9f789cedab3fa9571843","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.14.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Y49c44s0zPcVbuUPAAlO3mAx7IUo5XDbWJrHOc7IcpuragP/dKdYOy4mOLktaiJ1ciBXXH82sGVdkjGaDssr8g==","_from":"file:sinclair-typebox-0.14.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.14.0_1615896987252_0.4688064491306243"},"_hasShrinkwrap":false},"0.14.1":{"_id":"@sinclair/typebox@0.14.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.14.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a306436ff4beba1e98e635f58d6625aa56b3de6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.14.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-SPm1ttNRHTK+kcJmkjqc0PwzCxhtre32lGcsdn6s+mXrpOm3RdjclBrRhE1/t96hRKb7qXrx/SHZoor4aEkI9Q==","_from":"file:sinclair-typebox-0.14.1.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.14.1_1615897222669_0.8195024516596479"},"_hasShrinkwrap":false},"0.15.0":{"_id":"@sinclair/typebox@0.15.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.15.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"b0cc1179f8af0d244a927bf8e071ad19ef199a17","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.15.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-lKSdEZJJxzK3ll8qaCBuU18/XMZR9Yt/awOuDugMATOyLLk7lCDcdiNs2wAN60/MSTpx94NfbfVTRLrP6frkHA==","_from":"file:sinclair-typebox-0.15.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.15.0_1615974883846_0.9454264424925964"},"_hasShrinkwrap":false},"0.16.0":{"_id":"@sinclair/typebox@0.16.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a1e0af52f26b5006bba4703c405102419f9cbc48","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+5ucTvISuUyxE4yvSjpx5vZWThK/ya0MbOIgwxfhEdZSZje0v1xiGuZWAA/7/dcalu8WGKGopyf5fsHF4giiEg==","_from":"file:sinclair-typebox-0.16.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.0_1616266633122_0.3824878343413336"},"_hasShrinkwrap":false},"0.16.1":{"_id":"@sinclair/typebox@0.16.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"1534198931db61e5c630106909a02743376bef10","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-M2e35t7IKJYlIIvLAHYeAHAubdW5Dlb4v6lpeH630G7ebWv5nfJKQoCOMku7OngfScN936Z9y0ZD1r4NhRVWHQ==","_from":"file:sinclair-typebox-0.16.1.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.1_1617077407522_0.5305074916974941"},"_hasShrinkwrap":false},"0.16.2":{"_id":"@sinclair/typebox@0.16.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"f81ea9def0aaf3a7152c1b73d8db9122a37219da","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-fvGbn6K+gZY/aJDCdWiA/NmdIfSSXYDTs/8DMIxFGhbvDPPJSKpKam99SAygfJsAzfhN/SIh71GCiFPWrw33lQ==","_from":"file:sinclair-typebox-0.16.2.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.2_1617732034441_0.03358383816301269"},"_hasShrinkwrap":false},"0.16.3":{"_id":"@sinclair/typebox@0.16.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"2db54d30a8e1f47d2bc0a23b665c07e650e3b645","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-jWGmkmPtxiipL3zGuoq3aX5TIyXkqUXC9BrdwsAlxQ+ufzOgRhHuwBdKc6CuD98Sn8W7e0XdoJvOx6PhEAf3IQ==","_from":"file:sinclair-typebox-0.16.3.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.3_1618064815435_0.07936137507120855"},"_hasShrinkwrap":false},"0.16.4":{"_id":"@sinclair/typebox@0.16.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"90cc259857230476bf40765ee30f79ec6012fa4d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KMDgWZ+8kmaiHW/rbJfmxk8eUWOx2sflyeeYIVmAk0Nk3/GEkDW1QhyP2/eelsv/ZkqeNwlFoSMGxB0fb/TwKQ==","_from":"file:sinclair-typebox-0.16.4.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.4_1618116566297_0.4967920424996035"},"_hasShrinkwrap":false},"0.16.5":{"_id":"@sinclair/typebox@0.16.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"c5fea69bb29f1b2a72e4d87851d8b2461b47994f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.5.tgz"},"types":"./typebox.d.ts","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.5_1618284734612_0.41774579474672136"},"_hasShrinkwrap":false},"0.16.6":{"_id":"@sinclair/typebox@0.16.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4ef0810c8b6c9ab2da9040da87cdb4d7d3108395","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZD2FapdV8rZweAa5wqBHN7yB3HyRJdY5ty1e8b2YQjw+j4WPYNZN3FbpDUFMXD6Cd51gickYEin3Q8YF2K7Q7g==","_from":"file:sinclair-typebox-0.16.6.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.6_1621308365772_0.5174433428929068"},"_hasShrinkwrap":false},"0.16.7":{"_id":"@sinclair/typebox@0.16.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"3187369b2ff237f57477ef155be4c992e592fa7c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d12AkLZJXD30hXBhJSgf33RqGO0NMHIDzsQPYfp6WGoaSuMnSGIUanII2OUbeZFnD/j3Nbl2zifgO2+5tPClCQ==","_from":"file:sinclair-typebox-0.16.7.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.7_1621311113811_0.2830577939602723"},"_hasShrinkwrap":false},"0.17.0":{"_id":"@sinclair/typebox@0.17.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6ddb9286a49fdc5b36fcccb6ab2de56d97f0ffd3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cHkdl1XP2EUGQVnaVgWT48VTgwI695/+W9LrDn1qTudDtmkUK6dS+Da79jZUvSeRFqglQTmDrbiXyugDx0kD/A==","_from":"file:sinclair-typebox-0.17.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.0_1624690904125_0.7974732075309647"},"_hasShrinkwrap":false},"0.17.1":{"_id":"@sinclair/typebox@0.17.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"945392b4aaab513ec7899c48ab0040e9933b46b9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-rva9A1kYSDDmXnu/YfBNlW1RbZVJJo8rzY+9gytOxpG9FF+lgL/8JHK6gJsXA1mFjO8DF7+55BiR7MP+zQMLCA==","_from":"file:sinclair-typebox-0.17.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.1_1624693263513_0.07996416645691573"},"_hasShrinkwrap":false},"0.17.2":{"_id":"@sinclair/typebox@0.17.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6d3ad611ce284d14297787e3343860bddf2a5007","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-sma4R8zamJJlGWsDOtl41z4XVinREox85eVtfVJpFFBbFk9jyDcUgzXvYY1uZV8nRsMjXcngmxpw8SVww+0r3A==","_from":"file:sinclair-typebox-0.17.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.2_1625310277122_0.9412102957062185"},"_hasShrinkwrap":false},"0.17.3":{"_id":"@sinclair/typebox@0.17.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"c140a0b3c73e4636bc7c48bfc62838ec7d4f5f56","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PnELUAhjAXJRdCJsaG5/qLrjqzy4YO8cJUbGmLsalhYsGytS6dtKJ3wz5TsYW7syY0EjLmo8FjNP+W2DdYJLyQ==","_from":"file:sinclair-typebox-0.17.3.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.3_1625332396306_0.3208711351561717"},"_hasShrinkwrap":false},"0.17.4":{"_id":"@sinclair/typebox@0.17.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"ccbc7ec86114bb963b5f30e4cfbd58349184bb38","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KCm+wGleBbpuyqE6Tfx6HONkM6EzJOLqd+yQ0wCkMLVG3/7DUMcCjaxA33eRgmRjNY+NL+vpZF2HZRGYS4AUEw==","_from":"file:sinclair-typebox-0.17.4.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.4_1625332593974_0.7107073872915799"},"_hasShrinkwrap":false},"0.17.5":{"_id":"@sinclair/typebox@0.17.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"544db2ae049bd517d7549bd3a00e01ac83c075e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-HxRZzRNAOd9WkENToiWMJ1TrBbxI5UyNo4HzC/HhoQhbv/1gkdDvy5IQvaivddyiurw3rE0kmeousXS+eTyc6g==","_from":"file:sinclair-typebox-0.17.5.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.5_1625559008954_0.9201363237884765"},"_hasShrinkwrap":false},"0.17.6":{"_id":"@sinclair/typebox@0.17.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"56c59321b6007edaa0d5e81dade49b6df89cf1cb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YuqlXKWYZkzMDJphA8M2cN1U2MBUembu1wmRsUcagwLLH0L0/m+79iH4VQk+WKTmgvtF9cbD5mi+j4cmSPyUYQ==","_from":"file:sinclair-typebox-0.17.6.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.6_1625559234364_0.3814591768050357"},"_hasShrinkwrap":false},"0.17.7":{"_id":"@sinclair/typebox@0.17.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"fdb7fa1e3ef0f2f943c0bb8f375427c27fcda280","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-eu/XpQu20LHTjMnuOkUlTYwombrAF0xLAvDNV2MVR6RHXfWRp7iEEz87Eef0FEkiitNeEoH4BtzLBKGAhfH7Ng==","_from":"file:sinclair-typebox-0.17.7.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.7_1625572234774_0.9448630897017243"},"_hasShrinkwrap":false},"0.17.8":{"_id":"@sinclair/typebox@0.17.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"9cef4c284d2437368d90fc36a002549681e7263b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-enm8ET5E31RYbzGYPB9p+CvRzURrNEUCS2EvUxYQCdnDJw6wBpn6N+TK7iIumCc6fTRKgoOX1InJO2cQYZA4mg==","_from":"file:sinclair-typebox-0.17.8.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.8_1626342888438_0.3249582033709708"},"_hasShrinkwrap":false},"0.18.0":{"_id":"@sinclair/typebox@0.18.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.18.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"c7f31bd7ba59634dc7b2468a873b78553b680342","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.18.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VfCZfx5BAF+NpJV+XIKqvQvZbbXCKWyTk2QYbQ8GD2BN7ipnITaKTNdJGzFQ1fZn/+4eh8tlisaNA0RLxG8isg==","_from":"file:sinclair-typebox-0.18.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.18.0_1626801049293_0.5774701300342711"},"_hasShrinkwrap":false},"0.18.1":{"_id":"@sinclair/typebox@0.18.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.18.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"2d01fe5109dfa9b97188aa98081b4ef2c9a29beb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.18.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bl1omaQJ7RKyEmhfQGGIqv9XxwngP0P1MpUFhyBQZcLpFQyNu213DRva8NMorkf+YpX833IUZL5VrqSkaCOL7Q==","_from":"file:sinclair-typebox-0.18.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.18.1_1627044214754_0.17873792461189275"},"_hasShrinkwrap":false},"0.19.0":{"_id":"@sinclair/typebox@0.19.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6725fbdb1dce93d9ccff3b82d487277a1aa980a5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+jOcKa/HVQgT+UuSsupGPdyJ3L9xr399hz9DyVgbks0AESYPkOkQNgP+CwySEjqqJcgiL0AzIPz9Q6+P4WxLOw==","_from":"file:sinclair-typebox-0.19.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.0_1627211715254_0.6394675172760469"},"_hasShrinkwrap":false},"0.19.1":{"_id":"@sinclair/typebox@0.19.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"705f1ba1c007cad2a465ce9fa892ae0adb026d6e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VQW34PPRWPX4d7RpHLqkMDQhcrcWVmZtVVh0KAblBbUAaosapAb7I2G07hmkxhCYNkWAAN9tXWtb9BFSDXN4JA==","_from":"file:sinclair-typebox-0.19.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.1_1627211922333_0.10952095893133129"},"_hasShrinkwrap":false},"0.19.2":{"_id":"@sinclair/typebox@0.19.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"3a526594d6f652ada78e6c00be84463ae48047e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0U/RVPZQw1QxhrbKV0o281ZWI1Ve3osJnyEYnwOp3slydIQHyXumbJANJeNv9BqABDiHWlmzsxSVopPHMvt3Aw==","_from":"file:sinclair-typebox-0.19.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.2_1627212356267_0.12027053311482261"},"_hasShrinkwrap":false},"0.20.0":{"_id":"@sinclair/typebox@0.20.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"f0e620ea3a4f82b2fbbd16d89a92fbe5c869ba90","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-qFKbghRt4sutWEQYchceiErGVhunbCoCssCcOjLXN6vtMMyaycCQGGEgd1kGyueucONnnO+nNYUXLXATU35j7w==","_from":"file:sinclair-typebox-0.20.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.0_1627406584783_0.6071930571258608"},"_hasShrinkwrap":false},"0.20.1":{"_id":"@sinclair/typebox@0.20.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"7a4636960dc31d95d26d831f177d39d58682744e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-uJdygXCzArkBE7sjqPljYaCKcWP3frqye46DLYJCjGgWKAKlMdMdO2g4K33uxAiRdnTAItBu6k8nQzpVLE9dxA==","_from":"file:sinclair-typebox-0.20.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.1_1627409280763_0.06865223521231445"},"_hasShrinkwrap":false},"0.20.2":{"_id":"@sinclair/typebox@0.20.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"9b43ce3b143083b4aa67bab8653005c506a6a158","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-AL347st6ZPLjvN/Pncs1O1C6MXOPgcEmgbt7+AQVfXPhwMtedn9EpzvjbvyveDPBF6iuwSZN9D6UVgPJybUgng==","_from":"file:sinclair-typebox-0.20.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.2_1627467495986_0.24338420645370618"},"_hasShrinkwrap":false},"0.20.3":{"_id":"@sinclair/typebox@0.20.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"597c30cbb2c20c6ee2ceaa9fd5146c1af968eb99","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8qopxzSWCfjKtVrjbFmIoQRJI/x7fVXQc0JrV3XJw4lzaREpRUh7OBsRcxube3T3RXxv1ztPH+BSTqwPx4peng==","_from":"file:sinclair-typebox-0.20.3.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.3_1627495156970_0.4899278222479988"},"_hasShrinkwrap":false},"0.20.4":{"_id":"@sinclair/typebox@0.20.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"d1c68a9aa320f2e1ae77d1bed595c03b3853176b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cWmUFRMdGanzrrDzE1uHyWG0FeDGf8EWtzxbGQ0zD+Dad8Y4f0xSBe1kK+27TWQKQKcC9/GuOTysmOqaQfK3Aw==","_from":"file:sinclair-typebox-0.20.4.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.4_1627496927349_0.32029499895032143"},"_hasShrinkwrap":false},"0.20.5":{"_id":"@sinclair/typebox@0.20.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"d5828bbb8237876d7937dd229e3dac71d1220771","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-WNiVFcS1rdz5KyEutpl3Wmp/AwSQHBUFTyJz7KqMLkpLhOXCj1dnvMytBM6uMS5OTwhwwq877T7EC4vDGrX5Eg==","_from":"file:sinclair-typebox-0.20.5.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.5_1629432705504_0.5948338219699616"},"_hasShrinkwrap":false},"0.20.6":{"_id":"@sinclair/typebox@0.20.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"98b08aafb4556b85e9ba78d5075aed23cf04eca1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8/y8a2Xerrfym1W0lNtFe2+1OsWSao5S7A3b2375+vcAIh0pdf6Sgz4FH2dwpVnH9bJeIiq+RvT5pbEgM9Q28Q==","_from":"file:sinclair-typebox-0.20.6.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.6_1637232143952_0.6897018829331245"},"_hasShrinkwrap":false},"0.21.0":{"_id":"@sinclair/typebox@0.21.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"fd0fbdcc760a00354a99218ce78e00c05e78fead","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-UVtAtxCHhixACtlZAvRCS3pBNOPGwYkpY6zpHbSEyOBuTmYunGTzXlnsD/+Hu61l9xdF8mqyebg8lnzMOr/Vlg==","_from":"file:sinclair-typebox-0.21.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.0_1637263354464_0.8851163995993059"},"_hasShrinkwrap":false},"0.21.1":{"_id":"@sinclair/typebox@0.21.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"e89170c12da6369a2099f47d5dfcdb1b5239f5db","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-pdD7wcj7WOu0F7s2ITLGJjwS8y+Vzbh96cHi5PccKFD/0NV4HmnW+1rVQhSnQ0g9K6zUGiHu1JZIasdljGWHaw==","_from":"file:sinclair-typebox-0.21.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.1_1637298148539_0.654900276264692"},"_hasShrinkwrap":false},"0.21.2":{"_id":"@sinclair/typebox@0.21.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"d23a42adafc482f4893994e22916b0b54e18c23d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YeGOsWyjmGS26VxfvxbDgO7In4em8riCI5hEe/NnjM72ifoLQNUeHxwFNufXVIcaaPEK4fCV+fYoLKgmpPKjsA==","_from":"file:sinclair-typebox-0.21.2.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.2_1637311102264_0.5226018427532988"},"_hasShrinkwrap":false},"0.22.0":{"_id":"@sinclair/typebox@0.22.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.22.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"503448f3b76d86f87342739621610e766103a5ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.22.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KEB7UiEMw43/x2urIAlUD1bu0JUTiTNcEMcGVM0pYq2mAHg8CbVQHMP1xGSCbPWpmoej/oaz3lGLO7XZN9AN9Q==","_from":"file:sinclair-typebox-0.22.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.22.0_1637572808394_0.7562884039335187"},"_hasShrinkwrap":false},"0.22.1":{"_id":"@sinclair/typebox@0.22.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.22.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"718162cb38d5cf732ea348821cce00d88a10d2b3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.22.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cYkZ5oYd/KrzwcocLtGI4QRi6oniV4eP8IEefEhZp8YjLhrsrHiiaeChs8a9T/YKIlIjHMoxoOCWOUkZ/vviNw==","_from":"file:sinclair-typebox-0.22.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.22.1_1637656814938_0.17706449883164566"},"_hasShrinkwrap":false},"0.23.0":{"_id":"@sinclair/typebox@0.23.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"67da07e1e3be6d18f861728ba0a83cc7fee462e3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-G8+yjtQlXVBOSWqsi8ezmmt2Y4VyR+FJOvYV/3DwKcJiAvyU+WcSA9chS5X3H+2VN3L/MEHm/puenGo9S6kbcw==","_from":"file:sinclair-typebox-0.23.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.0_1638210430014_0.15507066709494866"},"_hasShrinkwrap":false},"0.23.1":{"_id":"@sinclair/typebox@0.23.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"14a945aa26a41a875a219db00b293c0bbe4fb804","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XsmyWfps86gFmZhK97HDesbCe/pR+8qf/VveZaADI6oCk0cHGq6WeKdUHM/a8NeSetv/vpUf19ubwU34C2PVWw==","_from":"file:sinclair-typebox-0.23.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.1_1638559461750_0.1201321149718595"},"_hasShrinkwrap":false},"0.23.2":{"_id":"@sinclair/typebox@0.23.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"387c20aacf9c9f7e55f8b6fc80ebef946ca818d8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Q2+xTM1zfzYt0TnSFQooG8RY3i39qi3VZRfTS75h5V2qGqqk6ZHHTTtuB1fBtolPRO8+cNCT7nny9bdFmW787w==","_from":"file:sinclair-typebox-0.23.2.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.2_1640184987543_0.15811760414373"},"_hasShrinkwrap":false},"0.23.3":{"_id":"@sinclair/typebox@0.23.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"83e127d1c5f9d79d76004a1b36f7b483f5056918","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zIjVOx3n08kLSAE6o4BhOUtgkpvbrZmR6B+lJLl/tP78GB7KpLrOK15FC9sKaWZHLtnObIDAQV5kihLbisgYYw==","_from":"file:sinclair-typebox-0.23.3.tgz","_nodeVersion":"16.13.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.3_1642896498399_0.7081304169967535"},"_hasShrinkwrap":false},"0.23.4":{"_id":"@sinclair/typebox@0.23.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"6ff93fd2585ce44f7481c9ff6af610fbb5de98a4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0/WqSvpVbCBAV1yPeko7eAczKbs78dNVAaX14quVlwOb2wxfKuXCx91h4NrEfkYK9zEnyVSW4JVI/trP3iS+Qg==","_from":"file:sinclair-typebox-0.23.4.tgz","_nodeVersion":"16.13.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.4_1645103577540_0.8454530339502178"},"_hasShrinkwrap":false},"0.23.5":{"_id":"@sinclair/typebox@0.23.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"93f7b9f4e3285a7a9ade7557d9a8d36809cbc47d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-AFBVi/iT4g20DHoujvMH1aEDn8fGJh4xsRGCP6d8RpLPMqsNPvW01Jcn0QysXTsg++/xj25NmJsGyH9xug/wKg==","_from":"file:sinclair-typebox-0.23.5.tgz","_nodeVersion":"16.13.1","_npmVersion":"8.5.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.5_1651218905582_0.6088332311992679"},"_hasShrinkwrap":false},"0.24.0":{"_id":"@sinclair/typebox@0.24.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"07f233080e6840f41c4fe8eadb172102a7328092","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-UsOG+42zjQrmAAdxXitRI43fUYNwef9bq5jSwWKOe9q0NWrR1zkWe1ceXSYwuf3tkC7rJitiT0kHWMkCKiSfzA==","_from":"file:sinclair-typebox-0.24.0.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.0_1656508059136_0.7187567085541802"},"_hasShrinkwrap":false},"0.24.1":{"_id":"@sinclair/typebox@0.24.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"b4ff200fb4f18dfd15c53e984d8801e2c8df1526","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-v59jW0KQIy4iMP0Pn7gcpQ48YDXa9vOopsRhaPWmsStTxaVNYIqFY3eK6y4PU+53hlQoaQ8pAxU4cPIaMFEJwg==","_from":"file:sinclair-typebox-0.24.1.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.1_1656514181831_0.0032912113645298113"},"_hasShrinkwrap":false},"0.24.2":{"_id":"@sinclair/typebox@0.24.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"29f290d20a144ee47106206309eceb1488166d41","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-EpdWGQtmnZbXMioI90e+JSL0DnYINu8OX4ruVEXhoXAbgUgSmkpz5FWTiLai1sfg8AfpX8XDCLF50gzlEcBv2A==","_from":"file:sinclair-typebox-0.24.2.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.2_1656604011535_0.5667895059651575"},"_hasShrinkwrap":false},"0.24.3":{"_id":"@sinclair/typebox@0.24.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"dd74a836233305bca4078c23d7ab926ad53e8ed6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/h/IFTmwpLQeHbtkPb7DUr/jtl7VW8xZgIIAZOK5vRpKQRuJPUdJY1ltAR2Ba7n8vQLP4porDyg20oobIvXcUQ==","_from":"file:sinclair-typebox-0.24.3.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.3_1656646724930_0.6549617611621041"},"_hasShrinkwrap":false},"0.24.4":{"_id":"@sinclair/typebox@0.24.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"a22231479a4291924e424729f92ab5cb394eace4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KpJwpDfG4o4DM+zm4k4hGVH5pRRTgmxptFzU6QtXTKsuNW8UPkxapEOUDXMnBj+FhsfVHM3fUVAvAVj0ki6lAQ==","_from":"file:sinclair-typebox-0.24.4.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.4_1656662213259_0.867266456483494"},"_hasShrinkwrap":false},"0.24.5":{"_id":"@sinclair/typebox@0.24.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"b43b65329e2b78d4260997899d28965171315afc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Te3ZdSGjvNg9knge4ZvHpAn4Pjr5jV1GfKKWJtZzWtyDB0tIWIVVJLqaD0sXFyWqFnKKzjzFsRbDRvd/5ejawQ==","_from":"file:sinclair-typebox-0.24.5.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.5_1656668737338_0.8168874372446935"},"_hasShrinkwrap":false},"0.24.6":{"_id":"@sinclair/typebox@0.24.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"ea71148b019cd40cc1a51f644abac33cad81a2d2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ziqHFbpqzAuXtDFx4hwwPR1fm6SyfzhQoYXkmLZq4rFzRob1TDtjhI68rV84V7voqhb0yrwVJSwbOc3nm+0avQ==","_from":"file:sinclair-typebox-0.24.6.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.6_1656735761379_0.011198753759123159"},"_hasShrinkwrap":false},"0.24.7":{"_id":"@sinclair/typebox@0.24.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"633f3f223db742469bc59221bd636f18bbc2a964","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-K/sf9yfEU3Z8rmd2t4HCPLsatI5Fovzf+aODyCez5RMqgy/ZLv1bHLobFnXH90UAi9UBYUXWCxYBsUznSqZYkg==","_from":"file:sinclair-typebox-0.24.7.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.7_1656739273782_0.5094830765394163"},"_hasShrinkwrap":false},"0.24.8":{"_id":"@sinclair/typebox@0.24.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"2e41fb3b48f1985749aee8fe7ca16c15a5b021fb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4Cf8AFKViEeTifdga3mQxNmWbLPQJ0Ab5nAODCWulf58rWEqFEiBBsqc/RoRdugW0QyMwl0pZTKDyrVhGEYOYA==","_from":"file:sinclair-typebox-0.24.8.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.8_1656914288705_0.38293575683211767"},"_hasShrinkwrap":false},"0.24.9":{"_id":"@sinclair/typebox@0.24.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.9","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"5e66a3c9adff81efe06a80dd189fca2810987588","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ID/my8r4g0fp9aefo+bmEApgEgG6Sid42i5bmBXXXGqOK00aTMjHTNwSV2zTt7ddJn0IcevUxS7JzFn0WjwrGg==","_from":"file:sinclair-typebox-0.24.9.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.9_1656934898640_0.5637896161342006"},"_hasShrinkwrap":false},"0.24.10":{"_id":"@sinclair/typebox@0.24.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.10","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"a2459ccf83cfe83085022563b13d119ba5df73b6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+0jinSndYKPW9xGO/hj8M/y+i8g9c7RBiXp+st9ZWaYe9Fn2yNC1uQ1JwSHhm6hyQPdriC4R069K9AGGP5ChYg==","_from":"file:sinclair-typebox-0.24.10.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.10_1656994275698_0.03916689453030098"},"_hasShrinkwrap":false},"0.24.11":{"_id":"@sinclair/typebox@0.24.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.11","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"e9f4aa5056e367ed419ff60c26808f385688b521","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-oHAgeyktMgCNPu4+oDAlwgqcHYn8piH8Nw0OngLeu2HIJM7EFxzU4VrK8ACrgbXAiXWedXL4nrfMb+bALMWD6w==","_from":"file:sinclair-typebox-0.24.11.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.11_1657175119472_0.19069613441115174"},"_hasShrinkwrap":false},"0.24.12":{"_id":"@sinclair/typebox@0.24.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.12","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"0b964ab272909a41bc45d8c0454d2b04fa259b1a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-FZs52BqpKMXNzUPCLpyWjMVVkNAuN//YpgARUp8wWfBhFyt12a2C9hAITyD9Ursiju4XsP4Lk6GNJcNllHwbgw==","_from":"file:sinclair-typebox-0.24.12.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.12_1657274789279_0.4967427577895378"},"_hasShrinkwrap":false},"0.24.13":{"_id":"@sinclair/typebox@0.24.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.13","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"4705841912ea7ddfb8795bac3db8df17948f5277","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-MzpUqze7Gmj1ZNNanFov1QtyXu+aPYV6KZILEqgKnKlbMTgS6HRZ6aAlaEmrFPHSN4KG+yoOACDkJqA+/oXwFQ==","_from":"file:sinclair-typebox-0.24.13.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.13_1657372780221_0.027267967886738687"},"_hasShrinkwrap":false},"0.24.14":{"_id":"@sinclair/typebox@0.24.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.14","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"463720b9209ddf519454ba46e27f86915c8f1b04","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+dld7HhmwiDD8nEYqdUQ/OpCMmiFnuu0huWbZ18hY6RL7ByIc4tdvvEDXPJJyCbbyaKR0R7P6gWmmdpv4btX7A==","_from":"file:sinclair-typebox-0.24.14.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.14_1657440012523_0.5778926619289857"},"_hasShrinkwrap":false},"0.24.15":{"_id":"@sinclair/typebox@0.24.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.15","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"423bc636cf47d039aa79f20cf5fc248576931290","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VtII20dRdDzJy7hk9Zh2u8wbNhFeOm7P8S9dpVIagkP7cJLDeOP5YRdSWbiZF29nkxFXhI6Axj/pZbRkT2lTTg==","_from":"file:sinclair-typebox-0.24.15.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.15_1657470943181_0.23398543355131052"},"_hasShrinkwrap":false},"0.24.16":{"_id":"@sinclair/typebox@0.24.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.16","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"d911c31b9b604084c725385369a4f1de52382517","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aWqQhrghjG38ymiiIPDhH5M2skStc5CepTBC6m0tYIdKqm5CDDPf0niJ8gC2vrRkCW6tjmJnoMucrp2j+dJvkg==","_from":"file:sinclair-typebox-0.24.16.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.16_1657471764960_0.4763035063154706"},"_hasShrinkwrap":false},"0.24.17":{"_id":"@sinclair/typebox@0.24.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.17","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"5e5ac39cc54bdcbb002555a0bdfc79f5188e63e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KyXzbBBYly+wSwbhPTKecqIWFST/anAXTlA2o23rDUMzVnFUrDyC0Gk96yL8zQw5O5OqdqALomdih6wwSdRc2Q==","_from":"file:sinclair-typebox-0.24.17.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.17_1657535071738_0.24289360767777013"},"_hasShrinkwrap":false},"0.24.18":{"_id":"@sinclair/typebox@0.24.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.18","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"962c259235908047cf4367df31bec953a2e0d1c2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-H16DM4E7fyY5X6ggtYDViOHCrHLKs8/khz6akaJ3FN+l2a/pAp1lLy921KqwR4eP40tJWaaDogU+stCnuurahQ==","_from":"file:sinclair-typebox-0.24.18.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.18_1657611092323_0.33665250524951484"},"_hasShrinkwrap":false},"0.24.19":{"_id":"@sinclair/typebox@0.24.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.19","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"5297278e0d8a1aea084685a3216074910ac6c113","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gHJu8cdYTD5p4UqmQHrxaWrtb/jkH5imLXzuBypWhKzNkW0qfmgz+w1xaJccWVuJta1YYUdlDiPHXRTR4Ku0MQ==","_from":"file:sinclair-typebox-0.24.19.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.19_1657688215343_0.586927087906"},"_hasShrinkwrap":false},"0.24.20":{"_id":"@sinclair/typebox@0.24.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"11a657875de6008622d53f56e063a6347c51a6dd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-kVaO5aEFZb33nPMTZBxiPEkY+slxiPtqC7QX8f9B3eGOMBvEfuMfxp9DSTTCsRJPumPKjrge4yagyssO4q6qzQ==","_from":"file:sinclair-typebox-0.24.20.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.20_1657875101153_0.9598524901428978"},"_hasShrinkwrap":false},"0.24.21":{"_id":"@sinclair/typebox@0.24.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"f2e435ac4c1919ae89c2b693a0d4213d09899290","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-II2SIjvxBVJmrGkkZYza/BqNjwx3PWROIA8CZ0/Hn7LV0Mv0CVpZxoyHGBVsQqfFLMv9DmArIeRHTwo76bE6oA==","_from":"file:sinclair-typebox-0.24.21.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.21_1658915961048_0.05577125064089539"},"_hasShrinkwrap":false},"0.24.22":{"_id":"@sinclair/typebox@0.24.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.22","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"0da18e6e75701d6609c7c68fe18002bb1f47345f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-JsBe3cOFpNZ6yjBYnXKhcENWy5qZE3PQZwExQ5ksA/h8qp4bwwxFmy07A6bC2R6qv6+RF3SfrbQTskTwYNTXUQ==","_from":"file:sinclair-typebox-0.24.22.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.22_1659059392761_0.6928466614416711"},"_hasShrinkwrap":false},"0.24.23":{"_id":"@sinclair/typebox@0.24.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"ce30c80e93a69e8f18fd77f8995b3afdb6bb9974","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dhpD3rztStcXgwuhJhg10CA2YJfwx799VlzZpuEi/8ijKriQST6rEpA8mDYlyaVkxWlTiVFme1s1fc6rx8+BhA==","_from":"file:sinclair-typebox-0.24.23.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.23_1659348705517_0.457725377235221"},"_hasShrinkwrap":false},"0.24.24":{"_id":"@sinclair/typebox@0.24.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"1c201951882b0954b0689b0047584776e0053c1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.24.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YaQ015FMwcveHbmI7w7X19f979CUCut2sf1gryWVV5nkAFr598jUhSpByKaC2BSBtJLT9lrDBfEo0Y2IFNipMQ==","_from":"file:sinclair-typebox-0.24.24.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.24_1659372851814_0.4984057280664649"},"_hasShrinkwrap":false},"0.24.25":{"_id":"@sinclair/typebox@0.24.25","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.25","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"61234177664cf161b621443a18f9e6714f757e2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.25.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Z0b1gkfeHzRQen7juqXIZ4P2nvI6vZV+m/PhxBlVsNH/jSg2FuqJ+x4haFFIbbct6LMA7m6x2sBob/Giecj09A==","_from":"file:sinclair-typebox-0.24.25.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.25_1659375414468_0.08659865534070899"},"_hasShrinkwrap":false},"0.24.26":{"_id":"@sinclair/typebox@0.24.26","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.26","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"84f9e8c1d93154e734a7947609a1dc7c7a81cc22","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.26.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1ZVIyyS1NXDRVT8GjWD5jULjhDyM3IsIHef2VGUMdnWOlX2tkPjyEX/7K0TGSH2S8EaPhp1ylFdjSjUGQ+gecg==","_from":"file:sinclair-typebox-0.24.26.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.26_1659412722826_0.890120941889464"},"_hasShrinkwrap":false},"0.24.27":{"_id":"@sinclair/typebox@0.24.27","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.27","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"d55643516a1546174e10da681a8aaa81e757452d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.27.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-K7C7IlQ3zLePEZleUN21ceBA2aLcMnLHTLph8QWk1JK37L90obdpY+QGY8bXMKxf1ht1Z0MNewvXxWv0oGDYFg==","_from":"file:sinclair-typebox-0.24.27.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.27_1659602158872_0.053863671780329136"},"_hasShrinkwrap":false},"0.24.28":{"_id":"@sinclair/typebox@0.24.28","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.28","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.0","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"15aa0b416f82c268b1573ab653e4413c965fe794","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.28.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dgJd3HLOkLmz4Bw50eZx/zJwtBq65nms3N9VBYu5LTjJ883oBFkTyXRlCB/ZGGwqYpJJHA5zW2Ibhl5ngITfow==","_from":"file:sinclair-typebox-0.24.28.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.28_1660321975386_0.24358698133975487"},"_hasShrinkwrap":false},"0.24.29":{"_id":"@sinclair/typebox@0.24.29","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.29","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"acf9799f22e04cb13146e3946f71561d5e33ff5b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.29.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ohR2BnUhkCCUyiYnw3Rp/MspBLXImFMnrhSjdbCmkL7RgwfFwfLKJi7sPl7Ifq93UfZq7PCyFLcyO+D/qI5Jyg==","_from":"file:sinclair-typebox-0.24.29.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.29_1661807382053_0.9060904271778507"},"_hasShrinkwrap":false},"0.24.30":{"_id":"@sinclair/typebox@0.24.30","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.30","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"70d94661a065373b7330cc2dce79424bc8e957a1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.30.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YTlUf5iAfDZEVmI4SWOBGcxpufY2XQhWqSwyLeR2Qg1pkjlM6+Pvc+9MA/+zUaiEFuuX3F3KdhqS5bcasgLc5A==","_from":"file:sinclair-typebox-0.24.30.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.30_1661808091434_0.8675767253573601"},"_hasShrinkwrap":false},"0.24.31":{"_id":"@sinclair/typebox@0.24.31","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.31","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"3f3752bc830a9daa4a0185573f0bf870089c3222","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.31.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-uWZaAsh9WFhcY1rWLLcMU/omiIIAQ/PmgqplaF6UWY6ULPH0ZO8hupJRAydzlTQZJIK3Voz8o8dYlEx+Cm6BAA==","_from":"file:sinclair-typebox-0.24.31.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.31_1661852125649_0.1806011388853752"},"_hasShrinkwrap":false},"0.24.32":{"_id":"@sinclair/typebox@0.24.32","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.32","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"214a03e430122d239a6414a5d5412c23964cafbd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.32.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-NWNTW284AOFhxgYofPef5IqDq6Y7ghZkZAkWJcUBp1r9ljfrFOKBDsiQJnLNp9tLcaSXFK9OgsS72W4RXe0jvw==","_from":"file:sinclair-typebox-0.24.32.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.32_1661930337600_0.40031395568692063"},"_hasShrinkwrap":false},"0.24.33":{"_id":"@sinclair/typebox@0.24.33","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.33","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"e7852f8cdd2fd93a9ea4de17a2dccd788a8bf50a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.33.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-c5p4Ib38ILOGfeYZWIu2Ms6EDdc2PGehzEYLevsvZ1njIt4Jt66E++4pjpBpgh+yJFj4ahnbKfYahOyLxvTBCw==","_from":"file:sinclair-typebox-0.24.33.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.33_1661968681124_0.7511750957402077"},"_hasShrinkwrap":false},"0.24.34":{"_id":"@sinclair/typebox@0.24.34","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.34","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"35b799cf98a203d1940c8ce06688f9a09fbc0f50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.34.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-x3ejWKw7rpy30Bvm6U0AQMOHdjqe2E3YJrBHlTxH0KFsp77bBa+MH324nJxtXZFpnTy/JW2h5HPYVm0vG2WPnw==","_from":"file:sinclair-typebox-0.24.34.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.34_1661970917660_0.845779932585563"},"_hasShrinkwrap":false},"0.24.35":{"_id":"@sinclair/typebox@0.24.35","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.35","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7b5ca127aefe3ed482bb60f874bebbe3143e82f5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.35.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-iN6ehuDndiTiDz2F+Orv/+oHJR+PrGv+38oghCddpsW4YEZl5qyLsWxSwYUWrKEOfjpGtXDFW6scJtjpzSLeSw==","_from":"file:sinclair-typebox-0.24.35.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.35_1662307420328_0.637072737663672"},"_hasShrinkwrap":false},"0.24.36":{"_id":"@sinclair/typebox@0.24.36","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.36","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8d44cf34fac7226c61f57b174c0b4b47652a2f8f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.36.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KxQQnSP+5x+JbBbnz0ZwCK0KQ06Wsvt8eYCUsBkt+h80+iXaVJzfDQ9GmAcypfUk/HrQL+l1Hjz1Fjeznfs+Uw==","_from":"file:sinclair-typebox-0.24.36.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.36_1662492763720_0.5023570082155973"},"_hasShrinkwrap":false},"0.24.37":{"_id":"@sinclair/typebox@0.24.37","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.37","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"3ea4cf8f3cf8a943c17baf5bb7b33587afa5f76b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.37.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8xuD57tNMHs7R0YUzFp0xqIVOTJDbFHnEN/JTej5d5o/dTx4OSsURKTT9dkWl6ghMk4zs3AYe1bi7UK0NnJ4oA==","_from":"file:sinclair-typebox-0.24.37.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.37_1662496509637_0.761011118057821"},"_hasShrinkwrap":false},"0.24.38":{"_id":"@sinclair/typebox@0.24.38","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.38","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7f68d9c5775c4c2cec0524b3b990263dd009c968","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.38.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-IbYB6vdhLFmzGEyXXEdFAJKyq7S4/RsivkgxNzs/LzwYuUJHmeNQ0cHkjG/Yqm6VgUzzZDLMZAf0XgeeaZAocA==","_from":"file:sinclair-typebox-0.24.38.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.38_1662541793172_0.5151982994861768"},"_hasShrinkwrap":false},"0.24.39":{"_id":"@sinclair/typebox@0.24.39","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.39","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"21d0c56c295a00e391e20a88a48c11d4a1210ac5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.39.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GqtkxoAjhTzoMwFg/JYRl+1+miOoyvp6mkLpbMSd2fIQak2KvY00ndlXxxkDBpuCPYkorZeEZf0LEQn9V9NRVQ==","_from":"file:sinclair-typebox-0.24.39.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.39_1662678347047_0.6267658698062895"},"_hasShrinkwrap":false},"0.24.40":{"_id":"@sinclair/typebox@0.24.40","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.40","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"00ee9b48537b147f6ffc80ebc28ab16d6016ed5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.40.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Xint60L8rF0+nRy+6fCjW9jQMmu7fTpbwTBrXZiK6eq/RHDJS7LvWX/0oXC8O7fCePmrY/XdfaTv2HiUDeCq4g==","_from":"file:sinclair-typebox-0.24.40.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.40_1662843973863_0.42825022842374283"},"_hasShrinkwrap":false},"0.24.41":{"_id":"@sinclair/typebox@0.24.41","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.41","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"45470b8bae32a28f1e0501066d0bacbd8b772804","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.41.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-TJCgQurls4FipFvHeC+gfAzb+GGstL0TDwYJKQVtTeSvJIznWzP7g3bAd5gEBlr8+bIxqnWS9VGVWREDhmE8jA==","_from":"file:sinclair-typebox-0.24.41.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.41_1663008300066_0.4697474671574682"},"_hasShrinkwrap":false},"0.24.42":{"_id":"@sinclair/typebox@0.24.42","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.42","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"a74b608d494a1f4cc079738e050142a678813f52","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.42.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d+2AtrHGyWek2u2ITF0lHRIv6Tt7X0dEHW+0rP+5aDCEjC3fiN2RBjrLD0yU0at52BcZbRGxLbAtXiR0hFCjYw==","_from":"file:sinclair-typebox-0.24.42.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.42_1663400920184_0.6415183789971715"},"_hasShrinkwrap":false},"0.24.43":{"_id":"@sinclair/typebox@0.24.43","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.43","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"2e2bce0e5e493aaf639beed0cd6c88cfde7dd3d7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.43.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1orQTvtazZmsPeBroJjysvsOQCYV2yjWlebkSY38pl5vr2tdLjEJ+LoxITlGNZaH2RE19WlAwQMkH/7C14wLfw==","_from":"file:sinclair-typebox-0.24.43.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.43_1664044907407_0.898384977300209"},"_hasShrinkwrap":false},"0.24.44":{"_id":"@sinclair/typebox@0.24.44","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.44","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"0a0aa3bf4a155a678418527342a3ee84bd8caa5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.44.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ka0W0KN5i6LfrSocduwliMMpqVgohtPFidKdMEOUjoOFCHcOOYkKsPRxfs5f15oPNHTm6ERAm0GV/+/LTKeiWg==","_from":"file:sinclair-typebox-0.24.44.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.44_1664394561505_0.19586846035770056"},"_hasShrinkwrap":false},"0.24.45":{"_id":"@sinclair/typebox@0.24.45","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.45","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"a2ea1d151276646e1c6498b06d4183c0b660d5c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.45.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tD/Zg4RR7/pVVPjgHjnbCeBshwj/4FYfkSwIew8/YmMOalXPilcQiQIbif7DR/SM/e2sZAmy4qrFKDtTjAvz8w==","_from":"file:sinclair-typebox-0.24.45.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.45_1665562222401_0.04729360562723528"},"_hasShrinkwrap":false},"0.24.46":{"_id":"@sinclair/typebox@0.24.46","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.46","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"57501b58023776dbbae9e25619146286440be34c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.46.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ng4ut1z2MCBhK/NwDVwIQp3pAUOCs/KNaW3cBxdFB2xTDrOuo1xuNmpr/9HHFhxqIvHrs1NTH3KJg6q+JSy1Kw==","_from":"file:sinclair-typebox-0.24.46.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.46_1665565152309_0.15009511973909162"},"_hasShrinkwrap":false},"0.24.47":{"_id":"@sinclair/typebox@0.24.47","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.47","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"530b67163714356f93e82bdb871e7db4b7bc564e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.47.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J4Xw0xYK4h7eC34MNOPQi6IkNxGRck6n4VJpWDzXIFVTW8I/D43Gf+NfWz/v/7NHlzWOPd3+T4PJ4OqklQ2u7A==","_from":"file:sinclair-typebox-0.24.47.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.47_1666104615693_0.5433373763742027"},"_hasShrinkwrap":false},"0.24.48":{"_id":"@sinclair/typebox@0.24.48","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.48","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"bd558c6059df563d49a4d94df8e8e0510b662e3f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.48.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-WPGpRNHbkOsfBDmh8QHU7a5NWzEuYNThST8x1cISvX0RpP+1+V8zjuJqNwGJkHGIlhdIIhv6qVYqXz2q5/gjAA==","_from":"file:sinclair-typebox-0.24.48.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.48_1666396498631_0.49574597891436323"},"_hasShrinkwrap":false},"0.24.49":{"_id":"@sinclair/typebox@0.24.49","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.49","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7a3a5569fe9e4faa47d8019246d37541c2d7a058","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.49.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-qWgJVeCThMWTJSAZHyHDlHBkJY0LARFoq/96RH4oIFAwJptMwB3Isq62c4zRVRIAF2r4RMOc2WOhtOLj5C4InA==","_from":"file:sinclair-typebox-0.24.49.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.49_1666513726610_0.7686200519134401"},"_hasShrinkwrap":false},"0.24.50":{"_id":"@sinclair/typebox@0.24.50","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.50","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"35ee4db4ab8f3a8ff56490c51f92445d2776451e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.50.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-k8ETQOOQDg5FtK7y9KJWpsGLik+QlPmIi8zzl/dGUgshV2QitprkFlCR/AemjWOTyKn9UwSSGRTzLVotvgCjYQ==","_from":"file:sinclair-typebox-0.24.50.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.50_1666515742111_0.05366137589442843"},"_hasShrinkwrap":false},"0.24.51":{"_id":"@sinclair/typebox@0.24.51","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.51","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"645f33fe4e02defe26f2f5c0410e1c094eac7f5f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.51.tgz"},"types":"./typebox.d.ts"},"0.25.0":{"_id":"@sinclair/typebox@0.25.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"90babb116b331fabd7ac598092c21a4679ee3ee4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Eb0KGwpkjo2JGj3FM5X6HjXzTONm12RsWUNInY+pa53EzV3MlwFEOBvuhY2tW7wNWrkR4XIKoRgonkJZk4lG5Q==","_from":"file:sinclair-typebox-0.25.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.0_1666987341238_0.993780588977329"},"_hasShrinkwrap":false},"0.25.1":{"_id":"@sinclair/typebox@0.25.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8caa80c24e0be5f909ce2439a0600dae3937c23c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ij7duiwNUyqplvhAqBXJAHNAT+ozsyUhmC5mLO7PqyHOAk1G91d3ITF2h9LIDbYLP5PSTNYpcxYstU+4Y4i3aQ==","_from":"file:sinclair-typebox-0.25.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.1_1666991081635_0.5035445488242405"},"_hasShrinkwrap":false},"0.25.2":{"_id":"@sinclair/typebox@0.25.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8de5684b8ef7c46444d3ee54f6711d6f4e74aa6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QWjo2shO8oUWM6rSwIz7tUY8+WxP0fhUYQvaFA5eq+sECaQjQaRZIBXgWhWzzsB+lbgjljB1zRFfyX8mudn1gQ==","_from":"file:sinclair-typebox-0.25.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.2_1667219548150_0.8859022009937798"},"_hasShrinkwrap":false},"0.25.3":{"_id":"@sinclair/typebox@0.25.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"84517e087003ad1156807dc6a48422a1ed32d65b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zIxm0hEDwflBaa/hPjiRulXK+67sPp22V5jUwb3T58MitHBVGgM+cutxneeXY2vgj3990c4L06A0oKeZT+1hhw==","_from":"file:sinclair-typebox-0.25.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.3_1667892148418_0.016709778667588937"},"_hasShrinkwrap":false},"0.25.4":{"_id":"@sinclair/typebox@0.25.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"6ddb4fd0ef420bfd32b6b10460dbfcfe87c2b897","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4orhjT9lSj61BBH77hz3whIKZRnxNGiO3nKVheNfpXhmhUEWEMBRw5Go1IFRERYqH3afFlXJzElJOZpcG5b4Sw==","_from":"file:sinclair-typebox-0.25.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.4_1667982968451_0.914500510756804"},"_hasShrinkwrap":false},"0.25.5":{"_id":"@sinclair/typebox@0.25.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8f8d6650efbe318db20616687278f7d2d37f7164","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cjauXt7Has9yaVcQ0c/DEckBTVimsty3ycyzpAJfQM/zTcfC4r6+CF8J/Ax7AHNxAhDA903OSe7Fs5TPFdLiLA==","_from":"file:sinclair-typebox-0.25.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.5_1667986063039_0.8602852731781716"},"_hasShrinkwrap":false},"0.25.6":{"_id":"@sinclair/typebox@0.25.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"1631c286161cdfeacf65e11654898c62a5b4a338","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZX6NlLpBZ13bovy93T2eEwnar7SzpKtI+ezEFa6g9o1ztYXMOCQaDfS/7PQuPH/8FNRGGU4o4Nv7i4eN77M+3w==","_from":"file:sinclair-typebox-0.25.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.6_1668079066728_0.20150445556475294"},"_hasShrinkwrap":false},"0.25.7":{"_id":"@sinclair/typebox@0.25.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"91653bc8e7d85c5c7d657a8baceb31b2e1db34b1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-P1akWHXV7H4gl4mxM6ln/4Blk74QRbCW3kmiYkNai3nDpClxF2/rwElyuz/YjBfwgdcOiSiEcrQEtoNrUnUHgQ==","_from":"file:sinclair-typebox-0.25.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.7_1668080384388_0.378414048388116"},"_hasShrinkwrap":false},"0.25.8":{"_id":"@sinclair/typebox@0.25.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"882d969dfc433cbd362f1876f8ea29b743dc32d3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/7GXgMOCfnxpIov52cPetqQ7bxRBaTBJAgp04Se2UQB1J0vUfEOIMpn63cLc3S5JXDUflCWxELKDV8eiPpmUTQ==","_from":"file:sinclair-typebox-0.25.8.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.8_1668139965070_0.04553424337229672"},"_hasShrinkwrap":false},"0.25.9":{"_id":"@sinclair/typebox@0.25.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"e36fe28d002cb17d1ed245da465733d0b045b94d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-FDfpDJJ589OME6W01GUbPoNDovU72N8LPtCTopmRttzWpeDVNFefWzzJVXmL9lw7712kXgPfcyb3/AkGZfHNeg==","_from":"file:sinclair-typebox-0.25.9.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.9_1669121786421_0.02569458297374183"},"_hasShrinkwrap":false},"0.25.10":{"_id":"@sinclair/typebox@0.25.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"98b928abc37c57bafc98147b02a1e5ae76950163","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-B7yEaT5yPZUS7kL/Ogh94n7Rb7p1DJEjCqOaPMuwAy4XXnlZchFrxIeE5pbrPsHOn5NMhWZtOnKtksaNQzCq1A==","_from":"file:sinclair-typebox-0.25.10.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.10_1669355363228_0.6727215363154413"},"_hasShrinkwrap":false},"0.25.11":{"_id":"@sinclair/typebox@0.25.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"476bad310092de48af7a9807ecd75019ac01f3d7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GgUJN0Drvh74i8gOl2S8SkHuAgkZJtzzd6EmfBVxpNDB6QmzXdZ3tyUt02Kr42X58as5I187CKiWpLCMJmdLbw==","_from":"file:sinclair-typebox-0.25.11.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.11_1670349507251_0.02501615056276907"},"_hasShrinkwrap":false},"0.25.12":{"_id":"@sinclair/typebox@0.25.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"3157d3be38a1df18f784640bb19739a38436366c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-xm46HDwYz69z8xcNh9esHYKpvhXmA02sD+K9cur6XZvwjZTSBJ8PNbK5xeSO0IYZqRzpxkXYsbpsF/hF0WdPew==","_from":"file:sinclair-typebox-0.25.12.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.12_1670587551634_0.5722623185062437"},"_hasShrinkwrap":false},"0.25.13":{"_id":"@sinclair/typebox@0.25.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"c12956684a9c57271bdf10e4686b8f85531f75af","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XiEwzYpUwE5y/k333Cy0Ujmxvw/mA4zIyEmwUyA0EDDik7ba8S/HClvz3ylOsABfYSj+/skQq4QJl0k/Z1eDLg==","_from":"file:sinclair-typebox-0.25.13.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.13_1670746429585_0.9806831578766027"},"_hasShrinkwrap":false},"0.25.14":{"_id":"@sinclair/typebox@0.25.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"2063552e614b77d5d4f2ae404449084d7e90172c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QHPtRqD95nGnJZHWolgKFNmpuY8gpqVEfyasUSJO78X62f4nKmxPbDjd8FpMmwj2J8d0gQWChLtuBtH4yw0qpA==","_from":"file:sinclair-typebox-0.25.14.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.14_1671457881070_0.005727986855571965"},"_hasShrinkwrap":false},"0.25.15":{"_id":"@sinclair/typebox@0.25.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"38d60f82e3b092043ea0fb52007de82ec040c35a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J0C9JoAFbuRx37ofnpv6ZDgPMFogUBgtVPiHyq69ictcS1E3onLWBrzxTJuByV5ngUyLEXymtYMf3TppNbJWLw==","_from":"file:sinclair-typebox-0.25.15.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.15_1671504435626_0.8804388901004891"},"_hasShrinkwrap":false},"0.25.16":{"_id":"@sinclair/typebox@0.25.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"daf07d14d93897d6f7849159d8242808b956b069","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-5sclbtYBKQ0W5hY8ovF/cBbQV+FWBZArd738hQpLgWUdlWyuOA0HOuYN178jUJRz0pXuL1+UYR+LCMvoR47osg==","_from":"file:sinclair-typebox-0.25.16.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.16_1671647711794_0.5478055902673016"},"_hasShrinkwrap":false},"0.25.17":{"_id":"@sinclair/typebox@0.25.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"77661d05d203f027745edaf92d3ab621c426ddc4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-OLQlcfNZn2Qy59LE7Fzt2dLAxvVx3F7GsAGpQPKWq1nsdzPpudaSNjwhrjc1HgtbidSxxJmSe7RNTbedFlSqkg==","_from":"file:sinclair-typebox-0.25.17.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.17_1673096700958_0.6526373102814131"},"_hasShrinkwrap":false},"0.25.18":{"_id":"@sinclair/typebox@0.25.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"e21e025d085ca3ecd41884c06f13cd3ebdad5c2a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-kJV6/P2PZmvcOY0V+Nm0pazyHMYYmuuKzTUZjnsyJHRdHRPQX/G53AwpA+39CP5k4rx2BIz3hJzRG0c8KtzLGQ==","_from":"file:sinclair-typebox-0.25.18.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.18_1673265372739_0.05607049293827315"},"_hasShrinkwrap":false},"0.25.19":{"_id":"@sinclair/typebox@0.25.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"714a62f4b6b4385dc89c7f8ff9aadf122f33feb0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-q99nbqFtmyn/3mP53ORoG/hEQIh+zK0dR5nUr2eSor/SyxsNE5qHNuZHrbMXPYnv2MAZ/F+YyVOtGFqz3uY4rw==","_from":"file:sinclair-typebox-0.25.19.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.19_1673274550837_0.8368252918825929"},"_hasShrinkwrap":false},"0.25.20":{"_id":"@sinclair/typebox@0.25.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"6378757820642d6a56d9fdde33ab8abcd603df66","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7cPrp+XyulftbrBIH0MjUvrn0cFgLe/Tpqi8WPE+iigBiyKCItWKWfY743OI4nLcNbZkz9t0u8Tb3r2t5csE9Q==","_from":"file:sinclair-typebox-0.25.20.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.20_1673274859971_0.02779927896990797"},"_hasShrinkwrap":false},"0.25.21":{"_id":"@sinclair/typebox@0.25.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"763b05a4b472c93a8db29b2c3e359d55b29ce272","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gFukHN4t8K4+wVC+ECqeqwzBDeFeTzBXroBTqE6vcWrQGbEUpHO7LYdG0f4xnvYq4VOEwITSlHlp0JBAIFMS/g==","_from":"file:sinclair-typebox-0.25.21.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.21_1674109512899_0.18768693784600465"},"_hasShrinkwrap":false},"0.25.22":{"_id":"@sinclair/typebox@0.25.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.22","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"2808d895e9c2722b20a622a9c8cb332f6720eb4a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-6U6r2L7rnM7EG8G1tWzIjdB3QlsHF4slgcqXNN/SF0xJOAr0nDmT2GedlkyO3mrv8mDTJ24UuOMWR3diBrCvQQ==","_from":"file:sinclair-typebox-0.25.22.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.22_1676444428763_0.15672591255167512"},"_hasShrinkwrap":false},"0.25.23":{"_id":"@sinclair/typebox@0.25.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"1c15b0d2b872d89cc0f47c7243eacb447df8b8bd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VEB8ygeP42CFLWyAJhN5OklpxUliqdNEUcXb4xZ/CINqtYGTjL5ukluKdKzQ0iWdUxyQ7B0539PAUhHKrCNWSQ==","_from":"file:sinclair-typebox-0.25.23.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.23_1676544824274_0.4543425226292541"},"_hasShrinkwrap":false},"0.25.24":{"_id":"@sinclair/typebox@0.25.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"8c7688559979f7079aacaf31aa881c3aa410b718","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.24.tgz"},"types":"./typebox.d.ts"},"0.26.0-dev":{"_id":"@sinclair/typebox@0.26.0-dev","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"edfae6b019fa7efb799c1fe94de35b8debbe3feb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-CLrRa33JcUM2vBCKTWe8VGxhgeOoBMyeROc2zF8ofPfLQMDPxG5CK0whqC4I9AClELI2kyc4xJtgICjBvH7rNQ==","_from":"file:sinclair-typebox-0.26.0-dev.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev_1679069743308_0.3441310875842185"},"_hasShrinkwrap":false},"0.26.0-dev.1":{"_id":"@sinclair/typebox@0.26.0-dev.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"aa8ea8b0a359923f269171ddc60e577e2cbef0ef","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-hS1IAUsBrSwUcsSoYqo2JKJQDj6nsv7yPuxwWmthO/5j/Xh8jBqP//dfrokEkcfMU8f9F4DtxbDV+j5I6XuhZg==","_from":"file:sinclair-typebox-0.26.0-dev.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.1_1679121614153_0.23910352672296353"},"_hasShrinkwrap":false},"0.26.0-dev.2":{"_id":"@sinclair/typebox@0.26.0-dev.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"ad32ff42ace97962297dcbbbc9957c6dd09e1f1b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-r5ZFF4gkBEko5XYeE0Xx5u0cELYP0ysJrHOo1NPNcJ7k83Xh6QA2AJuQBwFnAvxH2mRYkpFbJBVSmjf23xqI5g==","_from":"file:sinclair-typebox-0.26.0-dev.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.2_1679132517965_0.737655923271626"},"_hasShrinkwrap":false},"0.26.0-dev.3":{"_id":"@sinclair/typebox@0.26.0-dev.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"cf5694e8ac3c0cb463110206da482d7cb1b7f79b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QfMYpAl5ES8xqmKJ3yGCWuBKluIeAXXqSJmbOwsTkwKsYBBYkAsVcPefzZLreyfvqsIcAOOToojFXkx2uTswyQ==","_from":"file:sinclair-typebox-0.26.0-dev.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.3_1679198545037_0.7240979723421632"},"_hasShrinkwrap":false},"0.26.0-dev.4":{"_id":"@sinclair/typebox@0.26.0-dev.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"31024cfdb89382647f2c38317871dbae3cca4c3c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ogxik7EzihqGDxkp8kBUU83Mq1OwymalXjof3bdxb5EN0HQHWqgoFiV3cfa2L2jWM+Kp7aYW0tsDcK4fWRYDXA==","_from":"file:sinclair-typebox-0.26.0-dev.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.4_1679221409627_0.2946865632078246"},"_hasShrinkwrap":false},"0.26.0-dev.5":{"_id":"@sinclair/typebox@0.26.0-dev.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ee5656823fb2eda6d495f5e43087ad31b8d28e50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-DshtQKfuHxawadWK6YgEhF9l3aag/rlSI29EL2AeOks0XvohwR/RzGIiseeP8B7Y4ez9SgygJLiCI9ySXGzQJw==","_from":"file:sinclair-typebox-0.26.0-dev.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.5_1679301222356_0.08870351623844708"},"_hasShrinkwrap":false},"0.26.0":{"_id":"@sinclair/typebox@0.26.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"49b2b2f52147e4145486c778a727dcdcd65d4682","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tpJrwq/npjYCZ5x//33zRKlgOg8lsBKuQ7MhmItrde/URJshRwDJsJzPwGSUqVetRCDDmcUP5P3Ux1XtAU7l1g==","_from":"file:sinclair-typebox-0.26.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0_1679414849072_0.5486670804900116"},"_hasShrinkwrap":false},"0.26.1":{"_id":"@sinclair/typebox@0.26.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"34c9a6c5356d5a54b6e9c74bb1b7229073d875a8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-6tJPRp4iDOLXvjuiB5O96Dgseex4B7at91koonQ000Fk+MC4Ix7B56ULS9cBJgakWb5P8QsytLigkAve17g86Q==","_from":"file:sinclair-typebox-0.26.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.1_1679511990564_0.40399211925751666"},"_hasShrinkwrap":false},"0.26.2":{"_id":"@sinclair/typebox@0.26.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"4f60dc028629c3d91bdcca769053a7d00d3fcbea","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ltt0X5VwgBdDfgJ9j37jNMQ/QIsarKZqLUhcW7SpREcdGZZ8RupBhchWkJiJzhnwwnxq+nIhAi1EJzygwbEIFg==","_from":"file:sinclair-typebox-0.26.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.2_1679559412147_0.6873424568984425"},"_hasShrinkwrap":false},"0.26.3":{"_id":"@sinclair/typebox@0.26.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"4f2d33038f9d7fa9514c1c00903fe641cdb59472","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7ePab2ecv+Qsn2N9cKY31gQpXBd+jtQvT2lmknEbi4k0n5nwQQ43AOnhdy/TkECIO//fM+OdefPDc1eexeEN0A==","_from":"file:sinclair-typebox-0.26.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.3_1679633809270_0.03535487432492879"},"_hasShrinkwrap":false},"0.26.4":{"_id":"@sinclair/typebox@0.26.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ea23bee1f9121cd404134bbf891372e93ca61c28","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZJgx9iRQ6ngcRevS/JrYfBYD1ZKT21c4MAvAUIQgzcHRuD2HJ3WwrSKxmVhfE/MbrGLsMBQ6Wpc3tMPVXOBYuA==","_from":"file:sinclair-typebox-0.26.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.4_1679818703438_0.5080452710070835"},"_hasShrinkwrap":false},"0.26.5":{"_id":"@sinclair/typebox@0.26.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"565335597bf1876197848b27335b518a043aab43","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bCAUB2mTRhSCbDKjtlsqfmIAahNLdW7T854jnbruGHsH8p7CZKJQgU84x9b59HQ6NKvI9GUCimxBJSrp5f7fbA==","_from":"file:sinclair-typebox-0.26.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.5_1679887824369_0.5914031809042886"},"_hasShrinkwrap":false},"0.26.6":{"_id":"@sinclair/typebox@0.26.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"d66a26ce4e09af10a4a6a85a26dceafc956b6162","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7BT4sRfeCV5j/CK/+cXu05B2IxrNBhD1rR3HJ8XG3/oqZfJIA60GnNKo+N4VHA47JTg8zlXuYTLYMVxI3pwMEQ==","_from":"file:sinclair-typebox-0.26.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.6_1680015114894_0.9936326930420853"},"_hasShrinkwrap":false},"0.26.7":{"_id":"@sinclair/typebox@0.26.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"34faf7d8beffefb5ed9c2d6de3900db6709cd6a8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-lDClq3usrxGZ30W/ILuIJyPNM27lhLDpMEKnKp7QklMtU3tmEfs5v8Qdlcw2JHmhlzsH5tKGCAkd28xp2jOOxQ==","_from":"file:sinclair-typebox-0.26.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.7_1680063626254_0.3986138887108903"},"_hasShrinkwrap":false},"0.26.8":{"_id":"@sinclair/typebox@0.26.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.8","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"daea92a69f2903b1f1d9582b9539553f144aba6b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-fvAkOrUWndf5vjptkW+4TeTH84/bILWQHgk7rbbzT8trZxW+b84lr8dZQPM/r7cGNRFxDaJYsMjHCikEYyAHaw==","_from":"file:sinclair-typebox-0.26.8.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.8_1680113568871_0.48686976653214553"},"_hasShrinkwrap":false},"0.27.0":{"_id":"@sinclair/typebox@0.27.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"e8fe35461a1ee1a2fd78ac56b8c40f4a18195299","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-nqCvfid613HckrkVcHw/OJv7Lbkd9PTQV3U/unOsUjdsoHhx9l7sEBNzdTfXxanreHOKV4tbmokLOGMXOQm4yw==","_from":"file:sinclair-typebox-0.27.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.0_1680970391716_0.16761637968069132"},"_hasShrinkwrap":false},"0.27.1":{"_id":"@sinclair/typebox@0.27.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"99ace29708c8da1cdc323b1e685a36abafc5b987","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+BzPidY3shay9ue8Qa2v6Z5HO4HWP0+irwMQcs6PEDWf//Iu7U7+b+W3+aXdovFFl/Sh3yyKKXlJhQ0h3zIMBg==","_from":"file:sinclair-typebox-0.27.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.1_1681126425938_0.8257015919976811"},"_hasShrinkwrap":false},"0.27.2":{"_id":"@sinclair/typebox@0.27.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"d178f8b8845dc6da2d947706549d69fa7a9bf179","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-nm4jY2hG2w51Qug+qSw8aSLatstdDy2JA3f6vpJRQttnXcZZ6k+EBzQWPdvW3+tBbw7NPoQ9N287F6PTzGVzMg==","_from":"file:sinclair-typebox-0.27.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.2_1681162887482_0.828106181670214"},"_hasShrinkwrap":false},"0.27.3":{"_id":"@sinclair/typebox@0.27.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"af668779cbead6b1f9e5df7ff8918fba3cbc840f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-mzSyMA75B1kVzw6P/mo9J9cBCOqtA0GvbIOhlSonRtDSR4jQyla1opsgNnHKzXuCqhVef/Nv+F+z2ueNrIVLVQ==","_from":"file:sinclair-typebox-0.27.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.3_1681191839786_0.2745561800150049"},"_hasShrinkwrap":false},"0.27.4":{"_id":"@sinclair/typebox@0.27.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ab9e302179f67254b21b330ca55bfbd755cc61de","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PwDIJ41Wl/Rn8DbBC4tIEG8nONKyKfbf5P32frIvm6VrJqjukjqOs4VR+iR3khQVC91k9SopeRo4B+SrfNW2YA==","_from":"file:sinclair-typebox-0.27.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.4_1681304030918_0.20240948080889365"},"_hasShrinkwrap":false},"0.27.5":{"_id":"@sinclair/typebox@0.27.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"fb31a0068036def8466a3b6e5a6c999b6139b945","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-SwsnzCF2nqxuoXx+hhDWGFA37/x6V94SCcYUfYIqUunhvQka4ii0uCW7/dmtE6MQs3dk42TISf6gRUooiR5FBA==","_from":"file:sinclair-typebox-0.27.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.5_1681437503155_0.2711753051399677"},"_hasShrinkwrap":false},"0.27.6":{"_id":"@sinclair/typebox@0.27.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"21bc37a16b4032f1643545141c267a85fc65c71f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Mp7BRgoCKdukKBxCaSWf7kGMd0lA4yaz7fQTYTe4pTEwBBcXNih7/xynWApgOsFGMQe5fwJR7Av952E1BVQOtw==","_from":"file:sinclair-typebox-0.27.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.6_1681445590188_0.31040865002974183"},"_hasShrinkwrap":false},"0.27.7":{"_id":"@sinclair/typebox@0.27.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"85bc2d03d4a404a6fba98f56661a2f7cdbcd78ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-sNK1gp9TPArdNMR5QWyNKhGYez2G/NXi6zXlOON9i88fLfGLiubYfkGVPpswPTqnJ4Y9PSnQfKWdwnE01qsaTg==","_from":"file:sinclair-typebox-0.27.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.7_1681459830240_0.642138542463379"},"_hasShrinkwrap":false},"0.27.8":{"_id":"@sinclair/typebox@0.27.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"6667fac16c436b5434a387a34dedb013198f6e6e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.8.tgz"},"types":"./typebox.d.ts"},"0.28.0":{"_id":"@sinclair/typebox@0.28.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"9b24037202c25fc11f148cf3e1d105923dcadc74","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-9Nk7ny/CiaManM7DZ+NAFqBpnNKEPjAzn+Fqb/xID2uaIYTlqsWrm6ph8x4wxhfQFdpDFF3qvToC6GD5xyCwsA==","_from":"file:sinclair-typebox-0.28.0.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.0_1682027280870_0.6438497127374865"},"_hasShrinkwrap":false},"0.28.1":{"_id":"@sinclair/typebox@0.28.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"51d72db9d0d42da23c2bbd4434eee33f3d601e84","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Qmrojy+++InUpF782bGcDYP5VFXiZzEN5EduD33TuESjTSLTljCdeeGWlIh42E37LMlYJB3jCpbABZV7lnVX1w==","_from":"file:sinclair-typebox-0.28.1.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.1_1682032904696_0.7706299931177147"},"_hasShrinkwrap":false},"0.28.2":{"_id":"@sinclair/typebox@0.28.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"7d310ab33eb73729fed751469fc90147209b9d45","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3CdUgXqd6ud7tKvEvo5h2c1lx87DsR9pwZeDJ1AVdG9fFK87uTXBR7/b5BeHowjkFgrPmvaYyc+xo407laUceA==","_from":"file:sinclair-typebox-0.28.2.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.2_1682081125860_0.0926610422734575"},"_hasShrinkwrap":false},"0.28.3":{"_id":"@sinclair/typebox@0.28.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"e1261c202721b5b2b1178381e1d07b3214b3bf00","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aF0PAXDI5+jidu9WuhJumF6JEaQfIbM2bR0UbGc/UhHrHm7LQ76UenXGgvIcQNDYjghjoPssTxdx9ElNUaGG9g==","_from":"file:sinclair-typebox-0.28.3.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.3_1682112626986_0.8397945073300612"},"_hasShrinkwrap":false},"0.28.4":{"_id":"@sinclair/typebox@0.28.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"753a48f9b88e0a9589c244fd8c5ae86a3556f145","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Yqxz+dK/AFu9p03Q7XmajxDsNDLEfaQFFdEE4krqi+1otLkEgOrQD5IrWiq26Mbie5R6bPR6BljarufOdlCqQA==","_from":"file:sinclair-typebox-0.28.4.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.4_1682121075325_0.1179759392987445"},"_hasShrinkwrap":false},"0.28.5":{"_id":"@sinclair/typebox@0.28.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"5bb0568c9bca97a1f031c3a30ac625976d22d235","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3BjziLrALI2q+KpSKMwQdHP0MwmBpiu3oH0LM3mr7Aob9xO2z1hbGxjorTH7l5msuevXH7TU7YLt3Qs7U6Iokg==","_from":"file:sinclair-typebox-0.28.5.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.5_1682225459473_0.04868811451395172"},"_hasShrinkwrap":false},"0.28.6":{"_id":"@sinclair/typebox@0.28.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.6","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"a762715e46313afc0038ab5495b41cac76f40e1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dIlAWjH0O0zK2w0YDhLX0vYy75sE0Ie+w9NL3hWCXbegQZMgTc7RVMeNLUem6PDwN1YvKo8oZIFXEsqTM7pVDw==","_from":"file:sinclair-typebox-0.28.6.tgz","_nodeVersion":"20.0.0","_npmVersion":"9.6.4","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.6_1682417842949_0.0631929121055268"},"_hasShrinkwrap":false},"0.28.7":{"_id":"@sinclair/typebox@0.28.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"6ae0cb14c98917340654847c2969d02f58b72156","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ubom8FLHLw0tKXpsbDrcljkGUJpD+FlcLdALsTx+cQNjv3NxW87JaAvqnmHKmLxvI7SQCmdxFcIPytW9Jal3Iw==","_from":"file:sinclair-typebox-0.28.7.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.7_1682577871859_0.20216079986839963"},"_hasShrinkwrap":false},"0.28.8":{"_id":"@sinclair/typebox@0.28.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"876fc57190cd3f169dbf054d66963ff4bf424fdd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-OerNjE43mIb2RDy/RJfjS+OHfJHq3caePlVe/GXkLwLzcYevA2JPzHWSFMkpGgfoFKWdQdckKRiMVMsz40yHgw==","_from":"file:sinclair-typebox-0.28.8.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.8_1682673580224_0.6107443338530492"},"_hasShrinkwrap":false},"0.28.9":{"_id":"@sinclair/typebox@0.28.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"594e4e752839868074be70a8cbb35f264de79d07","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-m98m37J9CBZ8XinStjpss2ZOW50KG45XB4cAva2NGoQHiGPxhfNL2BzUXYCs6ahXdK7/F1NIjOGh+MPP5dK8Rw==","_from":"file:sinclair-typebox-0.28.9.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.9_1682951412838_0.9389784001271382"},"_hasShrinkwrap":false},"0.28.10":{"_id":"@sinclair/typebox@0.28.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"dddd3243c3020166b52d46d2ced8073ed89759e8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZRpJZFpr2yq1vAenq2qspUKs34CBC97LOMghUuTTEveFONVExQAYEB8Tcjy9NlPj8oVlSysK15Hzkf7Ox6x3lA==","_from":"file:sinclair-typebox-0.28.10.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.10_1683993972980_0.8615084344613271"},"_hasShrinkwrap":false},"0.28.11":{"_id":"@sinclair/typebox@0.28.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"f094caefc315e1a9b4e649056f661ddb20fcea97","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8QPhkOowccAdXa/ra54pq+UVYvzbKjYMuojxCOTFq+yyEfcWZJSdlIVdivTRrIq7Mgjx1n4E37t8Js/RXwyvUg==","_from":"file:sinclair-typebox-0.28.11.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.11_1684294039059_0.8682479788384345"},"_hasShrinkwrap":false},"0.28.12":{"_id":"@sinclair/typebox@0.28.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"b84895fdc96ca8d32a2f241a6eaead268044ba35","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-v/jftJeCY+qsfAY3l75tmEJ+3MlCkWG3gO7tSFwg+g5/Sfh8rdA278DFIRezt5JX/T0LB+TNmHnSXnMo5ok3Xw==","_from":"file:sinclair-typebox-0.28.12.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.12_1684993930311_0.15879279548934067"},"_hasShrinkwrap":false},"0.28.13":{"_id":"@sinclair/typebox@0.28.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"83bc090f29e0d7c1fdc27000c3ebbb990391a52f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bSHHPYPB3UGMoa1n85cpzpMXksFabJA2ZUNojojg4gqfaSUgSmtAG+AbCAGJSylQYbk5slOxkQymqWXEv492aw==","_from":"file:sinclair-typebox-0.28.13.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.13_1685075725991_0.9860249042663369"},"_hasShrinkwrap":false},"0.28.14":{"_id":"@sinclair/typebox@0.28.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"31653c1ecb93af1eec673c771971620060dfde40","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aB3ddagwMFz2cSLg0/gUt7yaUHJUKnT+rEHGdb/srtEFILB0zdL7a2mcbA7kskOCFHicAOV1POeeZdwoevFgAQ==","_from":"file:sinclair-typebox-0.28.14.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.14_1685388202169_0.6524188764257999"},"_hasShrinkwrap":false},"0.28.15":{"_id":"@sinclair/typebox@0.28.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"44ef4cf4138740f0e17051cbf5217e0fed578256","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-IUHNXCbehBRC1yC1PVtzOHuDaqb30NnCquY3T8VFChu8Jy+wwl1l/XJ0VhC/EEUPi9MBQ8KTeWGT/KmbhztU4g==","_from":"file:sinclair-typebox-0.28.15.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.15_1686384602381_0.02191716081197881"},"_hasShrinkwrap":false},"0.28.16":{"_id":"@sinclair/typebox@0.28.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"4416f4a88c12eb9ab53f8473c0053f368a4cb328","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0MqOedIj2ZjvCtUwibzubKdVzIDihAdCAEtoMAEDzuRpdlRtw/MlXbkNZaM+cjU8h0ApR0uctmakKgSY9kQqLg==","_from":"file:sinclair-typebox-0.28.16.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.16_1687245353206_0.8000202031127268"},"_hasShrinkwrap":false},"0.28.17":{"_id":"@sinclair/typebox@0.28.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"b28f0d444f866500c4ce4674c3b9cb042a42a689","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/twakA+gA4KgkXMiMjWwmV57xmDrm1fp+OaIMz01R3+q7AOSPhnTPZPwxqOzPDslfelxwzZx0Ttp3YdyS1+F4Q==","_from":"file:sinclair-typebox-0.28.17.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.17_1687366646711_0.14255705302644794"},"_hasShrinkwrap":false},"0.28.18":{"_id":"@sinclair/typebox@0.28.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"4a13c7ea3393d00e581717a8a750128e631c0831","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-I19d36CXlLAsm+nrl7VKsYyirFLtdebT2nlfV3Knvo0tnk8B8UKyt3DEqNJexEb/2pKPtdXNLcr72aJtfl6whA==","_from":"file:sinclair-typebox-0.28.18.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.18_1687408941166_0.08137537353268143"},"_hasShrinkwrap":false},"0.28.19":{"_id":"@sinclair/typebox@0.28.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"bcc9b0fb26082ea8d052e59cacadf096b60fcf81","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J08onOXZeCXEwB/Kpri/1l3b8Fs1EzG301kDCEikf5+E0TH8SzY1Edfq8T4ebNzXFcs34gonv20LjMn4Bzthow==","_from":"file:sinclair-typebox-0.28.19.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.19_1687807678899_0.4743302968422367"},"_hasShrinkwrap":false},"0.28.20":{"_id":"@sinclair/typebox@0.28.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"978652a10ced0102aec86e8e088837ab7d0d5871","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QCF3BGfacwD+3CKhGsMeixnwOmX4AWgm61nKkNdRStyLVu0mpVFYlDSY8gVBOOED1oSwzbJauIWl/+REj8K5+w==","_from":"file:sinclair-typebox-0.28.20.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.20_1687854435283_0.02745105650222257"},"_hasShrinkwrap":false},"0.29.0":{"_id":"@sinclair/typebox@0.29.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"a19842180595a9a77d57407091707a2739feb508","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-htPaB6O/USun7JviXuzHnIchTbwgSdKijwt/ho8l9agmvbFcYnrSPOi2qNRzqNOBnHjXMUPoCXri4C6SwkOy3g==","_from":"file:sinclair-typebox-0.29.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.0_1688305512100_0.22106198380612407"},"_hasShrinkwrap":false},"0.29.1":{"_id":"@sinclair/typebox@0.29.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"28946ecc70e421f2e6b9c3eed55dc2b46a18c947","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ML/pdD3MnCijK8jzB+E/rTWtZ/2JAbwq196AzlsDBXPzLAjtCRHFAp5VvrWClmzJ8CVMBxOjeraoQX3s9XwXHA==","_from":"file:sinclair-typebox-0.29.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.1_1688324358677_0.28638665236245653"},"_hasShrinkwrap":false},"0.29.2":{"_id":"@sinclair/typebox@0.29.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"f7316d26a3bcb8c6088a2885f9f39690bc970410","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dbQjPyqrfo7vC10e/iEfrGnuT0z8WJyCSXmAX7fpnPg3UjduU8mZmQp9HW5u4nfG7Jf5rFWPK51VudVJ5B4e3A==","_from":"file:sinclair-typebox-0.29.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.2_1688419876446_0.8912109746052437"},"_hasShrinkwrap":false},"0.29.3":{"_id":"@sinclair/typebox@0.29.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"26a8f5ee265ce487166568c3796723e1a9958f50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-j793DNq5m+GdEp7s8O4CUyumrjEwu9Kj8vsokAdeK/3aHQ35eFYOJn5WWIFexVOCWjLTZhWir04vsBLCaZM2xw==","_from":"file:sinclair-typebox-0.29.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.3_1688423547706_0.6284180650580198"},"_hasShrinkwrap":false},"0.29.4":{"_id":"@sinclair/typebox@0.29.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"88bcfbd6252ae935dec45022e2c98d6fd9d0c643","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XSEM1jjL9CPI4pZ0RZs84Oq+jcONXFHljufxrp70rTYTbslDuYDj1wnDCzDb3XC9Tf5C36sGO1Fu7VFXXDTgFw==","_from":"file:sinclair-typebox-0.29.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.4_1688610729420_0.08153613499443546"},"_hasShrinkwrap":false},"0.29.5":{"_id":"@sinclair/typebox@0.29.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"95d666b799a2f52a3374a635379ce37bfe0ec240","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-hmwtss82axitE4y/koJvkvZ4e3xfWH+CcxlCEGZYrXC9p3YBkbtG98bs1WHQi+cpfr/Q6cXj8Mk3Fsq6tHK1JA==","_from":"file:sinclair-typebox-0.29.5.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.5_1689700183703_0.17997743680384137"},"_hasShrinkwrap":false},"0.29.6":{"_id":"@sinclair/typebox@0.29.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"4cd8372f9247372edd5fc5af44f67e2032c46e2f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aX5IFYWlMa7tQ8xZr3b2gtVReCvg7f3LEhjir/JAjX2bJCMVJA5tIPv30wTD4KDfcwMd7DDYY3hFDeGmOgtrZQ==","_from":"file:sinclair-typebox-0.29.6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.6_1689701212880_0.982377218694056"},"_hasShrinkwrap":false},"0.30.0-dev-1":{"_id":"@sinclair/typebox@0.30.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"2d8e2f378df5cd3a343cd812fe9d85dbe92ecf23","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-1.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that can be composed into more complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 6 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                                type: 'number'            \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                   type: 'string'            \r\n ])                                                             }, {                         \r\n                                                                   type: 'number'            \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Pattern('^xy$')  type T = string              const T = {                    \r\n                                                                 type: 'string',             \r\n                                                                 pattern: '^xy$'             \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [...A, ...B]          items: [                     \r\n ])                                                               { const: 0 },              \r\n const B = Type.Tuple([                                           { const: 1 },              \r\n|   Type.Literal(2),                                               { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions constrained to type `TSchema`. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nThe following creates a generic `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Type.Ref`. The target type must specify a valid `$id`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //    $id: 'T',\r\n                                                     //    type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref(T)                                // const R = {\r\n                                                     //    $ref: 'T'\r\n                                                     // }\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Type.Recursive`.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Type.Extends`. This type will perform a structural assignment check for the first two parameters and return a `true` or `false` type from the second two parameters. The types `Type.Exclude` and `Type.Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1>\r\n  Type.Union([\r\n    Type.Literal(1), \r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]>\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `Type.TemplateLiteral`. This type implements an embedded DSL syntax to match the TypeScript template literal syntax. This type can also be composed by passing an array of union and literal types as parameters. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype P = `/post/${string}/user/${number}`            // type P = `/post/${string}/user/${number}`\r\n\r\ntype T = `option${'A'|'B'}`                          // type T = 'optionA' | 'optionB'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst P = Type.TemplateLiteral('/post/${string}/user/${number}')\r\n\r\n                                                     // const P = {\r\n                                                     //   type: 'string',\r\n                                                     //   pattern: '^/post/(.*)/user/(0|[1-9][0-9]*)$'\r\n                                                     // }\r\n\r\nconst T = Type.TemplateLiteral('option${A|B}')       // const T = {\r\n                                                     //   pattern: '^option(A|B)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Type.Index`. This type provides a consistent way to access interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Type.Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nThis type can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the values `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\n\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Type.Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well as for variadic functions.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nUse `Type.Unsafe` to create custom schematics with user defined inference rules.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThe `Type.Unsafe` type can be useful to express specific OpenAPI schema representations.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a `TypeGuard` module that can be used for reflection and asserting values as types.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = Type.String()\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 6 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    232 ms'  '      8 ms'  '   29.00 x' \r\n Literal_Number                 1000     '    179 ms'  '      6 ms'  '   29.83 x' \r\n Literal_Boolean                1000     '    154 ms'  '      3 ms'  '   51.33 x' \r\n Primitive_Number               1000     '    160 ms'  '      7 ms'  '   22.86 x' \r\n Primitive_String               1000     '    149 ms'  '      6 ms'  '   24.83 x' \r\n Primitive_String_Pattern       1000     '    191 ms'  '      9 ms'  '   21.22 x' \r\n Primitive_Boolean              1000     '    135 ms'  '      4 ms'  '   33.75 x' \r\n Primitive_Null                 1000     '    144 ms'  '      6 ms'  '   24.00 x' \r\n Object_Unconstrained           1000     '   1144 ms'  '     30 ms'  '   38.13 x' \r\n Object_Constrained             1000     '   1228 ms'  '     24 ms'  '   51.17 x' \r\n Object_Vector3                 1000     '    380 ms'  '      9 ms'  '   42.22 x' \r\n Object_Box3D                   1000     '   1771 ms'  '     30 ms'  '   59.03 x' \r\n Tuple_Primitive                1000     '    471 ms'  '     11 ms'  '   42.82 x' \r\n Tuple_Object                   1000     '   1272 ms'  '     15 ms'  '   84.80 x' \r\n Composite_Intersect            1000     '    606 ms'  '     17 ms'  '   35.65 x' \r\n Composite_Union                1000     '    560 ms'  '     22 ms'  '   25.45 x' \r\n Math_Vector4                   1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Math_Matrix4                   1000     '    419 ms'  '      9 ms'  '   46.56 x' \r\n Array_Primitive_Number         1000     '    382 ms'  '      6 ms'  '   63.67 x' \r\n Array_Primitive_String         1000     '    324 ms'  '      6 ms'  '   54.00 x' \r\n Array_Primitive_Boolean        1000     '    301 ms'  '      4 ms'  '   75.25 x' \r\n Array_Object_Unconstrained     1000     '   1734 ms'  '     21 ms'  '   82.57 x' \r\n Array_Object_Constrained       1000     '   1509 ms'  '     20 ms'  '   75.45 x' \r\n Array_Tuple_Primitive          1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Array_Tuple_Object             1000     '   1619 ms'  '     16 ms'  '  101.19 x' \r\n Array_Composite_Intersect      1000     '    773 ms'  '     16 ms'  '   48.31 x' \r\n Array_Composite_Union          1000     '    822 ms'  '     17 ms'  '   48.35 x' \r\n Array_Math_Vector4             1000     '   1131 ms'  '     13 ms'  '   87.00 x' \r\n Array_Math_Matrix4             1000     '    661 ms'  '     10 ms'  '   66.10 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     13 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_Number             1000000    '     21 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_String             1000000    '     19 ms'  '     16 ms'  '     10 ms'  '    1.60 x' \r\n Primitive_String_Pattern     1000000    '    150 ms'  '     41 ms'  '     35 ms'  '    1.17 x' \r\n Primitive_Boolean            1000000    '     17 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     18 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Object_Unconstrained         1000000    '   1001 ms'  '     31 ms'  '     24 ms'  '    1.29 x' \r\n Object_Constrained           1000000    '   1288 ms'  '     50 ms'  '     36 ms'  '    1.39 x' \r\n Object_Vector3               1000000    '    439 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2109 ms'  '     52 ms'  '     45 ms'  '    1.16 x' \r\n Object_Recursive             1000000    '   5337 ms'  '    356 ms'  '    162 ms'  '    2.20 x' \r\n Tuple_Primitive              1000000    '    164 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    744 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    764 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Composite_Union              1000000    '    516 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    262 ms'  '     20 ms'  '     11 ms'  '    1.82 x' \r\n Math_Matrix4                 1000000    '   1089 ms'  '     37 ms'  '     27 ms'  '    1.37 x' \r\n Array_Primitive_Number       1000000    '    276 ms'  '     21 ms'  '     11 ms'  '    1.91 x' \r\n Array_Primitive_String       1000000    '    228 ms'  '     21 ms'  '     14 ms'  '    1.50 x' \r\n Array_Primitive_Boolean      1000000    '    159 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5695 ms'  '     77 ms'  '     69 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5701 ms'  '    127 ms'  '    110 ms'  '    1.15 x' \r\n Array_Object_Recursive       1000000    '  21267 ms'  '   1664 ms'  '    573 ms'  '    2.90 x' \r\n Array_Tuple_Primitive        1000000    '    702 ms'  '     40 ms'  '     32 ms'  '    1.25 x' \r\n Array_Tuple_Object           1000000    '   3141 ms'  '     68 ms'  '     51 ms'  '    1.33 x' \r\n Array_Composite_Intersect    1000000    '   3145 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2134 ms'  '     68 ms'  '     31 ms'  '    2.19 x' \r\n Array_Math_Vector4           1000000    '   1197 ms'  '     37 ms'  '     25 ms'  '    1.48 x' \r\n Array_Math_Matrix4           1000000    '   5323 ms'  '    111 ms'  '     96 ms'  '    1.16 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '128.2 kb'  ' 58.2 kb'   '2.20 x'   \r\n typebox/errors        '110.4 kb'  ' 49.5 kb'   '2.23 x'   \r\n typebox/system        ' 75.2 kb'  ' 31.1 kb'   '2.42 x'   \r\n typebox/value         '179.6 kb'  ' 78.7 kb'   '2.28 x'   \r\n typebox               ' 74.1 kb'  ' 30.6 kb'   '2.42 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-K6gloE8tUV3W73mbN+/N0lsUeTTs93ed8w9Lc9OUSazu+sRzI/tiXXw2m2pL2dLg7+iq5XdJzItwtFxZV6kvag==","_from":"file:sinclair-typebox-0.30.0-dev-1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-1_1690560461697_0.5176429348681768"},"_hasShrinkwrap":false},"0.30.0-dev-2":{"_id":"@sinclair/typebox@0.30.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"77d02fbb224e29c5f922c6190a3aa722c4062400","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-2.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that can be composed into more complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 6 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                                type: 'number'            \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                   type: 'string'            \r\n ])                                                             }, {                         \r\n                                                                   type: 'number'            \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Pattern('^xy$')  type T = string              const T = {                    \r\n                                                                 type: 'string',             \r\n                                                                 pattern: '^xy$'             \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [...A, ...B]          items: [                     \r\n ])                                                               { const: 0 },              \r\n const B = Type.Tuple([                                           { const: 1 },              \r\n|   Type.Literal(2),                                               { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions constrained to type `TSchema`. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nThe following creates a generic `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Type.Ref`. The target type must specify a valid `$id`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //    $id: 'T',\r\n                                                     //    type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref(T)                                // const R = {\r\n                                                     //    $ref: 'T'\r\n                                                     // }\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Type.Recursive`.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Type.Extends`. This type will perform a structural assignment check for the first two parameters and return a `true` or `false` type from the second two parameters. The types `Type.Exclude` and `Type.Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1>\r\n  Type.Union([\r\n    Type.Literal(1), \r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]>\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `Type.TemplateLiteral`. This type implements an embedded DSL syntax to match the TypeScript template literal syntax. This type can also be composed by passing an array of union and literal types as parameters. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype P = `/post/${string}/user/${number}`            // type P = `/post/${string}/user/${number}`\r\n\r\ntype T = `option${'A'|'B'}`                          // type T = 'optionA' | 'optionB'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst P = Type.TemplateLiteral('/post/${string}/user/${number}')\r\n\r\n                                                     // const P = {\r\n                                                     //   type: 'string',\r\n                                                     //   pattern: '^/post/(.*)/user/(0|[1-9][0-9]*)$'\r\n                                                     // }\r\n\r\nconst T = Type.TemplateLiteral('option${A|B}')       // const T = {\r\n                                                     //   pattern: '^option(A|B)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Type.Index`. This type provides a consistent way to access interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Type.Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nThis type can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the values `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\n\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Type.Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well as for variadic functions.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nUse `Type.Unsafe` to create custom schematics with user defined inference rules.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThe `Type.Unsafe` type can be useful to express specific OpenAPI schema representations.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a `TypeGuard` module that can be used for reflection and asserting values as types.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = Type.String()\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 6 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    232 ms'  '      8 ms'  '   29.00 x' \r\n Literal_Number                 1000     '    179 ms'  '      6 ms'  '   29.83 x' \r\n Literal_Boolean                1000     '    154 ms'  '      3 ms'  '   51.33 x' \r\n Primitive_Number               1000     '    160 ms'  '      7 ms'  '   22.86 x' \r\n Primitive_String               1000     '    149 ms'  '      6 ms'  '   24.83 x' \r\n Primitive_String_Pattern       1000     '    191 ms'  '      9 ms'  '   21.22 x' \r\n Primitive_Boolean              1000     '    135 ms'  '      4 ms'  '   33.75 x' \r\n Primitive_Null                 1000     '    144 ms'  '      6 ms'  '   24.00 x' \r\n Object_Unconstrained           1000     '   1144 ms'  '     30 ms'  '   38.13 x' \r\n Object_Constrained             1000     '   1228 ms'  '     24 ms'  '   51.17 x' \r\n Object_Vector3                 1000     '    380 ms'  '      9 ms'  '   42.22 x' \r\n Object_Box3D                   1000     '   1771 ms'  '     30 ms'  '   59.03 x' \r\n Tuple_Primitive                1000     '    471 ms'  '     11 ms'  '   42.82 x' \r\n Tuple_Object                   1000     '   1272 ms'  '     15 ms'  '   84.80 x' \r\n Composite_Intersect            1000     '    606 ms'  '     17 ms'  '   35.65 x' \r\n Composite_Union                1000     '    560 ms'  '     22 ms'  '   25.45 x' \r\n Math_Vector4                   1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Math_Matrix4                   1000     '    419 ms'  '      9 ms'  '   46.56 x' \r\n Array_Primitive_Number         1000     '    382 ms'  '      6 ms'  '   63.67 x' \r\n Array_Primitive_String         1000     '    324 ms'  '      6 ms'  '   54.00 x' \r\n Array_Primitive_Boolean        1000     '    301 ms'  '      4 ms'  '   75.25 x' \r\n Array_Object_Unconstrained     1000     '   1734 ms'  '     21 ms'  '   82.57 x' \r\n Array_Object_Constrained       1000     '   1509 ms'  '     20 ms'  '   75.45 x' \r\n Array_Tuple_Primitive          1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Array_Tuple_Object             1000     '   1619 ms'  '     16 ms'  '  101.19 x' \r\n Array_Composite_Intersect      1000     '    773 ms'  '     16 ms'  '   48.31 x' \r\n Array_Composite_Union          1000     '    822 ms'  '     17 ms'  '   48.35 x' \r\n Array_Math_Vector4             1000     '   1131 ms'  '     13 ms'  '   87.00 x' \r\n Array_Math_Matrix4             1000     '    661 ms'  '     10 ms'  '   66.10 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     13 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_Number             1000000    '     21 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_String             1000000    '     19 ms'  '     16 ms'  '     10 ms'  '    1.60 x' \r\n Primitive_String_Pattern     1000000    '    150 ms'  '     41 ms'  '     35 ms'  '    1.17 x' \r\n Primitive_Boolean            1000000    '     17 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     18 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Object_Unconstrained         1000000    '   1001 ms'  '     31 ms'  '     24 ms'  '    1.29 x' \r\n Object_Constrained           1000000    '   1288 ms'  '     50 ms'  '     36 ms'  '    1.39 x' \r\n Object_Vector3               1000000    '    439 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2109 ms'  '     52 ms'  '     45 ms'  '    1.16 x' \r\n Object_Recursive             1000000    '   5337 ms'  '    356 ms'  '    162 ms'  '    2.20 x' \r\n Tuple_Primitive              1000000    '    164 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    744 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    764 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Composite_Union              1000000    '    516 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    262 ms'  '     20 ms'  '     11 ms'  '    1.82 x' \r\n Math_Matrix4                 1000000    '   1089 ms'  '     37 ms'  '     27 ms'  '    1.37 x' \r\n Array_Primitive_Number       1000000    '    276 ms'  '     21 ms'  '     11 ms'  '    1.91 x' \r\n Array_Primitive_String       1000000    '    228 ms'  '     21 ms'  '     14 ms'  '    1.50 x' \r\n Array_Primitive_Boolean      1000000    '    159 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5695 ms'  '     77 ms'  '     69 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5701 ms'  '    127 ms'  '    110 ms'  '    1.15 x' \r\n Array_Object_Recursive       1000000    '  21267 ms'  '   1664 ms'  '    573 ms'  '    2.90 x' \r\n Array_Tuple_Primitive        1000000    '    702 ms'  '     40 ms'  '     32 ms'  '    1.25 x' \r\n Array_Tuple_Object           1000000    '   3141 ms'  '     68 ms'  '     51 ms'  '    1.33 x' \r\n Array_Composite_Intersect    1000000    '   3145 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2134 ms'  '     68 ms'  '     31 ms'  '    2.19 x' \r\n Array_Math_Vector4           1000000    '   1197 ms'  '     37 ms'  '     25 ms'  '    1.48 x' \r\n Array_Math_Matrix4           1000000    '   5323 ms'  '    111 ms'  '     96 ms'  '    1.16 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '128.2 kb'  ' 58.2 kb'   '2.20 x'   \r\n typebox/errors        '110.4 kb'  ' 49.5 kb'   '2.23 x'   \r\n typebox/system        ' 75.2 kb'  ' 31.1 kb'   '2.42 x'   \r\n typebox/value         '179.6 kb'  ' 78.7 kb'   '2.28 x'   \r\n typebox               ' 74.1 kb'  ' 30.6 kb'   '2.42 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-155Dim6Deo1ntkUP5xZfFBYMiwhD+2ERJ/mjBicP43qUiDmNp/T2yebLG7ViFyWHfKqCfLSAb5VvrTjmc6V9JA==","_from":"file:sinclair-typebox-0.30.0-dev-2.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-2_1690562544587_0.1543345304983419"},"_hasShrinkwrap":false},"0.30.0-dev-3":{"_id":"@sinclair/typebox@0.30.0-dev-3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-3","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"8aa4d7fa62b6e35280195a5c4ca968c421acce6f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-3.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that compose into complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                                type: 'number'            \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                   type: 'string'            \r\n ])                                                             }, {                         \r\n                                                                   type: 'number'            \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Pattern('^xy$')  type T = string              const T = {                    \r\n                                                                 type: 'string',             \r\n                                                                 pattern: '^xy$'             \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [...A, ...B]          items: [                     \r\n ])                                                               { const: 0 },              \r\n const B = Type.Tuple([                                           { const: 1 },              \r\n|   Type.Literal(2),                                               { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types are created with generic functions. All TypeBox types extend the sub type `TSchema` so it is common to constrain function arguments to this type. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types can be used to create aliases for more complex types. The following creates a `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Ref`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //   $id: 'T',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref<typeof T>('T')                    // const R = {\r\n                                                     //   $ref: 'T'\r\n                                                     // }\r\n\r\ntype R = Static<typeof R>                            // type R = string\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Recursive`. Recursive type inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Extends`. This type performs a structural assignment check against the first two parameters and returns either the `true` or `false` type as given from the second two parameters. The conditional types `Exclude` and `Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false> = {\r\n  Type.String(),                                     //   type: 'boolean',\r\n  Type.Number(),                                     //   const: false\r\n  Type.Literal(true),                                // }\r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1> = {\r\n  Type.Union([                                       //   type: 'number',\r\n    Type.Literal(1),                                 //   const: 1\r\n    Type.Literal(2),                                 // }\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]> = {\r\n    Type.Literal(3)                                 //   anyOf: [{\r\n  ]),                                               //     type: 'number',\r\n  Type.Literal(1)                                   //     const: 2\r\n)                                                   //   }, {\r\n                                                    //     type: 'number',\r\n                                                    //     const: 3\r\n                                                    //   }]\r\n                                                    // }\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `TemplateLiteral`. This type provides an embedded DSL syntax that is similar to the TypeScript template literal syntax. These type can also be composed by passing a tuple of exterior union and literal types. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = `option${'A'|'B'|'C'}`                      // type T = 'optionA' | 'optionB' | 'optionC'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     //   optionC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst T = Type.TemplateLiteral('option${A|B|C}')     // const T = {\r\n                                                     //   pattern: '^option(A|B|C)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //     optionC: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Index`. This type provides a consistent way of accessing interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nType negation can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the numbers `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well function parameter assignment.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports the creation of user defined schematics with user defined inference rules using the Unsafe type.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThis type can be useful to create various extended schematics, such as those used by OpenAPI.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a TypeGuard module to assert JavaScript values are valid TypeBox types.\r\n\r\n```typescript\r\nimport { Type, Kind, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. It's return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 7 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    232 ms'  '      8 ms'  '   29.00 x' \r\n Literal_Number                 1000     '    179 ms'  '      6 ms'  '   29.83 x' \r\n Literal_Boolean                1000     '    154 ms'  '      3 ms'  '   51.33 x' \r\n Primitive_Number               1000     '    160 ms'  '      7 ms'  '   22.86 x' \r\n Primitive_String               1000     '    149 ms'  '      6 ms'  '   24.83 x' \r\n Primitive_String_Pattern       1000     '    191 ms'  '      9 ms'  '   21.22 x' \r\n Primitive_Boolean              1000     '    135 ms'  '      4 ms'  '   33.75 x' \r\n Primitive_Null                 1000     '    144 ms'  '      6 ms'  '   24.00 x' \r\n Object_Unconstrained           1000     '   1144 ms'  '     30 ms'  '   38.13 x' \r\n Object_Constrained             1000     '   1228 ms'  '     24 ms'  '   51.17 x' \r\n Object_Vector3                 1000     '    380 ms'  '      9 ms'  '   42.22 x' \r\n Object_Box3D                   1000     '   1771 ms'  '     30 ms'  '   59.03 x' \r\n Tuple_Primitive                1000     '    471 ms'  '     11 ms'  '   42.82 x' \r\n Tuple_Object                   1000     '   1272 ms'  '     15 ms'  '   84.80 x' \r\n Composite_Intersect            1000     '    606 ms'  '     17 ms'  '   35.65 x' \r\n Composite_Union                1000     '    560 ms'  '     22 ms'  '   25.45 x' \r\n Math_Vector4                   1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Math_Matrix4                   1000     '    419 ms'  '      9 ms'  '   46.56 x' \r\n Array_Primitive_Number         1000     '    382 ms'  '      6 ms'  '   63.67 x' \r\n Array_Primitive_String         1000     '    324 ms'  '      6 ms'  '   54.00 x' \r\n Array_Primitive_Boolean        1000     '    301 ms'  '      4 ms'  '   75.25 x' \r\n Array_Object_Unconstrained     1000     '   1734 ms'  '     21 ms'  '   82.57 x' \r\n Array_Object_Constrained       1000     '   1509 ms'  '     20 ms'  '   75.45 x' \r\n Array_Tuple_Primitive          1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Array_Tuple_Object             1000     '   1619 ms'  '     16 ms'  '  101.19 x' \r\n Array_Composite_Intersect      1000     '    773 ms'  '     16 ms'  '   48.31 x' \r\n Array_Composite_Union          1000     '    822 ms'  '     17 ms'  '   48.35 x' \r\n Array_Math_Vector4             1000     '   1131 ms'  '     13 ms'  '   87.00 x' \r\n Array_Math_Matrix4             1000     '    661 ms'  '     10 ms'  '   66.10 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     13 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_Number             1000000    '     21 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_String             1000000    '     19 ms'  '     16 ms'  '     10 ms'  '    1.60 x' \r\n Primitive_String_Pattern     1000000    '    150 ms'  '     41 ms'  '     35 ms'  '    1.17 x' \r\n Primitive_Boolean            1000000    '     17 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     18 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Object_Unconstrained         1000000    '   1001 ms'  '     31 ms'  '     24 ms'  '    1.29 x' \r\n Object_Constrained           1000000    '   1288 ms'  '     50 ms'  '     36 ms'  '    1.39 x' \r\n Object_Vector3               1000000    '    439 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2109 ms'  '     52 ms'  '     45 ms'  '    1.16 x' \r\n Object_Recursive             1000000    '   5337 ms'  '    356 ms'  '    162 ms'  '    2.20 x' \r\n Tuple_Primitive              1000000    '    164 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    744 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    764 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Composite_Union              1000000    '    516 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    262 ms'  '     20 ms'  '     11 ms'  '    1.82 x' \r\n Math_Matrix4                 1000000    '   1089 ms'  '     37 ms'  '     27 ms'  '    1.37 x' \r\n Array_Primitive_Number       1000000    '    276 ms'  '     21 ms'  '     11 ms'  '    1.91 x' \r\n Array_Primitive_String       1000000    '    228 ms'  '     21 ms'  '     14 ms'  '    1.50 x' \r\n Array_Primitive_Boolean      1000000    '    159 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5695 ms'  '     77 ms'  '     69 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5701 ms'  '    127 ms'  '    110 ms'  '    1.15 x' \r\n Array_Object_Recursive       1000000    '  21267 ms'  '   1664 ms'  '    573 ms'  '    2.90 x' \r\n Array_Tuple_Primitive        1000000    '    702 ms'  '     40 ms'  '     32 ms'  '    1.25 x' \r\n Array_Tuple_Object           1000000    '   3141 ms'  '     68 ms'  '     51 ms'  '    1.33 x' \r\n Array_Composite_Intersect    1000000    '   3145 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2134 ms'  '     68 ms'  '     31 ms'  '    2.19 x' \r\n Array_Math_Vector4           1000000    '   1197 ms'  '     37 ms'  '     25 ms'  '    1.48 x' \r\n Array_Math_Matrix4           1000000    '   5323 ms'  '    111 ms'  '     96 ms'  '    1.16 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '128.2 kb'  ' 58.2 kb'   '2.20 x'   \r\n typebox/errors        '110.4 kb'  ' 49.5 kb'   '2.23 x'   \r\n typebox/system        ' 75.2 kb'  ' 31.1 kb'   '2.42 x'   \r\n typebox/value         '179.6 kb'  ' 78.7 kb'   '2.28 x'   \r\n typebox               ' 74.1 kb'  ' 30.6 kb'   '2.42 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-vN2HaqkAaNjED53FH3QOqDiANehLP+506SjM5r+NdxzEQKmpjQ6YfhD0pil/tIP6DqKUfzMMcJgCIwOVHvjlRw==","_from":"file:sinclair-typebox-0.30.0-dev-3.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-3_1690567519383_0.36335670387324015"},"_hasShrinkwrap":false},"0.30.0-dev-4":{"_id":"@sinclair/typebox@0.30.0-dev-4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"35e87e52bcef9849ab7c199c3518bc93ce17fbc8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zAC4tVTnIZlbahxDbqHkENnzbCeQVFHVU+IbwJwFFjqZaSgHCB1EzzWLvDEcHpqtDdtcIiqIWuf0ZYeZhrBn4Q==","_from":"file:sinclair-typebox-0.30.0-dev-4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-4_1690574123221_0.12092975496664948"},"_hasShrinkwrap":false},"0.30.0-dev-5":{"_id":"@sinclair/typebox@0.30.0-dev-5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"2e21a2da583aa7f6ca4ed58c4d3e680f8307baae","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-5.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript language. TypeBox allows one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Features](#features)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Transform](#Transform)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that compose into complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                                type: 'number'            \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                   type: 'string'            \r\n ])                                                             }, {                         \r\n                                                                   type: 'number'            \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Pattern('^xy$')  type T = string              const T = {                    \r\n                                                                 type: 'string',             \r\n                                                                 pattern: '^xy$'             \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [...A, ...B]          items: [                     \r\n ])                                                               { const: 0 },              \r\n const B = Type.Tuple([                                           { const: 1 },              \r\n|   Type.Literal(2),                                               { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                return: {                    \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   JSON Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types are created with generic functions. All TypeBox types extend the sub type `TSchema` so it is common to constrain function arguments to this type. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types can be used to create aliases for more complex types. The following creates a `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Ref`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //   $id: 'T',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref<typeof T>('T')                    // const R = {\r\n                                                     //   $ref: 'T'\r\n                                                     // }\r\n\r\ntype R = Static<typeof R>                            // type R = string\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Recursive`. Recursive type inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Extends`. This type performs a structural assignment check against the first two parameters and returns either the `true` or `false` type as given from the second two parameters. The conditional types `Exclude` and `Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false> = {\r\n  Type.String(),                                     //   type: 'boolean',\r\n  Type.Number(),                                     //   const: false\r\n  Type.Literal(true),                                // }\r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1> = {\r\n  Type.Union([                                       //   type: 'number',\r\n    Type.Literal(1),                                 //   const: 1\r\n    Type.Literal(2),                                 // }\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]> = {\r\n    Type.Literal(3)                                 //   anyOf: [{\r\n  ]),                                               //     type: 'number',\r\n  Type.Literal(1)                                   //     const: 2\r\n)                                                   //   }, {\r\n                                                    //     type: 'number',\r\n                                                    //     const: 3\r\n                                                    //   }]\r\n                                                    // }\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `TemplateLiteral`. This type provides an embedded DSL syntax that is similar to the TypeScript template literal syntax. These type can also be composed by passing a tuple of exterior union and literal types. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = `option${'A'|'B'|'C'}`                      // type T = 'optionA' | 'optionB' | 'optionC'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     //   optionC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst T = Type.TemplateLiteral('option${A|B|C}')     // const T = {\r\n                                                     //   pattern: '^option(A|B|C)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //     optionC: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Index`. This type provides a consistent way of accessing interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nType negation can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the numbers `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well function parameter assignment.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports the creation of user defined schematics with user defined inference rules using the Unsafe type.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThis type can be useful to create various extended schematics, such as those used by OpenAPI.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a TypeGuard module to assert JavaScript values are valid TypeBox types.\r\n\r\n```typescript\r\nimport { Type, Kind, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. It's return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 7 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='transform'></a>\r\n\r\n## TypeBox Transform\r\n\r\nTypeBox offers a small web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[TypeBox Transform Link Here](https://sinclairzx81.github.io/typebox-transform/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    232 ms'  '      8 ms'  '   29.00 x' \r\n Literal_Number                 1000     '    179 ms'  '      6 ms'  '   29.83 x' \r\n Literal_Boolean                1000     '    154 ms'  '      3 ms'  '   51.33 x' \r\n Primitive_Number               1000     '    160 ms'  '      7 ms'  '   22.86 x' \r\n Primitive_String               1000     '    149 ms'  '      6 ms'  '   24.83 x' \r\n Primitive_String_Pattern       1000     '    191 ms'  '      9 ms'  '   21.22 x' \r\n Primitive_Boolean              1000     '    135 ms'  '      4 ms'  '   33.75 x' \r\n Primitive_Null                 1000     '    144 ms'  '      6 ms'  '   24.00 x' \r\n Object_Unconstrained           1000     '   1144 ms'  '     30 ms'  '   38.13 x' \r\n Object_Constrained             1000     '   1228 ms'  '     24 ms'  '   51.17 x' \r\n Object_Vector3                 1000     '    380 ms'  '      9 ms'  '   42.22 x' \r\n Object_Box3D                   1000     '   1771 ms'  '     30 ms'  '   59.03 x' \r\n Tuple_Primitive                1000     '    471 ms'  '     11 ms'  '   42.82 x' \r\n Tuple_Object                   1000     '   1272 ms'  '     15 ms'  '   84.80 x' \r\n Composite_Intersect            1000     '    606 ms'  '     17 ms'  '   35.65 x' \r\n Composite_Union                1000     '    560 ms'  '     22 ms'  '   25.45 x' \r\n Math_Vector4                   1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Math_Matrix4                   1000     '    419 ms'  '      9 ms'  '   46.56 x' \r\n Array_Primitive_Number         1000     '    382 ms'  '      6 ms'  '   63.67 x' \r\n Array_Primitive_String         1000     '    324 ms'  '      6 ms'  '   54.00 x' \r\n Array_Primitive_Boolean        1000     '    301 ms'  '      4 ms'  '   75.25 x' \r\n Array_Object_Unconstrained     1000     '   1734 ms'  '     21 ms'  '   82.57 x' \r\n Array_Object_Constrained       1000     '   1509 ms'  '     20 ms'  '   75.45 x' \r\n Array_Tuple_Primitive          1000     '    824 ms'  '     14 ms'  '   58.86 x' \r\n Array_Tuple_Object             1000     '   1619 ms'  '     16 ms'  '  101.19 x' \r\n Array_Composite_Intersect      1000     '    773 ms'  '     16 ms'  '   48.31 x' \r\n Array_Composite_Union          1000     '    822 ms'  '     17 ms'  '   48.35 x' \r\n Array_Math_Vector4             1000     '   1131 ms'  '     13 ms'  '   87.00 x' \r\n Array_Math_Matrix4             1000     '    661 ms'  '     10 ms'  '   66.10 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     13 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_Number             1000000    '     21 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Primitive_String             1000000    '     19 ms'  '     16 ms'  '     10 ms'  '    1.60 x' \r\n Primitive_String_Pattern     1000000    '    150 ms'  '     41 ms'  '     35 ms'  '    1.17 x' \r\n Primitive_Boolean            1000000    '     17 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     18 ms'  '     16 ms'  '      9 ms'  '    1.78 x' \r\n Object_Unconstrained         1000000    '   1001 ms'  '     31 ms'  '     24 ms'  '    1.29 x' \r\n Object_Constrained           1000000    '   1288 ms'  '     50 ms'  '     36 ms'  '    1.39 x' \r\n Object_Vector3               1000000    '    439 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2109 ms'  '     52 ms'  '     45 ms'  '    1.16 x' \r\n Object_Recursive             1000000    '   5337 ms'  '    356 ms'  '    162 ms'  '    2.20 x' \r\n Tuple_Primitive              1000000    '    164 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    744 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    764 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Composite_Union              1000000    '    516 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    262 ms'  '     20 ms'  '     11 ms'  '    1.82 x' \r\n Math_Matrix4                 1000000    '   1089 ms'  '     37 ms'  '     27 ms'  '    1.37 x' \r\n Array_Primitive_Number       1000000    '    276 ms'  '     21 ms'  '     11 ms'  '    1.91 x' \r\n Array_Primitive_String       1000000    '    228 ms'  '     21 ms'  '     14 ms'  '    1.50 x' \r\n Array_Primitive_Boolean      1000000    '    159 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5695 ms'  '     77 ms'  '     69 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5701 ms'  '    127 ms'  '    110 ms'  '    1.15 x' \r\n Array_Object_Recursive       1000000    '  21267 ms'  '   1664 ms'  '    573 ms'  '    2.90 x' \r\n Array_Tuple_Primitive        1000000    '    702 ms'  '     40 ms'  '     32 ms'  '    1.25 x' \r\n Array_Tuple_Object           1000000    '   3141 ms'  '     68 ms'  '     51 ms'  '    1.33 x' \r\n Array_Composite_Intersect    1000000    '   3145 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2134 ms'  '     68 ms'  '     31 ms'  '    2.19 x' \r\n Array_Math_Vector4           1000000    '   1197 ms'  '     37 ms'  '     25 ms'  '    1.48 x' \r\n Array_Math_Matrix4           1000000    '   5323 ms'  '    111 ms'  '     96 ms'  '    1.16 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '129.4 kb'  ' 58.6 kb'   '2.21 x'   \r\n typebox/errors        '111.6 kb'  ' 50.1 kb'   '2.23 x'   \r\n typebox/system        ' 76.5 kb'  ' 31.7 kb'   '2.41 x'   \r\n typebox/value         '180.7 kb'  ' 79.3 kb'   '2.28 x'   \r\n typebox               ' 75.4 kb'  ' 31.3 kb'   '2.41 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-AKj1g4O094yFQieQ/RDcuguUMA4T2WfZetcmttk8uVA/Cw+94SS2fMOraB3dfRJuyTLM20Z63p6jayWxlyHBug==","_from":"file:sinclair-typebox-0.30.0-dev-5.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-5_1690787321247_0.7262271003183987"},"_hasShrinkwrap":false},"0.30.0-dev-6":{"_id":"@sinclair/typebox@0.30.0-dev-6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"ba14756b110f34fae377d0f53f86ea0b129fc152","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-DGMcWvxLJYOygHeqEX9cmEsqeTR5R4OepZNNHPykqbf6aCEw/6cZGYSc5WW7xu2EyWXD9HFbNlHppB9vNZ9tAg==","_from":"file:sinclair-typebox-0.30.0-dev-6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-6_1690791404666_0.878776167597586"},"_hasShrinkwrap":false},"0.30.0-dev-7":{"_id":"@sinclair/typebox@0.30.0-dev-7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"39b9fcb9427895ebca077c5db3ed861e6aef1650","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-TZcJVBlSs4tFA0XBG/rkyEwJ1qcD0n21k1FPSwufr7SVTijAKIw9Zqknhscnzjf32mqxrfzkTUGWLYGSJo4ynw==","_from":"file:sinclair-typebox-0.30.0-dev-7.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-7_1690812339986_0.09473113343279382"},"_hasShrinkwrap":false},"0.30.0":{"_id":"@sinclair/typebox@0.30.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"3ab85aaa4bce87b108bf3a1d4841ea84e0ae247b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7v+I+UuRm7S8rV6u1rz3MkXO5skN1QiqlTeIY6ShiuvhcEnzRIrj/bqzHQNb9M2O9d8Q1mepW7lJ9cNUA1HEVg==","_from":"file:sinclair-typebox-0.30.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0_1690873305700_0.2641088922239663"},"_hasShrinkwrap":false},"0.30.1":{"_id":"@sinclair/typebox@0.30.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"e34963817dad11a39f18f704c533d3a641639fdf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gEhL8rDxir3+Q0uYMeT9rQgp1g9YazEphp4tBdc10e0zMm/0pT3G1FlLHyN1DMZUI4Vk6nebZvtt1evB0nXdiw==","_from":"file:sinclair-typebox-0.30.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.1_1690972066124_0.6792638178712562"},"_hasShrinkwrap":false},"0.30.2":{"_id":"@sinclair/typebox@0.30.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"6036b17f2ccf0ef8a308d8c352e3081075c43c57","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PNEojrBZGQL+llfGfGn6EZNHUXxyvA3LeySMUxMk+i+GrtuT1nBBP3BPzzgJKW9b7lUMa9KxHVx+CIPEy5bL5w==","_from":"file:sinclair-typebox-0.30.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.2_1690974068622_0.9966290001682034"},"_hasShrinkwrap":false},"0.30.3":{"_id":"@sinclair/typebox@0.30.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"fedbaa4543ec80056f5df43c89253cfdc1d32b40","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Cho1WteNnbVrd6jYVr1mLeGF6nVkUVgMJdYV0FeGI+I1iSNIUu1O8lQbfz+Gh3DczZT7qoYeOuZS/wck2rtO8Q==","_from":"file:sinclair-typebox-0.30.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.3_1691224694549_0.8205580707831439"},"_hasShrinkwrap":false},"0.30.4":{"_id":"@sinclair/typebox@0.30.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.4","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"8c918bc127385272a9f988fa2bcf7d3259599e5e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-wFuuDR+O1OAE2GL0q68h1Ty00RE6Ihcixr55A6TU5RCvOUHnwJw9LGuDVg9NxDiAp7m/YJpa+UaOuLAz0ziyOQ==","_from":"file:sinclair-typebox-0.30.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.4_1691239420930_0.135149747192846"},"_hasShrinkwrap":false},"0.31.0-dev-1":{"_id":"@sinclair/typebox@0.31.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"a3c755b97d9db5e9e6a4f7767fe6d88235d605f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0-dev-1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Xu0ci9wK3HvjzO1wCJQ9SRyWGAEvLcsQhJeO55B9Yg9riBCDbR1Tawv4SUBqi6HzanTH2Az5NP5ay1ZVmaUIKQ==","_from":"file:sinclair-typebox-0.31.0-dev-1.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0-dev-1_1691532899325_0.440843669369682"},"_hasShrinkwrap":false},"0.31.0-dev-2":{"_id":"@sinclair/typebox@0.31.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"0c256d48b44d6afb712fa67adad675d420800d47","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0-dev-2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Pp50GMRKmBjtB5cmCUFJxvy63R/xj2v2WhTwBeWBoMDmtATOskfUKxHiiYfpJC9/acjErVsddK2GSUGw9+ozPg==","_from":"file:sinclair-typebox-0.31.0-dev-2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0-dev-2_1691535759005_0.9622796716288109"},"_hasShrinkwrap":false},"0.31.0":{"_id":"@sinclair/typebox@0.31.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"afd4478bf839b276be62e93b4df474d5b01eeb60","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bL3KIy1cqi4wyKwJZ3szckq0k/IuLluwQ9IB8QMNS2ogHGiqkempV7uO52Tjr79oBgOnlRaOhIf5qkc8HH9KhA==","_from":"file:sinclair-typebox-0.31.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0_1691789746220_0.6147373461731431"},"_hasShrinkwrap":false},"0.31.1":{"_id":"@sinclair/typebox@0.31.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"f9edccb4447481e62d93639361bf643c911dfa8a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-oAGsVU6u4k7pNGfDZG1ujFuku25yV3lFmyxZXXLylm0Pf2Qh9pgGFpGwPbyyFZl9PYH4thS9qRcfs3C2Sn3/SA==","_from":"file:sinclair-typebox-0.31.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.1_1691984972683_0.05885190593091738"},"_hasShrinkwrap":false},"0.31.2":{"_id":"@sinclair/typebox@0.31.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"88b998a269479e343718996d920938e2f7b30ed4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+LlOCOcCcsq6zxt1Ld9VkOSTMY6189dBtHHxb2nUftYpiUFXX0mKuK/UgtX84haktCs/x8j8k29v//ohdjlToA==","_from":"file:sinclair-typebox-0.31.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.2_1692732914608_0.7840422654140333"},"_hasShrinkwrap":false},"0.31.3":{"_id":"@sinclair/typebox@0.31.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"0ddee232d923704e5e4b9b70a28a34c6a30fc849","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-9ie8Vuvtw+7CzFhTbwmqtnpTMuMl1TU1WhY/P3LZopp/oruyKHO7uO9FqDq/m7r0vAavZnsSmBI7EMOjtpaqow==","_from":"file:sinclair-typebox-0.31.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.3_1692948129652_0.1448890577198747"},"_hasShrinkwrap":false},"0.31.4":{"_id":"@sinclair/typebox@0.31.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"d191cf12fb88cc987fecd439c6af7ec786b600ed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bNZ4CwuZYxJ7yvCVE2zANanEsXUtPfdPQyLe3tT7i30QwfndMbVyVCK3wmHQQSybaK+vUu4SYWlxdAQqshIBHA==","_from":"file:sinclair-typebox-0.31.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.4_1693034773978_0.8455569852993023"},"_hasShrinkwrap":false},"0.31.5":{"_id":"@sinclair/typebox@0.31.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"10ae6c60fc523d7d695a730df1ac3dd9725ce207","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4fbqH1ONle98ULTQakJFVNwGwSx+rv90HEnjZGt1GoApMKooUw1WXw3ub+Ew7rInmyDcwsjIxiHt39bkWzeCBA==","_from":"file:sinclair-typebox-0.31.5.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.5_1693116207042_0.7289156502756995"},"_hasShrinkwrap":false},"0.31.6":{"_id":"@sinclair/typebox@0.31.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"cbe60cc433595ba9c69f472688110526285e4899","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-u6Y0wqb1VAO+WwfRgJTzxNsv5P8QmF50Q2tVTDSdyLZcEwhcTujibc9vfPzJB9pYMvLNQtQGKyvlcexUoHYkKg==","_from":"file:sinclair-typebox-0.31.6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.6_1693301295065_0.11727929055730257"},"_hasShrinkwrap":false},"0.31.7":{"_id":"@sinclair/typebox@0.31.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"758c8e6de5403f85cbdb377c19f92eab6e1fa076","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cl6qKMXSK95aMwIzSQJeenKBtPmE1+hqts3vJe93EaSa7cIaNjz3A5yMKkgW/bAhjnOpa/yiCCV1pOG1bzzv0A==","_from":"file:sinclair-typebox-0.31.7.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.7_1693334778025_0.5379311470690515"},"_hasShrinkwrap":false},"0.31.8":{"_id":"@sinclair/typebox@0.31.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"61023e06173069e7fcadaeb8c0905d2a097e47ae","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1FdxgmuUqQWprlAHzGKTH3qSeNzbYnHXD65WIZOI037hcCZVw+r8SoFd8OIFUrbQxEI+MhHArCvKlndLvfw/bg==","_from":"file:sinclair-typebox-0.31.8.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.8_1693428016234_0.10418235844936508"},"_hasShrinkwrap":false},"0.31.9":{"_id":"@sinclair/typebox@0.31.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f6eebba4f3631624d0895283723116d3e1d8d91d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-p73UG4m/1h/1hraNZtabquOkryCbqpqrwok9T3XqPwp8H7V4+t12mzeZLVzxSNvtasI/44f5IZxNwpwjPX+Uwg==","_from":"file:sinclair-typebox-0.31.9.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.9_1693752879003_0.20649502754230475"},"_hasShrinkwrap":false},"0.31.10":{"_id":"@sinclair/typebox@0.31.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"70fa2eaface2de6a16fa2965b64fa2cb261bfcd5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d4xyuqhmWHQk3glt5hS2GXJ2IM9ZkUbMWJeKLpHbpQ1G80CGXZfem2smpbXlazQmbGSWNekjSrMVgCstiz1xoQ==","_from":"file:sinclair-typebox-0.31.10.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.10_1693849932650_0.5600767668152526"},"_hasShrinkwrap":false},"0.31.11":{"_id":"@sinclair/typebox@0.31.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"8f3aa21a672101036c177d7b9d98e9cec2b345ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-jTrfYeIdeU0ZZ3M5b2Mbf86Zc+STPjsPU6TJAauapqWippeybZGM8GZEHM3r03jt+ggrnZrQyeYTzw1m9eT7HQ==","_from":"file:sinclair-typebox-0.31.11.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.11_1693928926880_0.4989610280240433"},"_hasShrinkwrap":false},"0.31.12":{"_id":"@sinclair/typebox@0.31.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"672f66a4c7af4fd9d8f36c037c3df27d3419dd1a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XeIsBp4yYM92lHfVBCFyhImXlUt3EbyY+4FNCW+Lr7U+8pjli//9WVYo3tALrcB7frOOQxXiL2SOu0tY0mNYEw==","_from":"file:sinclair-typebox-0.31.12.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.12_1693933075100_0.5416820601349286"},"_hasShrinkwrap":false},"0.31.13":{"_id":"@sinclair/typebox@0.31.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"e91b39b79c35b52e4eb56b1b89ec505b2e02b605","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-V4UoNN1XlRiQd/s1iWlLUTmfGCKDB+B7KteI/m6OKPBXPsVeZ7bqTDrdD+9mAWwFXaXqYnX06+tzVjK3bcvS9g==","_from":"file:sinclair-typebox-0.31.13.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.13_1693936359664_0.25284302427485184"},"_hasShrinkwrap":false},"0.31.14":{"_id":"@sinclair/typebox@0.31.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"0c1f3f8dbb6c866088faab04af7fa7cda7f8e8c3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-2spk0ie6J/4r+nwb55OtBXUn5cZLF9S98fopIjuutBVoq8yLRNh+h8QvMkCjMu5gWBMnnZ/PUSXeHE3xGBPKLQ==","_from":"file:sinclair-typebox-0.31.14.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.14_1693944954668_0.4943767959973815"},"_hasShrinkwrap":false},"0.31.15":{"_id":"@sinclair/typebox@0.31.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"182bff2527c2953540f0b5e8d1851888fb57b2eb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gheE0Z2QWB/EuUwirniP+vq17N0MdQ+9bKyy2lPJzcBin6piBxOrazTYOB18N+oeBwVVepAmlqqo9KbpSl9DOA==","_from":"file:sinclair-typebox-0.31.15.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.15_1694675896349_0.7995434864007394"},"_hasShrinkwrap":false},"0.31.16":{"_id":"@sinclair/typebox@0.31.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"29e9b9644111d86bf4093c55c2337810a6ae7e21","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-US3ytBkDVP1JqooE1pBXgh97c8ljW05RkZj0MM6eVAsnZOtjalurleXy6LwssfazPDqQk/Vy64Ood77L4jG7Dw==","_from":"file:sinclair-typebox-0.31.16.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.16_1695625181372_0.41246447406395026"},"_hasShrinkwrap":false},"0.31.17":{"_id":"@sinclair/typebox@0.31.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f9ceed480957b919b203bb0b3e27bc559d1e8e19","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GVYVHHOGINx+DT2DwjXoCQO0mRpztYKyb3d48tucuqhjhHpQYGp7Xx7dhhQGzILx/beuBrzfITMC7/5X7fw+UA==","_from":"file:sinclair-typebox-0.31.17.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.17_1695712949768_0.15572870385508786"},"_hasShrinkwrap":false},"0.31.18":{"_id":"@sinclair/typebox@0.31.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"556a3de891d5daa004875f6d86c69754084428a6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-p2JGz+SciGJVl1zokCIK15f7LYDrI2ZsxItcLhkAyx50hEYEj/Qdy7z30qRYiakzdIu8dV4DfBi+e6xEZuugiQ==","_from":"file:sinclair-typebox-0.31.18.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.18_1697551093030_0.0032364591017253197"},"_hasShrinkwrap":false},"0.31.19":{"_id":"@sinclair/typebox@0.31.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"99f7b9746546b2b38b9d02e1fbd5d07e558b04c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8GznR/3FgDgA20Its5gd+BZqbtE0amjEidsIX4T2stmDFcaAcQviGsBmzlBtJ0E1Gxk8VtHxL4rt4/KSc/UdxQ==","_from":"file:sinclair-typebox-0.31.19.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.19_1698258870408_0.2736483475559721"},"_hasShrinkwrap":false},"0.31.20":{"_id":"@sinclair/typebox@0.31.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"74e855ba87a795f10c1eb9d791c7316d930d292e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-pqkf2X6fc1yk6c3Rk41cT8NYFKmzngl8TVHy375X7ihlONCsX7/YTReRLyZX7zZhuUUBx9KTZPFFDZo6AIERCw==","_from":"file:sinclair-typebox-0.31.20.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.20_1698312280235_0.11409787401523608"},"_hasShrinkwrap":false},"0.31.21":{"_id":"@sinclair/typebox@0.31.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"d52d8e35f71e5651042aa0237e918e4b21fbbbf8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Wtq/K44EMkREaXytK+2c5DrygtYsH7ZxT0StQL8HMJz2BoOM7NZ/xfrUFBVuZxDrhJCoXf5Im282P2CCz5DHwQ==","_from":"file:sinclair-typebox-0.31.21.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.21_1698580122964_0.44984771980197724"},"_hasShrinkwrap":false},"0.31.22":{"_id":"@sinclair/typebox@0.31.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.22","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f13fa4050a7e883d252365902e38186fa0dc8ab8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-CKviMgpcXd8q8IsQQD8cCleswe4/EkQRcOqtVQcP1e+XUyszjJYjgL5Dtf3XunWZc2zEGmQPqJEsq08NiW9xfw==","_from":"file:sinclair-typebox-0.31.22.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.22_1698940182867_0.7848260405558538"},"_hasShrinkwrap":false},"0.31.23":{"_id":"@sinclair/typebox@0.31.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"5ae0235824e63b595952dceb001b813349688b1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZzrzE8yCrWWU4mcBstBgdlBMjB8My3ESY9nZ/v996GptIJb4+MU1p7s1Qxrc2xvZeOiDDnAheLLmdHjPgZV79g==","_from":"file:sinclair-typebox-0.31.23.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.23_1699371263183_0.9664026554798715"},"_hasShrinkwrap":false},"0.31.24":{"_id":"@sinclair/typebox@0.31.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"3b718fbb4240953e83faa49be43b43ec9506adba","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.24.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3zmHQ+4ta05eLGjm/gq+hkFWS4rfr3/zUw8331Yg1X1IdqyDnt5FvoRx5LkK/YdvvJuO04x+E+Y/09Kde588Ng==","_from":"file:sinclair-typebox-0.31.24.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.24_1700030003352_0.2159360944541322"},"_hasShrinkwrap":false},"0.31.25":{"_id":"@sinclair/typebox@0.31.25","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.25","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"6ad0dca016c5a4a8f4578118815c3e4fe340c3fe","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.25.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tc075wfx6qCftSuNHq7kPNVTNhb5qBDf7B+c7pBdLkzxGsXdsqeinlRZQuGzrSowSh7nxEKvZKRUdbRGqy0GCA==","_from":"file:sinclair-typebox-0.31.25.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.25_1700056121068_0.7892015606687566"},"_hasShrinkwrap":false},"0.31.26":{"_id":"@sinclair/typebox@0.31.26","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.26","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f17fbefcfb38311e7ee2b9a3071f86cc62ab43cc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.26.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0S5BGB/Tle1kVa1pT2k2sc+wHTCB28+ivuetmZDCRV8I0iFKaNfk6HbvVyLEFBzZy56dp0dw+YDJ9Ed+YAAL7A==","_from":"file:sinclair-typebox-0.31.26.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.26_1700299362858_0.544186268354792"},"_hasShrinkwrap":false},"0.31.27":{"_id":"@sinclair/typebox@0.31.27","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.27","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"9776614f4c5ee4434043e0ba1499d297800b3d46","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.27.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Gf/P/hssx1ew6VNA5yLw3eLQb+fuuo63mlobVUSQHNCrQLXx4OzRa7Yt/mTZNGImBSrJo1a0bWR1NmpVjrU6xw==","_from":"file:sinclair-typebox-0.31.27.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.27_1700423117480_0.17875870350417"},"_hasShrinkwrap":false},"0.31.28":{"_id":"@sinclair/typebox@0.31.28","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.28","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"b68831e7bc7d09daac26968ea32f42bedc968ede","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.28.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/s55Jujywdw/Jpan+vsy6JZs1z2ZTGxTmbZTPiuSL2wz9mfzA2gN1zzaqmvfi4pq+uOt7Du85fkiwv5ymW84aQ==","_from":"file:sinclair-typebox-0.31.28.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.28_1700485032007_0.8377792278241056"},"_hasShrinkwrap":false},"0.32.0-dev-1":{"_id":"@sinclair/typebox@0.32.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./typebox.js","dist":{"shasum":"3edc8ab536bca3dd153045fb26e7d7da1f6ec947","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-w1FOdYZ7SvVMVFJvI7y0z9oK2c042rjUXTNEVYcyzsWBNppYp318sAg3vDAQlzDHNUeAXVLMxffrA6d8wjl+uw==","_from":"file:sinclair-typebox-0.32.0-dev-1.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-1_1701339204704_0.9492457449975578"},"_hasShrinkwrap":false},"0.32.0-dev-10":{"_id":"@sinclair/typebox@0.32.0-dev-10","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"ec8744d9029cfa7000acf32d35c97aa74b458099","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-10.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-FYb+t0IhNIBRPLlK7OSm7kWJjuku7cMpkKyG9GVVgd57fDiBBzwxIS1v1lYCu3E/+t28CAupvIwbnlpIAC3H1Q==","_from":"file:sinclair-typebox-0.32.0-dev-10.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-10_1701508816106_0.8616030386948672"},"_hasShrinkwrap":false},"0.32.0-dev-11":{"_id":"@sinclair/typebox@0.32.0-dev-11","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"55244d6d1cdec3b42b2d483460b5c2f025348857","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-11.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-qNU9nI/7qGkNREpp1PGq2Pv5GNdOhOFRF548U4HqUBoIdCKnen3vUbesGjtcMoLe3P6tbrWU0gNXb52PtfB7Xw==","_from":"file:sinclair-typebox-0.32.0-dev-11.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-11_1701524144522_0.8767059968626214"},"_hasShrinkwrap":false},"0.32.0-dev-12":{"_id":"@sinclair/typebox@0.32.0-dev-12","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"040168caf430bc4bef3f629c4cc9d246d8c2b713","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-12.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-JpW4q+5kErpuBSK9XFNxaIC0OXJtK2e1zlgLyrgSzRhSSVl92gcL9I9GdQRiR+PWWYH4Trfz03t3Kp9H6t0/mw==","_from":"file:sinclair-typebox-0.32.0-dev-12.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-12_1701617086836_0.42992935497086693"},"_hasShrinkwrap":false},"0.32.0-dev-13":{"_id":"@sinclair/typebox@0.32.0-dev-13","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"c1b163a73ac7b7933bd09e60f10ac6150d75de4e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-13.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-mY04jGlpuzF6rLoGs3ypVVoH48881HeOaoP2V2YBPdzwlktYcYRCjEBwO3bqYM+AhcAqL8E29E6cyhdUdhebHw==","_from":"file:sinclair-typebox-0.32.0-dev-13.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-13_1701678614384_0.07321368713450904"},"_hasShrinkwrap":false},"0.32.0-dev-14":{"_id":"@sinclair/typebox@0.32.0-dev-14","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"d94de0600e5f3461ae8bdf041317e4e4d2ad5647","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-14.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-qY/dg4OCxbkNl/5AWgzsC3FlqsUV3FpPwvUzQzayjfMPFf0Z9GHTlS78Tc8ua/Xxy+c4CS8jm+Jtols4h36b7A==","_from":"file:sinclair-typebox-0.32.0-dev-14.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-14_1701786126823_0.6916619598532394"},"_hasShrinkwrap":false},"0.32.0-dev-15":{"_id":"@sinclair/typebox@0.32.0-dev-15","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-15","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"57f446458f6805723b6e39de39021203f6193080","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-15.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Modular](#types-modular)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modular'></a>\r\n\r\n### Modular Types\r\n\r\nTypeBox implements a modular type system. The following imports the full type system (recommended)\r\n\r\n```typescript\r\nimport { Type } from '@sinclair/typebox'             // 36.5 kb minified\r\n```\r\nThe following imports types individually which enables modern bundlers to optimize bundle sizes via tree shaking.\r\n```typescript\r\nimport { Object, Number } from '@sinclair/typebox'   // 6.4 kb minified\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports Template Literal types with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript Template Literal syntax. TypeBox encodes Template Literals as regular expression string patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.3 kb'  ' 52.4 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.0 kb'  ' 61.5 kb'   '2.34 x'   \r\n typebox               ' 87.0 kb'  ' 36.5 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-6qOG/AGmazd6CtkoHxhZiQn/VxBjfQZV2n3tyuokemCLfjOLPiFLhA1IKK6VHaFLnodTYw2O6+hg70au0JY+sA==","_from":"file:sinclair-typebox-0.32.0-dev-15.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-15_1701870711300_0.9724360760426025"},"_hasShrinkwrap":false},"0.32.0-dev-16":{"_id":"@sinclair/typebox@0.32.0-dev-16","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-16","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"39a096eef89dc0beddc077d0dc11527c4d494eda","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-16.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Type Modules\r\n\r\nTypeBox uses a modular type system and supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique allows modern bundlers to tree shake unused types. This can reduce overall bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-2ZU4e0Jy9r4+yN//XduC/JhijPM7XxUfsYxrw+t5DJfIGTqceLLBDYGmWE0hsRsP0APU+uyFwwqTRHxCElsoFA==","_from":"file:sinclair-typebox-0.32.0-dev-16.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-16_1701934907703_0.14809380003578898"},"_hasShrinkwrap":false},"0.32.0-dev-17":{"_id":"@sinclair/typebox@0.32.0-dev-17","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-17","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"c078255189ca290eab7207b0deb79bcb4c878b07","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-17.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-OmvOC9TKFsGD7m+v+M23PQ4jsbodzFtIsjeGYQYx902kyDwiUbuomKrQ+ANs1Y/5elDQ+Q85DeDdBsvMIopfkg==","_from":"file:sinclair-typebox-0.32.0-dev-17.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-17_1701938116742_0.8082912823199455"},"_hasShrinkwrap":false},"0.32.0-dev-18":{"_id":"@sinclair/typebox@0.32.0-dev-18","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-18","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"97b8373b4b49180dad74c576d48f0165e3dadf2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-18.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-xf4IZEwDLDkEfqtQsTU8PN2mB2O7YqwtFGYGEVWkao0oaEXkGtsnvRyo9eGxwW2urFR93UcaA90v9fOksUNeJA==","_from":"file:sinclair-typebox-0.32.0-dev-18.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-18_1702022672297_0.022591453628886482"},"_hasShrinkwrap":false},"0.32.0-dev-19":{"_id":"@sinclair/typebox@0.32.0-dev-19","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-19","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"d9e6b34abf618799491e815029f26efe450ab5aa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-19.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-7euPCdhmlAVMl7ocKJGRf8OCtnG4p60F14rGiK1pynf4KSwAfYHrztonXzFYFv+KGzPqsNvhBYX61nSDtTUjTQ==","_from":"file:sinclair-typebox-0.32.0-dev-19.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-19_1702030362425_0.5497631686403808"},"_hasShrinkwrap":false},"0.32.0-dev-2":{"_id":"@sinclair/typebox@0.32.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build:esm":"hammer task build_esm","build:cjs":"hammer task build_cjs","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./cjs/index.js","dist":{"shasum":"6aa3f8d2d218596d16acf9b941b3639d3913632d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-2.tgz"},"module":"./esm/index.mjs","types":"./esm/index.d.mts","_integrity":"sha512-89x/4VrgjDuPqftJm1O/V7g1N/x0u/efEKHW+FZzPoZ2ZzZ5EMtgD8jtkCWRbn07cACFYONn0vy96zKCck8uUw==","_from":"file:sinclair-typebox-0.32.0-dev-2.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-2_1701351674965_0.31282098806285075"},"_hasShrinkwrap":false},"0.32.0-dev-20":{"_id":"@sinclair/typebox@0.32.0-dev-20","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-20","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"11d3eba86a2f02bff8255f319980f4eaab517088","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-20.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types, this leading to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts a distributive key (`K`) as the second. The following remaps each property of `T` to be optional.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Optional(Type.Index(T, K))             //   [K in keyof T]?: T[K]\r\n})                                                   // }\r\n                                                     //\r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-mwP83V9TA+aIBfpkCyM4EVYlOic5Y1BvcQEy/NEgCXzu6jPPoqLZbSDLA5mqQ251xpGoJU9ZgVoxLoozFUhXeg==","_from":"file:sinclair-typebox-0.32.0-dev-20.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-20_1702049584265_0.2553132108844789"},"_hasShrinkwrap":false},"0.32.0-dev-21":{"_id":"@sinclair/typebox@0.32.0-dev-21","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-21","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"16578f9373a2f4da1ae3bf3f6a5803be087be90c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-21.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-9UwbKjIIxp05SlEQV+ba3A6lUy1SsXd2neL46YUgdw2gks1vXfzzsPEdntTjIaxFLPDyO3GGU8xte1bjnVXVZg==","_from":"file:sinclair-typebox-0.32.0-dev-21.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-21_1702183933100_0.8610675907485126"},"_hasShrinkwrap":false},"0.32.0-dev-22":{"_id":"@sinclair/typebox@0.32.0-dev-22","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-22","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"f00f0b2c7d68de5beb01c8881783f914a0136b79","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-22.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-fYL6U/77HUyDSeXo+LAlIxAM6kcAmdxeEzCBUURXnmQatP9HugEK5MfvE7KfpuJ6FI+xtvLy9ny6IjniRKvXpg==","_from":"file:sinclair-typebox-0.32.0-dev-22.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-22_1702217724193_0.03962458512595357"},"_hasShrinkwrap":false},"0.32.0-dev-23":{"_id":"@sinclair/typebox@0.32.0-dev-23","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-23","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ac29755cbcc17d9bf0686dfc9691776af7c90347","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-23.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '118.7 kb'  ' 52.5 kb'   '2.26 x'   \r\n typebox/errors        ' 55.1 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.6 kb'  '  2.0 kb'   '2.31 x'   \r\n typebox/value         '144.8 kb'  ' 61.8 kb'   '2.34 x'   \r\n typebox               ' 87.7 kb'  ' 36.7 kb'   '2.39 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-yfd7OK2sBv4ITjirkmgDpDnpEmq2IzpYh5hKzI/L8U/hVdW4Uncs45wtjFpNcSUQsOB74pg2cb39wxZB37KDLQ==","_from":"file:sinclair-typebox-0.32.0-dev-23.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-23_1702219093715_0.09320221532624906"},"_hasShrinkwrap":false},"0.32.0-dev-24":{"_id":"@sinclair/typebox@0.32.0-dev-24","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-24","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"f28f525a63614a8dab39ebd5cacdaa4f03556ea4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-24.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '119.9 kb'  ' 52.5 kb'   '2.29 x'   \r\n typebox/errors        ' 55.5 kb'  ' 25.2 kb'   '2.21 x'   \r\n typebox/system        '  4.7 kb'  '  2.0 kb'   '2.33 x'   \r\n typebox/value         '146.8 kb'  ' 61.9 kb'   '2.37 x'   \r\n typebox               ' 90.7 kb'  ' 37.7 kb'   '2.40 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-o0wRofs4pondSFt3q8Xvbq3Gv2XOXzLBouGeQBsTNexdr4HTklRjKRbIgBKIw8BkQ+mI+sXzfb7qcrZyGFd6PA==","_from":"file:sinclair-typebox-0.32.0-dev-24.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-24_1702276394587_0.9137285489766649"},"_hasShrinkwrap":false},"0.32.0-dev-25":{"_id":"@sinclair/typebox@0.32.0-dev-25","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-25","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"5e394b938cda6d466d26d00c9abc9af2b999f05f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-25.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '120.5 kb'  ' 52.7 kb'   '2.29 x'   \r\n typebox/errors        ' 55.5 kb'  ' 25.2 kb'   '2.20 x'   \r\n typebox/system        '  4.7 kb'  '  2.0 kb'   '2.33 x'   \r\n typebox/value         '147.4 kb'  ' 62.2 kb'   '2.37 x'   \r\n typebox               ' 91.3 kb'  ' 38.0 kb'   '2.40 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-ZA154KxWufyWQDKvwDzOqlIIysCY6fThKcCydlB/eLWsMQzngGqWVEDO5EPq6ih1o0C5OQCpSfyCjUL/tqnKTA==","_from":"file:sinclair-typebox-0.32.0-dev-25.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-25_1702355895087_0.8391608982725174"},"_hasShrinkwrap":false},"0.32.0-dev-26":{"_id":"@sinclair/typebox@0.32.0-dev-26","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-26","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"0355e3b1535f914df77fadcf194a4037343f3a2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-26.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    236 ms'  '      9 ms'  '   26.22 x' \r\n Literal_Number                 1000     '    205 ms'  '     13 ms'  '   15.77 x' \r\n Literal_Boolean                1000     '    168 ms'  '      4 ms'  '   42.00 x' \r\n Primitive_Number               1000     '    170 ms'  '      8 ms'  '   21.25 x' \r\n Primitive_String               1000     '    162 ms'  '      7 ms'  '   23.14 x' \r\n Primitive_String_Pattern       1000     '    211 ms'  '     10 ms'  '   21.10 x' \r\n Primitive_Boolean              1000     '    139 ms'  '      4 ms'  '   34.75 x' \r\n Primitive_Null                 1000     '    146 ms'  '      5 ms'  '   29.20 x' \r\n Object_Unconstrained           1000     '   1160 ms'  '     33 ms'  '   35.15 x' \r\n Object_Constrained             1000     '   1257 ms'  '     26 ms'  '   48.35 x' \r\n Object_Vector3                 1000     '    393 ms'  '      8 ms'  '   49.13 x' \r\n Object_Box3D                   1000     '   1795 ms'  '     30 ms'  '   59.83 x' \r\n Tuple_Primitive                1000     '    542 ms'  '     16 ms'  '   33.88 x' \r\n Tuple_Object                   1000     '   1330 ms'  '     17 ms'  '   78.24 x' \r\n Composite_Intersect            1000     '    624 ms'  '     17 ms'  '   36.71 x' \r\n Composite_Union                1000     '    565 ms'  '     19 ms'  '   29.74 x' \r\n Math_Vector4                   1000     '    853 ms'  '     10 ms'  '   85.30 x' \r\n Math_Matrix4                   1000     '    406 ms'  '     12 ms'  '   33.83 x' \r\n Array_Primitive_Number         1000     '    401 ms'  '     11 ms'  '   36.45 x' \r\n Array_Primitive_String         1000     '    385 ms'  '      6 ms'  '   64.17 x' \r\n Array_Primitive_Boolean        1000     '    347 ms'  '      8 ms'  '   43.38 x' \r\n Array_Object_Unconstrained     1000     '   1904 ms'  '     25 ms'  '   76.16 x' \r\n Array_Object_Constrained       1000     '   1582 ms'  '     20 ms'  '   79.10 x' \r\n Array_Tuple_Primitive          1000     '    864 ms'  '     11 ms'  '   78.55 x' \r\n Array_Tuple_Object             1000     '   1658 ms'  '     16 ms'  '  103.63 x' \r\n Array_Composite_Intersect      1000     '    786 ms'  '     17 ms'  '   46.24 x' \r\n Array_Composite_Union          1000     '    844 ms'  '     16 ms'  '   52.75 x' \r\n Array_Math_Vector4             1000     '   1192 ms'  '     10 ms'  '  119.20 x' \r\n Array_Math_Matrix4             1000     '    688 ms'  '     10 ms'  '   68.80 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     19 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     14 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     21 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     22 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_String_Pattern     1000000    '    164 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '    966 ms'  '     33 ms'  '     24 ms'  '    1.38 x' \r\n Object_Constrained           1000000    '   1275 ms'  '     52 ms'  '     42 ms'  '    1.24 x' \r\n Object_Vector3               1000000    '    427 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Object_Box3D                 1000000    '   2024 ms'  '     56 ms'  '     50 ms'  '    1.12 x' \r\n Object_Recursive             1000000    '   5263 ms'  '    358 ms'  '    164 ms'  '    2.18 x' \r\n Tuple_Primitive              1000000    '    157 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Tuple_Object                 1000000    '    767 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    769 ms'  '     26 ms'  '     15 ms'  '    1.73 x' \r\n Composite_Union              1000000    '    501 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    250 ms'  '     23 ms'  '     11 ms'  '    2.09 x' \r\n Math_Matrix4                 1000000    '   1073 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    264 ms'  '     21 ms'  '     12 ms'  '    1.75 x' \r\n Array_Primitive_String       1000000    '    242 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Primitive_Boolean      1000000    '    151 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Object_Unconstrained   1000000    '   5864 ms'  '     66 ms'  '     58 ms'  '    1.14 x' \r\n Array_Object_Constrained     1000000    '   5996 ms'  '    138 ms'  '    116 ms'  '    1.19 x' \r\n Array_Object_Recursive       1000000    '  22515 ms'  '   1625 ms'  '    585 ms'  '    2.78 x' \r\n Array_Tuple_Primitive        1000000    '    737 ms'  '     38 ms'  '     31 ms'  '    1.23 x' \r\n Array_Tuple_Object           1000000    '   3257 ms'  '     77 ms'  '     56 ms'  '    1.38 x' \r\n Array_Composite_Intersect    1000000    '   3119 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Array_Composite_Union        1000000    '   2108 ms'  '     72 ms'  '     33 ms'  '    2.18 x' \r\n Array_Math_Vector4           1000000    '   1078 ms'  '     38 ms'  '     26 ms'  '    1.46 x' \r\n Array_Math_Matrix4           1000000    '   4967 ms'  '    126 ms'  '     88 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '120.7 kb'  ' 53.0 kb'   '2.28 x'   \r\n typebox/errors        ' 55.8 kb'  ' 25.5 kb'   '2.19 x'   \r\n typebox/system        '  4.7 kb'  '  2.0 kb'   '2.33 x'   \r\n typebox/value         '147.6 kb'  ' 62.5 kb'   '2.36 x'   \r\n typebox               ' 91.3 kb'  ' 38.0 kb'   '2.40 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-JScTTo253fqiQL9MpYdUbSjg8qM5AZpIJ5Tuw78eXxgc7+r/JLHn7dKdsgZKbxmU53FWbuchUrNnGK9pqFOZHQ==","_from":"file:sinclair-typebox-0.32.0-dev-26.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-26_1702361510341_0.18220126424548"},"_hasShrinkwrap":false},"0.32.0-dev-27":{"_id":"@sinclair/typebox@0.32.0-dev-27","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-27","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"3b730fcdf517ad69eb60565c173442c13cb63214","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-27.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is built to be a runtime type system offering similar capabilities to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    242 ms'  '     10 ms'  '   24.20 x' \r\n Literal_Number                 1000     '    200 ms'  '      8 ms'  '   25.00 x' \r\n Literal_Boolean                1000     '    168 ms'  '      6 ms'  '   28.00 x' \r\n Primitive_Number               1000     '    165 ms'  '      8 ms'  '   20.63 x' \r\n Primitive_String               1000     '    154 ms'  '      6 ms'  '   25.67 x' \r\n Primitive_String_Pattern       1000     '    208 ms'  '     14 ms'  '   14.86 x' \r\n Primitive_Boolean              1000     '    142 ms'  '      6 ms'  '   23.67 x' \r\n Primitive_Null                 1000     '    143 ms'  '      6 ms'  '   23.83 x' \r\n Object_Unconstrained           1000     '   1217 ms'  '     31 ms'  '   39.26 x' \r\n Object_Constrained             1000     '   1275 ms'  '     26 ms'  '   49.04 x' \r\n Object_Vector3                 1000     '    405 ms'  '     12 ms'  '   33.75 x' \r\n Object_Box3D                   1000     '   1833 ms'  '     27 ms'  '   67.89 x' \r\n Tuple_Primitive                1000     '    475 ms'  '     13 ms'  '   36.54 x' \r\n Tuple_Object                   1000     '   1267 ms'  '     30 ms'  '   42.23 x' \r\n Composite_Intersect            1000     '    604 ms'  '     18 ms'  '   33.56 x' \r\n Composite_Union                1000     '    545 ms'  '     20 ms'  '   27.25 x' \r\n Math_Vector4                   1000     '    829 ms'  '     12 ms'  '   69.08 x' \r\n Math_Matrix4                   1000     '    405 ms'  '     10 ms'  '   40.50 x' \r\n Array_Primitive_Number         1000     '    372 ms'  '     12 ms'  '   31.00 x' \r\n Array_Primitive_String         1000     '    327 ms'  '      5 ms'  '   65.40 x' \r\n Array_Primitive_Boolean        1000     '    300 ms'  '      4 ms'  '   75.00 x' \r\n Array_Object_Unconstrained     1000     '   1755 ms'  '     21 ms'  '   83.57 x' \r\n Array_Object_Constrained       1000     '   1516 ms'  '     20 ms'  '   75.80 x' \r\n Array_Tuple_Primitive          1000     '    825 ms'  '     14 ms'  '   58.93 x' \r\n Array_Tuple_Object             1000     '   1616 ms'  '     16 ms'  '  101.00 x' \r\n Array_Composite_Intersect      1000     '    776 ms'  '     16 ms'  '   48.50 x' \r\n Array_Composite_Union          1000     '    820 ms'  '     14 ms'  '   58.57 x' \r\n Array_Math_Vector4             1000     '   1166 ms'  '     15 ms'  '   77.73 x' \r\n Array_Math_Matrix4             1000     '    695 ms'  '      8 ms'  '   86.88 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     16 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Literal_Boolean              1000000    '     15 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Primitive_Number             1000000    '     21 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Primitive_String             1000000    '     22 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_String_Pattern     1000000    '    155 ms'  '     41 ms'  '     34 ms'  '    1.21 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '   1003 ms'  '     32 ms'  '     24 ms'  '    1.33 x' \r\n Object_Constrained           1000000    '   1265 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Object_Vector3               1000000    '    418 ms'  '     22 ms'  '     13 ms'  '    1.69 x' \r\n Object_Box3D                 1000000    '   2035 ms'  '     56 ms'  '     49 ms'  '    1.14 x' \r\n Object_Recursive             1000000    '   5243 ms'  '    326 ms'  '    157 ms'  '    2.08 x' \r\n Tuple_Primitive              1000000    '    153 ms'  '     20 ms'  '     12 ms'  '    1.67 x' \r\n Tuple_Object                 1000000    '    781 ms'  '     28 ms'  '     18 ms'  '    1.56 x' \r\n Composite_Intersect          1000000    '    742 ms'  '     25 ms'  '     14 ms'  '    1.79 x' \r\n Composite_Union              1000000    '    558 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    246 ms'  '     22 ms'  '     11 ms'  '    2.00 x' \r\n Math_Matrix4                 1000000    '   1052 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    272 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Array_Primitive_String       1000000    '    235 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Primitive_Boolean      1000000    '    134 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Object_Unconstrained   1000000    '   6280 ms'  '     65 ms'  '     59 ms'  '    1.10 x' \r\n Array_Object_Constrained     1000000    '   6076 ms'  '    130 ms'  '    119 ms'  '    1.09 x' \r\n Array_Object_Recursive       1000000    '  22738 ms'  '   1730 ms'  '    635 ms'  '    2.72 x' \r\n Array_Tuple_Primitive        1000000    '    689 ms'  '     35 ms'  '     30 ms'  '    1.17 x' \r\n Array_Tuple_Object           1000000    '   3266 ms'  '     63 ms'  '     52 ms'  '    1.21 x' \r\n Array_Composite_Intersect    1000000    '   3310 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Array_Composite_Union        1000000    '   2432 ms'  '     69 ms'  '     33 ms'  '    2.09 x' \r\n Array_Math_Vector4           1000000    '   1158 ms'  '     37 ms'  '     24 ms'  '    1.54 x' \r\n Array_Math_Matrix4           1000000    '   5435 ms'  '    132 ms'  '     92 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '119.2 kb'  ' 52.3 kb'   '2.28 x'   \r\n typebox/errors        ' 55.0 kb'  ' 25.2 kb'   '2.19 x'   \r\n typebox/system        '  4.7 kb'  '  2.0 kb'   '2.33 x'   \r\n typebox/value         '146.1 kb'  ' 61.8 kb'   '2.37 x'   \r\n typebox               ' 90.1 kb'  ' 37.3 kb'   '2.41 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-pGai7CigzKh7V+nU8GsKFfVuirhNClOPahMIEkWzaypZxgAPX9Igi+4Pfyx9s8tALUV9izjJ5GQXbWUJLyg4Nw==","_from":"file:sinclair-typebox-0.32.0-dev-27.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-27_1702419052016_0.11450007963241982"},"_hasShrinkwrap":false},"0.32.0-dev-28":{"_id":"@sinclair/typebox@0.32.0-dev-28","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-28","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"184b179e31aacfbbccffdad30a8bcb661116dcd8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-28.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is built to be a runtime type system offering similar capabilities to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                   ? true                      type: 'boolean'              \r\n   Type.Literal(true),              : false                   }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Mapped(          type T = {                   const T = {                    \r\n   Type.Union([                    [_ in 'x' | 'y'] : number    type: 'object',              \r\n     Type.Literal('x'),          }                              required: ['x', 'y'],        \r\n     Type.Literal('y')                                          properties: {                \r\n   ]),                                                            x: {                       \r\n   () => Type.Number()                                              type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/i)   type T = string              const T = {                    \r\n                                                                type: 'RegExp'               \r\n                                                                source: 'abc'                \r\n                                                                flags: 'i'                   \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    242 ms'  '     10 ms'  '   24.20 x' \r\n Literal_Number                 1000     '    200 ms'  '      8 ms'  '   25.00 x' \r\n Literal_Boolean                1000     '    168 ms'  '      6 ms'  '   28.00 x' \r\n Primitive_Number               1000     '    165 ms'  '      8 ms'  '   20.63 x' \r\n Primitive_String               1000     '    154 ms'  '      6 ms'  '   25.67 x' \r\n Primitive_String_Pattern       1000     '    208 ms'  '     14 ms'  '   14.86 x' \r\n Primitive_Boolean              1000     '    142 ms'  '      6 ms'  '   23.67 x' \r\n Primitive_Null                 1000     '    143 ms'  '      6 ms'  '   23.83 x' \r\n Object_Unconstrained           1000     '   1217 ms'  '     31 ms'  '   39.26 x' \r\n Object_Constrained             1000     '   1275 ms'  '     26 ms'  '   49.04 x' \r\n Object_Vector3                 1000     '    405 ms'  '     12 ms'  '   33.75 x' \r\n Object_Box3D                   1000     '   1833 ms'  '     27 ms'  '   67.89 x' \r\n Tuple_Primitive                1000     '    475 ms'  '     13 ms'  '   36.54 x' \r\n Tuple_Object                   1000     '   1267 ms'  '     30 ms'  '   42.23 x' \r\n Composite_Intersect            1000     '    604 ms'  '     18 ms'  '   33.56 x' \r\n Composite_Union                1000     '    545 ms'  '     20 ms'  '   27.25 x' \r\n Math_Vector4                   1000     '    829 ms'  '     12 ms'  '   69.08 x' \r\n Math_Matrix4                   1000     '    405 ms'  '     10 ms'  '   40.50 x' \r\n Array_Primitive_Number         1000     '    372 ms'  '     12 ms'  '   31.00 x' \r\n Array_Primitive_String         1000     '    327 ms'  '      5 ms'  '   65.40 x' \r\n Array_Primitive_Boolean        1000     '    300 ms'  '      4 ms'  '   75.00 x' \r\n Array_Object_Unconstrained     1000     '   1755 ms'  '     21 ms'  '   83.57 x' \r\n Array_Object_Constrained       1000     '   1516 ms'  '     20 ms'  '   75.80 x' \r\n Array_Tuple_Primitive          1000     '    825 ms'  '     14 ms'  '   58.93 x' \r\n Array_Tuple_Object             1000     '   1616 ms'  '     16 ms'  '  101.00 x' \r\n Array_Composite_Intersect      1000     '    776 ms'  '     16 ms'  '   48.50 x' \r\n Array_Composite_Union          1000     '    820 ms'  '     14 ms'  '   58.57 x' \r\n Array_Math_Vector4             1000     '   1166 ms'  '     15 ms'  '   77.73 x' \r\n Array_Math_Matrix4             1000     '    695 ms'  '      8 ms'  '   86.88 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     18 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     16 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Literal_Boolean              1000000    '     15 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Primitive_Number             1000000    '     21 ms'  '     19 ms'  '     10 ms'  '    1.90 x' \r\n Primitive_String             1000000    '     22 ms'  '     18 ms'  '      9 ms'  '    2.00 x' \r\n Primitive_String_Pattern     1000000    '    155 ms'  '     41 ms'  '     34 ms'  '    1.21 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     19 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '   1003 ms'  '     32 ms'  '     24 ms'  '    1.33 x' \r\n Object_Constrained           1000000    '   1265 ms'  '     49 ms'  '     38 ms'  '    1.29 x' \r\n Object_Vector3               1000000    '    418 ms'  '     22 ms'  '     13 ms'  '    1.69 x' \r\n Object_Box3D                 1000000    '   2035 ms'  '     56 ms'  '     49 ms'  '    1.14 x' \r\n Object_Recursive             1000000    '   5243 ms'  '    326 ms'  '    157 ms'  '    2.08 x' \r\n Tuple_Primitive              1000000    '    153 ms'  '     20 ms'  '     12 ms'  '    1.67 x' \r\n Tuple_Object                 1000000    '    781 ms'  '     28 ms'  '     18 ms'  '    1.56 x' \r\n Composite_Intersect          1000000    '    742 ms'  '     25 ms'  '     14 ms'  '    1.79 x' \r\n Composite_Union              1000000    '    558 ms'  '     24 ms'  '     13 ms'  '    1.85 x' \r\n Math_Vector4                 1000000    '    246 ms'  '     22 ms'  '     11 ms'  '    2.00 x' \r\n Math_Matrix4                 1000000    '   1052 ms'  '     43 ms'  '     28 ms'  '    1.54 x' \r\n Array_Primitive_Number       1000000    '    272 ms'  '     22 ms'  '     12 ms'  '    1.83 x' \r\n Array_Primitive_String       1000000    '    235 ms'  '     24 ms'  '     14 ms'  '    1.71 x' \r\n Array_Primitive_Boolean      1000000    '    134 ms'  '     23 ms'  '     14 ms'  '    1.64 x' \r\n Array_Object_Unconstrained   1000000    '   6280 ms'  '     65 ms'  '     59 ms'  '    1.10 x' \r\n Array_Object_Constrained     1000000    '   6076 ms'  '    130 ms'  '    119 ms'  '    1.09 x' \r\n Array_Object_Recursive       1000000    '  22738 ms'  '   1730 ms'  '    635 ms'  '    2.72 x' \r\n Array_Tuple_Primitive        1000000    '    689 ms'  '     35 ms'  '     30 ms'  '    1.17 x' \r\n Array_Tuple_Object           1000000    '   3266 ms'  '     63 ms'  '     52 ms'  '    1.21 x' \r\n Array_Composite_Intersect    1000000    '   3310 ms'  '     44 ms'  '     36 ms'  '    1.22 x' \r\n Array_Composite_Union        1000000    '   2432 ms'  '     69 ms'  '     33 ms'  '    2.09 x' \r\n Array_Math_Vector4           1000000    '   1158 ms'  '     37 ms'  '     24 ms'  '    1.54 x' \r\n Array_Math_Matrix4           1000000    '   5435 ms'  '    132 ms'  '     92 ms'  '    1.43 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '120.6 kb'  ' 52.9 kb'   '2.28 x'   \r\n typebox/errors        ' 55.7 kb'  ' 25.5 kb'   '2.19 x'   \r\n typebox/system        '  4.7 kb'  '  2.0 kb'   '2.33 x'   \r\n typebox/value         '146.2 kb'  ' 62.0 kb'   '2.36 x'   \r\n typebox               ' 91.4 kb'  ' 37.8 kb'   '2.42 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-elOextcszz0f4sjgTFocol5xzItnqc3EkOjXeEV4VEKKKOL3X+KCebj6Hopf/Qx1Sv1RUWrJuAjbD4JlUiYOAA==","_from":"file:sinclair-typebox-0.32.0-dev-28.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-28_1702528738529_0.8387211120071285"},"_hasShrinkwrap":false},"0.32.0-dev-3":{"_id":"@sinclair/typebox@0.32.0-dev-3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build:esm":"hammer task build_esm","build:cjs":"hammer task build_cjs","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./cjs/index.js","dist":{"shasum":"2bd2037dfef924b70986912e6bceeaa559447f4b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-3.tgz"},"module":"./esm/index.mjs","types":"./esm/index.d.mts","_integrity":"sha512-uKa3O8gB7Z+mlrB2nH696SUKDWpVFmDSR7DlWjoyvmXMIUkDtewOmgBDdNSddpOYCHLBbiSCbUG4Kff63LKgPw==","_from":"file:sinclair-typebox-0.32.0-dev-3.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-3_1701353789270_0.27843614283743223"},"_hasShrinkwrap":false},"0.32.0-dev-4":{"_id":"@sinclair/typebox@0.32.0-dev-4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./index.js","dist":{"shasum":"edee7485f157bf11575d9a78173a69af4df803cf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-4.tgz"},"types":"./index.d.ts","_integrity":"sha512-3jHO6XqEwcAlaZGuH9aMmVRP39SmwVVGCimOp33IHqtJ1KXCF6tA9t8s1pTVlJ5+GSq1H9I0PHqZ1Rqo/WlJtA==","_from":"file:sinclair-typebox-0.32.0-dev-4.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-4_1701482715809_0.18275578254789315"},"_hasShrinkwrap":false},"0.32.0-dev-5":{"_id":"@sinclair/typebox@0.32.0-dev-5","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","directories":{},"main":"./build/default/index.js","dist":{"shasum":"30233fcc92cd02224dd13d39773f35aa7fbe543e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-5.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Rest](#types-rest)\r\n  - [Transform](#types-transform)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Errors](#typesystem-errors)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This type will recursively reconstruct interior referenced types.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check for the first two arguments and will infer one of the second two arguments based on the result. The Extends type is designed to match the assignability rules of TypeScript conditional types. The conditional derived types Exclude and Extract are also supported.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax. TypeBox encodes template literals as regular expression string patterns which enable the template be checked via Json Schema. It also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access Types with Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, TemplateLiteral and Union types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the built-in Json and JavaScript type sets. They also manage TypeBox's localization options (i18n) for error message generation and can control various assertion policies used when type checking. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the TypeSystemErrorFunction to override validation error messages. This can be used to localize errors or create error messages for user defined types.\r\n\r\n```typescript\r\nimport { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'\r\n\r\nTypeSystemErrorFunction.Set((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T = { ... }\r\n  x: Type.String(),\r\n  y: Type.Number(),\r\n  z: Type.Boolean()\r\n})\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    216 ms'  '      9 ms'  '   24.00 x' \r\n Literal_Number                 1000     '    169 ms'  '      7 ms'  '   24.14 x' \r\n Literal_Boolean                1000     '    150 ms'  '      5 ms'  '   30.00 x' \r\n Primitive_Number               1000     '    161 ms'  '      7 ms'  '   23.00 x' \r\n Primitive_String               1000     '    148 ms'  '      6 ms'  '   24.67 x' \r\n Primitive_String_Pattern       1000     '    185 ms'  '      9 ms'  '   20.56 x' \r\n Primitive_Boolean              1000     '    132 ms'  '      4 ms'  '   33.00 x' \r\n Primitive_Null                 1000     '    141 ms'  '      3 ms'  '   47.00 x' \r\n Object_Unconstrained           1000     '   1109 ms'  '     30 ms'  '   36.97 x' \r\n Object_Constrained             1000     '   1200 ms'  '     24 ms'  '   50.00 x' \r\n Object_Vector3                 1000     '    379 ms'  '      9 ms'  '   42.11 x' \r\n Object_Box3D                   1000     '   1709 ms'  '     30 ms'  '   56.97 x' \r\n Tuple_Primitive                1000     '    456 ms'  '     14 ms'  '   32.57 x' \r\n Tuple_Object                   1000     '   1229 ms'  '     17 ms'  '   72.29 x' \r\n Composite_Intersect            1000     '    570 ms'  '     17 ms'  '   33.53 x' \r\n Composite_Union                1000     '    513 ms'  '     19 ms'  '   27.00 x' \r\n Math_Vector4                   1000     '    782 ms'  '     13 ms'  '   60.15 x' \r\n Math_Matrix4                   1000     '    393 ms'  '     12 ms'  '   32.75 x' \r\n Array_Primitive_Number         1000     '    361 ms'  '     12 ms'  '   30.08 x' \r\n Array_Primitive_String         1000     '    296 ms'  '      5 ms'  '   59.20 x' \r\n Array_Primitive_Boolean        1000     '    315 ms'  '      4 ms'  '   78.75 x' \r\n Array_Object_Unconstrained     1000     '   1721 ms'  '     22 ms'  '   78.23 x' \r\n Array_Object_Constrained       1000     '   1450 ms'  '     21 ms'  '   69.05 x' \r\n Array_Tuple_Primitive          1000     '    813 ms'  '     13 ms'  '   62.54 x' \r\n Array_Tuple_Object             1000     '   1537 ms'  '     17 ms'  '   90.41 x' \r\n Array_Composite_Intersect      1000     '    753 ms'  '     17 ms'  '   44.29 x' \r\n Array_Composite_Union          1000     '    808 ms'  '     16 ms'  '   50.50 x' \r\n Array_Math_Vector4             1000     '   1118 ms'  '     16 ms'  '   69.88 x' \r\n Array_Math_Matrix4             1000     '    690 ms'  '      9 ms'  '   76.67 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     24 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     20 ms'  '     10 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     25 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     21 ms'  '     24 ms'  '      9 ms'  '    2.67 x' \r\n Primitive_String_Pattern     1000000    '    156 ms'  '     43 ms'  '     38 ms'  '    1.13 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     20 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '   1055 ms'  '     32 ms'  '     24 ms'  '    1.33 x' \r\n Object_Constrained           1000000    '   1232 ms'  '     49 ms'  '     43 ms'  '    1.14 x' \r\n Object_Vector3               1000000    '    432 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Object_Box3D                 1000000    '   1993 ms'  '     54 ms'  '     46 ms'  '    1.17 x' \r\n Object_Recursive             1000000    '   5115 ms'  '    342 ms'  '    159 ms'  '    2.15 x' \r\n Tuple_Primitive              1000000    '    156 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    740 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    797 ms'  '     26 ms'  '     14 ms'  '    1.86 x' \r\n Composite_Union              1000000    '    530 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    240 ms'  '     22 ms'  '     11 ms'  '    2.00 x' \r\n Math_Matrix4                 1000000    '   1036 ms'  '     39 ms'  '     27 ms'  '    1.44 x' \r\n Array_Primitive_Number       1000000    '    248 ms'  '     20 ms'  '     12 ms'  '    1.67 x' \r\n Array_Primitive_String       1000000    '    227 ms'  '     22 ms'  '     13 ms'  '    1.69 x' \r\n Array_Primitive_Boolean      1000000    '    138 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5540 ms'  '     66 ms'  '     59 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5750 ms'  '    123 ms'  '    108 ms'  '    1.14 x' \r\n Array_Object_Recursive       1000000    '  21842 ms'  '   1771 ms'  '    599 ms'  '    2.96 x' \r\n Array_Tuple_Primitive        1000000    '    715 ms'  '     36 ms'  '     29 ms'  '    1.24 x' \r\n Array_Tuple_Object           1000000    '   3131 ms'  '     63 ms'  '     50 ms'  '    1.26 x' \r\n Array_Composite_Intersect    1000000    '   3064 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2172 ms'  '     65 ms'  '     31 ms'  '    2.10 x' \r\n Array_Math_Vector4           1000000    '   1032 ms'  '     37 ms'  '     24 ms'  '    1.54 x' \r\n Array_Math_Matrix4           1000000    '   4859 ms'  '    114 ms'  '     86 ms'  '    1.33 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '109.3 kb'  ' 48.5 kb'   '2.25 x'   \r\n typebox/errors        ' 54.8 kb'  ' 24.9 kb'   '2.20 x'   \r\n typebox/system        ' 12.1 kb'  '  6.1 kb'   '1.98 x'   \r\n typebox/type          ' 77.8 kb'  ' 32.8 kb'   '2.37 x'   \r\n typebox/value         '143.7 kb'  ' 61.2 kb'   '2.35 x'   \r\n typebox               ' 77.9 kb'  ' 32.8 kb'   '2.37 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./build/types/index.d.ts","module":"./build/import/index.mjs","readmeFilename":"readme.md","_integrity":"sha512-hxxK7BIb3oSQucvFR5hhAK9PnYiCzPfneQUZu2lnfFAUhVhGlzHyHMdViprGptDWD4qMmrhKcQeGvNByF+Oodg==","_from":"file:sinclair-typebox-0.32.0-dev-5.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-5_1701489295395_0.9903728896571504"},"_hasShrinkwrap":false},"0.32.0-dev-6":{"_id":"@sinclair/typebox@0.32.0-dev-6","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/default/index.js","dist":{"shasum":"ddbffc796d9f653887705bfaacbd3fc469e21564","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-6.tgz"},"types":"./build/types/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-r/+LRfImMeYuBTgSjFvkyMPKTZj/xOtXitVGMr3WaKVyrRQlvcYIhZcLi31lrpMKP1jbKgsKUulRrRPIpy6FQA==","_from":"file:sinclair-typebox-0.32.0-dev-6.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-6_1701490428077_0.617708370803159"},"_hasShrinkwrap":false},"0.32.0-dev-7":{"_id":"@sinclair/typebox@0.32.0-dev-7","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-7","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"9be1c821f0ddcfbddf150db8c37c66cc09dfa93f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-7.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Rest](#types-rest)\r\n  - [Transform](#types-transform)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Errors](#typesystem-errors)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Any()            type T = any                 const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.Unknown()        type T = unknown             const T = { }                  \r\n                                                                                             \r\n\r\n const T = Type.String()         type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Number()         type T = number              const T = {                    \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Integer()        type T = number              const T = {                    \r\n                                                                type: 'integer'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Boolean()        type T = boolean             const T = {                    \r\n                                                                type: 'boolean'              \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Null()           type T = null                const T = {                    \r\n                                                                type: 'null'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Literal(42)      type T = 42                  const T = {                    \r\n                                                                const: 42,                   \r\n                                                                type: 'number'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Array(           type T = number[]            const T = {                    \r\n   Type.Number()                                                type: 'array',               \r\n )                                                              items: {                     \r\n                                                                  type: 'number'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   x: Type.Number(),               x: number,                   type: 'object',              \r\n   y: Type.Number()                y: number                    required: ['x', 'y'],        \r\n })                              }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number'           \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Tuple([          type T = [number, number]    const T = {                    \r\n   Type.Number(),                                               type: 'array',               \r\n   Type.Number()                                                items: [{                    \r\n ])                                                               type: 'number'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                additionalItems: false,      \r\n                                                                minItems: 2,                 \r\n                                                                maxItems: 2                  \r\n                                                              }                              \r\n                                                                                             \r\n                                                                                             \r\n\r\n enum Foo {                      enum Foo {                   const T = {                    \r\n   A,                              A,                           anyOf: [{                    \r\n   B                               B                              type: 'number',            \r\n }                               }                                const: 0                   \r\n                                                                }, {                         \r\n const T = Type.Enum(Foo)        type T = Foo                     type: 'number',            \r\n                                                                  const: 1                   \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Const({          type T = {                   const T = {                    \r\n   x: 1,                           readonly x: 1,               type: 'object',              \r\n   y: 2,                           readonly y: 2                required: ['x', 'y'],        \r\n } as const)                     }                              properties: {                \r\n                                                                  x: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 1                 \r\n                                                                  },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number',          \r\n                                                                    const: 2                 \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.KeyOf(           type T = keyof {             const T = {                    \r\n   Type.Object({                   x: number,                   anyOf: [{                    \r\n     x: Type.Number(),             y: number                      type: 'string',            \r\n     y: Type.Number()            }                                const: 'x'                 \r\n   })                                                           }, {                         \r\n )                                                                type: 'string',            \r\n                                                                  const: 'y'                 \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Union([          type T = string | number     const T = {                    \r\n   Type.String(),                                               anyOf: [{                    \r\n   Type.Number()                                                  type: 'string'             \r\n ])                                                             }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Intersect([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number                    allOf: [{                    \r\n     x: Type.Number()            } & {                            type: 'object',            \r\n   }),                             y: number                      required: ['x'],           \r\n   Type.Object({                 }                                properties: {              \r\n     y: Type.Number()                                               x: {                     \r\n   ])                                                                 type: 'number'         \r\n ])                                                                 }                        \r\n                                                                  }                          \r\n                                                                }, {                         \r\n                                                                  type: 'object',            |\r\n                                                                  required: ['y'],           \r\n                                                                  properties: {              \r\n                                                                    y: {                     \r\n                                                                      type: 'number'         \r\n                                                                    }                        \r\n                                                                  }                          \r\n                                                                }]                           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Composite([      type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number()              y: number                    required: ['x', 'y'],        \r\n   }),                           }                              properties: {                \r\n   Type.Object({                                                  x: {                       \r\n     y: Type.Number()                                               type: 'number'           \r\n   })                                                             },                         \r\n ])                                                               y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Never()          type T = never               const T = {                    \r\n                                                                not: {}                      \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Not(            | type T = unknown             const T = {                    \r\n   Type.String()                                                not: {                       \r\n )                                                                type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n\r\n const T = Type.Extends(         type T =                     const T = {                    \r\n   Type.String(),                 string extends number         const: false,                \r\n   Type.Number(),                 true : false                  type: 'boolean'              \r\n   Type.Literal(true),                                        }                              \r\n   Type.Literal(false)                                                                       \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Extract(         type T = Extract<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'string'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const T = Type.Exclude(         type T = Exclude<            const T = {                    \r\n   Type.Union([                    string | number,             type: 'number'               \r\n     Type.String(),                string                     }                              \r\n     Type.Number(),              >                                                           \r\n   ]),                                                                                       \r\n   Type.String()                                                                             \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const U = Type.Union([          type U = 'open' | 'close'    const T = {                    \r\n   Type.Literal('open'),                                        type: 'string',              \r\n   Type.Literal('close')         type T = `on${U}`              pattern: '^on(open|close)$'  \r\n ])                                                           }                              \r\n                                                                                             \r\n const T = Type                                                                              \r\n   .TemplateLiteral([                                                                        \r\n      Type.Literal('on'),                                                                    \r\n      U                                                                                      \r\n   ])                                                                                        \r\n                                                                                             \r\n\r\n const T = Type.Record(          type T = Record<             const T = {                    \r\n   Type.String(),                  string,                      type: 'object',              \r\n   Type.Number()                   number                       patternProperties: {         \r\n )                               >                                '^.*$': {                  \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Partial(         type T = Partial<{           const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    properties: {                \r\n     y: Type.Number()           | }>                               x: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                },                         \r\n                                                                  y: {                       \r\n                                                                    type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Required(        type T = Required<{          const T = {                    \r\n   Type.Object({                   x?: number,                  type: 'object',              \r\n     x: Type.Optional(             y?: number                   required: ['x', 'y'],        \r\n       Type.Number()            | }>                             properties: {                \r\n     ),                                                           x: {                       \r\n     y: Type.Optional(                                              type: 'number'           \r\n       Type.Number()                                              },                         \r\n     )                                                            y: {                       \r\n   })                                                               type: 'number'           \r\n )                                                                }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Pick(            type T = Pick<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['x'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  x: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Omit(            type T = Omit<{              const T = {                    \r\n   Type.Object({                   x: number,                   type: 'object',              \r\n     x: Type.Number(),             y: number                    required: ['y'],             \r\n     y: Type.Number()            }, 'x'>                        properties: {                \r\n   }), ['x']                    |                                  y: {                       \r\n )                                                                  type: 'number'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Index(           type T = {                   const T = {                    \r\n   Type.Object({                   x: number,                   type: 'number'               \r\n     x: Type.Number(),             y: string                  }                              \r\n     y: Type.String()            }['x']                                                      \r\n   }), ['x']                                                                                 \r\n )                                                                                           \r\n                                                                                             \r\n\r\n const A = Type.Tuple([          type A = [0, 1]              const T = {                    \r\n   Type.Literal(0),              type B = [2, 3]                type: 'array',               \r\n   Type.Literal(1)               type T = [                     items: [                     \r\n ])                                ...A,                          { const: 0 },              \r\n const B = Type.Tuple([            ...B                           { const: 1 },              \r\n|   Type.Literal(2),              ]                                { const: 2 },              \r\n|   Type.Literal(3)                                                { const: 3 }               \r\n ])                                                             ],                           \r\n const T = Type.Tuple([                                         additionalItems: false,      \r\n|   ...Type.Rest(A),                                             minItems: 4,                 \r\n|   ...Type.Rest(B)                                              maxItems: 4                  \r\n ])                                                           }                              \r\n                                                                                             \r\n\r\n const T = Type.Uncapitalize(    type T = Uncapitalize<       const T = {                    \r\n   Type.Literal('Hello')           'Hello'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Capitalize(      type T = Capitalize<         const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'Hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uppercase(       type T = Uppercase<          const T = {                    \r\n   Type.Literal('hello')           'hello'                      type: 'string',              \r\n )                               >                              const: 'HELLO'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Lowercase(       type T = Lowercase<          const T = {                    \r\n   Type.Literal('HELLO')           'HELLO'                      type: 'string',              \r\n )                               >                              const: 'hello'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const R = {                    \r\n    x: Type.Number(),              x: number,                   $ref: 'T'                    \r\n    y: Type.Number()               y: number                  }                              \r\n }, { $id: 'T' })               | }                                                           \r\n                                                                                             \r\n const R = Type.Ref(T)           type R = T                                                  \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Extended Schema                \r\n                                                                                             \r\n\r\n const T = Type.Constructor([    type T = new (               const T = {                    \r\n   Type.String(),                 arg0: string,                 type: 'Constructor',         \r\n   Type.Number()                  arg0: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Function([       type T = (                   const T = {                    \r\n|   Type.String(),                 arg0: string,                 type: 'Function',            \r\n   Type.Number()                  arg1: number                  parameters: [{               \r\n ], Type.Boolean())              ) => boolean                     type: 'string'             \r\n                                                                }, {                         \r\n                                                                  type: 'number'             \r\n                                                                }],                          \r\n                                                                returns: {                   \r\n                                                                  type: 'boolean'            \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Promise(         type T = Promise<string>     const T = {                    \r\n   Type.String()                                                type: 'Promise',             \r\n )                                                              item: {                      \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T =                       type T =                     const T = {                    \r\n   Type.AsyncIterator(             AsyncIterableIterator<       type: 'AsyncIterator',       \r\n     Type.String()                  string                      items: {                     \r\n   )                               >                              type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Iterator(        type T =                     const T = {                    \r\n   Type.String()                   IterableIterator<string>     type: 'Iterator',            \r\n )                                                              items: {                     \r\n                                                                  type: 'string'             \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.RegExp(/abc/)    type T = string              const T = {                    \r\n                                                                type: 'string'               \r\n                                                                pattern: 'abc'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Uint8Array()     type T = Uint8Array          const T = {                    \r\n                                                                type: 'Uint8Array'           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Date()           type T = Date                const T = {                    \r\n                                                                type: 'Date'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Undefined()      type T = undefined           const T = {                    \r\n                                                                type: 'undefined'            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Symbol()         type T = symbol              const T = {                    \r\n                                                                type: 'symbol'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.BigInt()         type T = bigint              const T = {                    \r\n                                                                type: 'bigint'               \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Void()           type T = void                const T = {                    \r\n                                                                type: 'void'                 \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n\r\n TypeBox                         TypeScript                   Json Schema                    \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.ReadonlyOptional(    readonly name?: string       type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Readonly(            readonly name: string        type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                },                           \r\n                                                                required: ['name']           \r\n                                                              }                              \r\n                                                                                             \r\n\r\n const T = Type.Object({         type T = {                   const T = {                    \r\n   name: Type.Optional(            name?: string                type: 'object',              \r\n     Type.String()               }                              properties: {                \r\n   )                                                              name: {                    \r\n })  \t                                                             type: 'string'           \r\n                                                                  }                          \r\n                                                                }                            \r\n                                                              }                              \r\n                                                                                             \r\n\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This type will recursively reconstruct interior referenced types.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check for the first two arguments and will infer one of the second two arguments based on the result. The Extends type is designed to match the assignability rules of TypeScript conditional types. The conditional derived types Exclude and Extract are also supported.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax. TypeBox encodes template literals as regular expression string patterns which enable the template be checked via Json Schema. It also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access Types with Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, TemplateLiteral and Union types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the built-in Json and JavaScript type sets. They also manage TypeBox's localization options (i18n) for error message generation and can control various assertion policies used when type checking. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the TypeSystemErrorFunction to override validation error messages. This can be used to localize errors or create error messages for user defined types.\r\n\r\n```typescript\r\nimport { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'\r\n\r\nTypeSystemErrorFunction.Set((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return ' '      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T = { ... }\r\n  x: Type.String(),\r\n  y: Type.Number(),\r\n  z: Type.Boolean()\r\n})\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: ' '\r\n                                                     // }]\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations      Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String                 1000     '    216 ms'  '      9 ms'  '   24.00 x' \r\n Literal_Number                 1000     '    169 ms'  '      7 ms'  '   24.14 x' \r\n Literal_Boolean                1000     '    150 ms'  '      5 ms'  '   30.00 x' \r\n Primitive_Number               1000     '    161 ms'  '      7 ms'  '   23.00 x' \r\n Primitive_String               1000     '    148 ms'  '      6 ms'  '   24.67 x' \r\n Primitive_String_Pattern       1000     '    185 ms'  '      9 ms'  '   20.56 x' \r\n Primitive_Boolean              1000     '    132 ms'  '      4 ms'  '   33.00 x' \r\n Primitive_Null                 1000     '    141 ms'  '      3 ms'  '   47.00 x' \r\n Object_Unconstrained           1000     '   1109 ms'  '     30 ms'  '   36.97 x' \r\n Object_Constrained             1000     '   1200 ms'  '     24 ms'  '   50.00 x' \r\n Object_Vector3                 1000     '    379 ms'  '      9 ms'  '   42.11 x' \r\n Object_Box3D                   1000     '   1709 ms'  '     30 ms'  '   56.97 x' \r\n Tuple_Primitive                1000     '    456 ms'  '     14 ms'  '   32.57 x' \r\n Tuple_Object                   1000     '   1229 ms'  '     17 ms'  '   72.29 x' \r\n Composite_Intersect            1000     '    570 ms'  '     17 ms'  '   33.53 x' \r\n Composite_Union                1000     '    513 ms'  '     19 ms'  '   27.00 x' \r\n Math_Vector4                   1000     '    782 ms'  '     13 ms'  '   60.15 x' \r\n Math_Matrix4                   1000     '    393 ms'  '     12 ms'  '   32.75 x' \r\n Array_Primitive_Number         1000     '    361 ms'  '     12 ms'  '   30.08 x' \r\n Array_Primitive_String         1000     '    296 ms'  '      5 ms'  '   59.20 x' \r\n Array_Primitive_Boolean        1000     '    315 ms'  '      4 ms'  '   78.75 x' \r\n Array_Object_Unconstrained     1000     '   1721 ms'  '     22 ms'  '   78.23 x' \r\n Array_Object_Constrained       1000     '   1450 ms'  '     21 ms'  '   69.05 x' \r\n Array_Tuple_Primitive          1000     '    813 ms'  '     13 ms'  '   62.54 x' \r\n Array_Tuple_Object             1000     '   1537 ms'  '     17 ms'  '   90.41 x' \r\n Array_Composite_Intersect      1000     '    753 ms'  '     17 ms'  '   44.29 x' \r\n Array_Composite_Union          1000     '    808 ms'  '     16 ms'  '   50.50 x' \r\n Array_Math_Vector4             1000     '   1118 ms'  '     16 ms'  '   69.88 x' \r\n Array_Math_Matrix4             1000     '    690 ms'  '      9 ms'  '   76.67 x' \r\n\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n\r\n          (index)            Iterations   ValueCheck       Ajv       TypeCompiler  Performance  \r\n\r\n Literal_String               1000000    '     24 ms'  '      5 ms'  '      4 ms'  '    1.25 x' \r\n Literal_Number               1000000    '     15 ms'  '     20 ms'  '     10 ms'  '    2.00 x' \r\n Literal_Boolean              1000000    '     14 ms'  '     19 ms'  '      9 ms'  '    2.11 x' \r\n Primitive_Number             1000000    '     25 ms'  '     18 ms'  '     10 ms'  '    1.80 x' \r\n Primitive_String             1000000    '     21 ms'  '     24 ms'  '      9 ms'  '    2.67 x' \r\n Primitive_String_Pattern     1000000    '    156 ms'  '     43 ms'  '     38 ms'  '    1.13 x' \r\n Primitive_Boolean            1000000    '     18 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Primitive_Null               1000000    '     20 ms'  '     17 ms'  '      9 ms'  '    1.89 x' \r\n Object_Unconstrained         1000000    '   1055 ms'  '     32 ms'  '     24 ms'  '    1.33 x' \r\n Object_Constrained           1000000    '   1232 ms'  '     49 ms'  '     43 ms'  '    1.14 x' \r\n Object_Vector3               1000000    '    432 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Object_Box3D                 1000000    '   1993 ms'  '     54 ms'  '     46 ms'  '    1.17 x' \r\n Object_Recursive             1000000    '   5115 ms'  '    342 ms'  '    159 ms'  '    2.15 x' \r\n Tuple_Primitive              1000000    '    156 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Tuple_Object                 1000000    '    740 ms'  '     29 ms'  '     18 ms'  '    1.61 x' \r\n Composite_Intersect          1000000    '    797 ms'  '     26 ms'  '     14 ms'  '    1.86 x' \r\n Composite_Union              1000000    '    530 ms'  '     23 ms'  '     13 ms'  '    1.77 x' \r\n Math_Vector4                 1000000    '    240 ms'  '     22 ms'  '     11 ms'  '    2.00 x' \r\n Math_Matrix4                 1000000    '   1036 ms'  '     39 ms'  '     27 ms'  '    1.44 x' \r\n Array_Primitive_Number       1000000    '    248 ms'  '     20 ms'  '     12 ms'  '    1.67 x' \r\n Array_Primitive_String       1000000    '    227 ms'  '     22 ms'  '     13 ms'  '    1.69 x' \r\n Array_Primitive_Boolean      1000000    '    138 ms'  '     21 ms'  '     13 ms'  '    1.62 x' \r\n Array_Object_Unconstrained   1000000    '   5540 ms'  '     66 ms'  '     59 ms'  '    1.12 x' \r\n Array_Object_Constrained     1000000    '   5750 ms'  '    123 ms'  '    108 ms'  '    1.14 x' \r\n Array_Object_Recursive       1000000    '  21842 ms'  '   1771 ms'  '    599 ms'  '    2.96 x' \r\n Array_Tuple_Primitive        1000000    '    715 ms'  '     36 ms'  '     29 ms'  '    1.24 x' \r\n Array_Tuple_Object           1000000    '   3131 ms'  '     63 ms'  '     50 ms'  '    1.26 x' \r\n Array_Composite_Intersect    1000000    '   3064 ms'  '     44 ms'  '     35 ms'  '    1.26 x' \r\n Array_Composite_Union        1000000    '   2172 ms'  '     65 ms'  '     31 ms'  '    2.10 x' \r\n Array_Math_Vector4           1000000    '   1032 ms'  '     37 ms'  '     24 ms'  '    1.54 x' \r\n Array_Math_Matrix4           1000000    '   4859 ms'  '    114 ms'  '     86 ms'  '    1.33 x' \r\n\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n\r\n       (index)          Compiled    Minified   Compression \r\n\r\n typebox/compiler      '109.3 kb'  ' 48.5 kb'   '2.25 x'   \r\n typebox/errors        ' 54.8 kb'  ' 24.9 kb'   '2.20 x'   \r\n typebox/system        ' 12.1 kb'  '  6.1 kb'   '1.98 x'   \r\n typebox/type          ' 77.8 kb'  ' 32.8 kb'   '2.37 x'   \r\n typebox/value         '143.7 kb'  ' 61.2 kb'   '2.35 x'   \r\n typebox               ' 77.9 kb'  ' 32.8 kb'   '2.37 x'   \r\n\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-kXQqjqc6Gqg3tlekvD4WDV5uMX60qU4RDvYnnLhwnQ5LizfsnepGNk2SEMKjA7yrBczJTHheNLv3+ZHxle4f9g==","_from":"file:sinclair-typebox-0.32.0-dev-7.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-7_1701497420636_0.07099781757081036"},"_hasShrinkwrap":false},"0.32.0-dev-8":{"_id":"@sinclair/typebox@0.32.0-dev-8","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"0de661481d98eeac1f2128c3ef9eb8c10c254b97","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-8.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-KdEUKCaVC8cWVOEx+GYxQbwe/SrfeLoY7dmSSVtmw6ddDkl+InwT3kPlHziNzHhOetyzDiV7isFekiXWUzj19Q==","_from":"file:sinclair-typebox-0.32.0-dev-8.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-8_1701498329852_0.5090859952407734"},"_hasShrinkwrap":false},"0.32.0-dev-9":{"_id":"@sinclair/typebox@0.32.0-dev-9","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"54f1c18407d418a71e5189c6bc8b2a2b9ccc450a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-9.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-8bewiPy/yWFu7y2BIM4RCgOdaMd7Ei7bGxVMcTeeVMijbS1DNzMDqgbL6pVKVWcYtFXnqc5yiAQdMJ7MtT7qOg==","_from":"file:sinclair-typebox-0.32.0-dev-9.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-9_1701508003148_0.8089861599615353"},"_hasShrinkwrap":false},"0.32.0":{"_id":"@sinclair/typebox@0.32.0","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"17b6003a99f34686cc28d50c3ee2a68c9b3d6099","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-FdBgO+ib0JCSPtq55cDva/5xd55vfAAyTXWVLCaTAFzNjVPaR5lNRKoEzMHTtArELEaHNs4E6WmdNJIY+gUoZw==","_from":"file:sinclair-typebox-0.32.0.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0_1703221645352_0.7914765093974809"},"_hasShrinkwrap":false},"0.32.1":{"_id":"@sinclair/typebox@0.32.1","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"082ce58e8fc9200a1056e76a467bf8ae1ffcf33e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.1.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-DJKtxrcKL5MqUc5Gr0w+m/744wXhinq3d3hrRokNz4I9v5JbQCJleYqaQGfFwgkeZKHh01abFevbWX44CmUy1w==","_from":"file:sinclair-typebox-0.32.1.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.1_1703306657818_0.866481235770802"},"_hasShrinkwrap":false},"0.32.2":{"_id":"@sinclair/typebox@0.32.2","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"11ced43441a33757e9857e21dff60ce2f693eac9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.2.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-QnCMPXH56cA/hYiHGZSm1nvopFisrubJu4gYTWAapT66ieo3yroPc6hLYFieAs+D9ZLJuD910adm117xZplsOQ==","_from":"file:sinclair-typebox-0.32.2.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.2_1703420273718_0.037704388134492284"},"_hasShrinkwrap":false},"0.32.3":{"_id":"@sinclair/typebox@0.32.3","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.3","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ccc2ae8b59f9a7e8e1f6aea0965ef8ee2c7796c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.3.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-o1OzDySkCSEobAEAVS1SGrzznes9KqPOC3arGfH5rQhOIeokLQYLKQmy68lr979BmPr43v4m9d85ttUSRpHdFA==","_from":"file:sinclair-typebox-0.32.3.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.3_1703431817312_0.7447103019296877"},"_hasShrinkwrap":false},"0.32.4":{"_id":"@sinclair/typebox@0.32.4","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.4","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"94b8744215c1f54f38df9bd33626ef821ce66ca3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.4.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-Q2Pex6H+HGuyxIGuFadkpqwtjZFXiVZlvy1rVX9XgAzUrDmUDEM69M2c4CkWUgMJ1NaFPvUf+cMBljY96GJVNQ==","_from":"file:sinclair-typebox-0.32.4.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.4_1703822784271_0.14906610378893315"},"_hasShrinkwrap":false},"0.32.5":{"_id":"@sinclair/typebox@0.32.5","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"7f5995e2abc02be4e9fa38b58987b77e0bfe5ead","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.5.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-0M6FyxZwIEu/Ly6W+l7iYqiZQYJ8khLOJGzg+cxivNKRKqk9hctcuDC0UYI7B9vNgycExA8w40m4M3yDKW37RA==","_from":"file:sinclair-typebox-0.32.5.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.5_1704426622807_0.991759221016931"},"_hasShrinkwrap":false},"0.32.6":{"_id":"@sinclair/typebox@0.32.6","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.6","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"b3a7c5290ce6f713924f29ffad0bfdf0db4c1b6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.6.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-mgcPAfLZEL2B/hrF+vPDdwwZ1MR0UuALvz+tI2zx7IYHfREmua3C82XsYgkwxCCJKpO3ibTje4QrHYrOAHWhxA==","_from":"file:sinclair-typebox-0.32.6.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.6_1704858995315_0.9069802485019476"},"_hasShrinkwrap":false},"0.32.7":{"_id":"@sinclair/typebox@0.32.7","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.7","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"05822cf21091ddca245c24aa9163bb7384db5c1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.7.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-XI+xC3gBLkto5nigJpqxF63uth+3t5PQt3o/yWFvvzuXax1nvRKlm5iSorgyZiT70REsGHk6i4EYeFaONFWwbQ==","_from":"file:sinclair-typebox-0.32.7.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.7_1704884773591_0.2363028479624656"},"_hasShrinkwrap":false},"0.32.8":{"_id":"@sinclair/typebox@0.32.8","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.8","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"9d1559d1dfe8e7f75004cbbb2037d9d0085fef44","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.8.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-ifqNG6GBr0QRao2Vy+2P2WzxkOnpGmHfZCFXWwuR/0elH4h79mGXN8mEYwnJ2qGEr7MGgfqvf8Njwj4dBGFMBA==","_from":"file:sinclair-typebox-0.32.8.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.8_1704888224150_0.7265404898731502"},"_hasShrinkwrap":false},"0.32.9":{"_id":"@sinclair/typebox@0.32.9","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.9","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"025f05fa16aea3357f78cdcdbecbd6047de87673","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.9.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-6oeJJPTIb0y3cs713HmXmXSx3WRWgid74KICYL9blOhNFuAcAB18dDWfATgcgzynfpF5xDzHGxEVbDYYr6nvgg==","_from":"file:sinclair-typebox-0.32.9.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.9_1705071871399_0.7575111929761458"},"_hasShrinkwrap":false},"0.32.10":{"_id":"@sinclair/typebox@0.32.10","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.10","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"346ee6b68242142a28e01d72b42521b43a005156","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.10.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-CZwwK09fdC/uKPD/cCJbNBLPQww3gYl5bYu86cqfziPXTVatUGU/o+vqu84gDGuIDoQRIvCB0Uj0MvcgsCsb8g==","_from":"file:sinclair-typebox-0.32.10.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.10_1705510851908_0.6690640622086526"},"_hasShrinkwrap":false},"0.32.11":{"_id":"@sinclair/typebox@0.32.11","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.11","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"b0ec8db3b178dfd237e07b0f952cff08e6f7a16d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.11.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-YtmrPo85LgWnw12GEwfdu44P/I7GsU6r/7PNHDxToHEIJxZk0+c3pZQBBj9ElP2uB2UwG2H2aazB+UHDG4iC1w==","_from":"file:sinclair-typebox-0.32.11.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.11_1705775592972_0.4731341080164333"},"_hasShrinkwrap":false},"0.32.12":{"_id":"@sinclair/typebox@0.32.12","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.12","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"6e0fef781f9ec6709d6c6c7e38984c8e7af3a1da","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.12.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-uKRQW9a+alkPwZMzQk6W8cCZC117kZJZ3GQx3Yn9unu2oWX09PxEsyMF7D9tuvoH8se1hIZqLRja+FtU7HKGhQ==","_from":"file:sinclair-typebox-0.32.12.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.12_1705817671730_0.8824180790747733"},"_hasShrinkwrap":false},"0.32.13":{"_id":"@sinclair/typebox@0.32.13","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.13","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"1b9bf6de7319d17bfb6e34b9b5b2051ba6c71278","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.13.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-6gfhrgov2RWxPIlGyFcCVn1DejhmQvObIiBIx/Qx3FRnxlLS/RuoyDxK1hhhVU+S5+1Xmul32QALLErVfinyxw==","_from":"file:sinclair-typebox-0.32.13.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.13_1706219567676_0.3333706276843005"},"_hasShrinkwrap":false},"0.32.14":{"_id":"@sinclair/typebox@0.32.14","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.14","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ef0a4ed981515fd430cadfb65cb6c2719a0b5539","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.14.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-EC77Mw8huT2z9YlYbWfpIQgN6shZE1tH4NP4/Trig8UBel9FZNMZRJ42ubJI8PLor2uIU+waLml1dce5ReCOPg==","_from":"file:sinclair-typebox-0.32.14.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.14_1707621652940_0.6247011545994094"},"_hasShrinkwrap":false},"0.32.15":{"_id":"@sinclair/typebox@0.32.15","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.15","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"92dcdc12907f7c0f6d954ba3700b5bb888d2eb34","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.15.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-5Lrwo7VOiWEBJBhHmqNmf3TPB9ll8gcEshvYJyAIJyCZ2PF48MFOtiDHJNj8+FsNcqImaQYmxVkKBCBlyAa/wg==","_from":"file:sinclair-typebox-0.32.15.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.15_1709279116128_0.6695122325566814"},"_hasShrinkwrap":false},"0.32.16":{"_id":"@sinclair/typebox@0.32.16","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.16","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"1c5f3a0007aa751dfc382f977a0994c648489849","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.16.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-jNsVbv3jV58KBSXIhnEOuEI6mquQbW72HcDDEAHH22qvCaiwGozcaLbL4NEfInMqkDZ0FLFctjOGx4ysxVY8Lw==","_from":"file:sinclair-typebox-0.32.16.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.16_1710869311784_0.7095818671313754"},"_hasShrinkwrap":false},"0.32.17":{"_id":"@sinclair/typebox@0.32.17","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.17","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"4b9795a5c42c84a03d27f0f466be87149a8e326e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.17.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-jgY31gR1xtOB9XpGo+xqrq6K3ssdEyCPKSrB6uRUPNuZ26L5S4u8Qi+bhiNa6PbJklozEoFZvbev7SoQ9ffuAA==","_from":"file:sinclair-typebox-0.32.17.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.17_1710928055554_0.2750633725638476"},"_hasShrinkwrap":false},"0.32.18":{"_id":"@sinclair/typebox@0.32.18","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.18","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"6d342310d85a993edec9a32fce9eb3d03d2bb008","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.18.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-ioMK5TA5YOloYf/GcnF+1fT4eTvowJes2j7Pm0Ivlm9xq61keqQw/XtbQQnPG8O4uq2y2DDenU8OqNc93xn11Q==","_from":"file:sinclair-typebox-0.32.18.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.18_1711007365247_0.9585034567983084"},"_hasShrinkwrap":false}},"time":{"created":"2023-01-13T12:58:58Z","modified":"2024-03-21T11:49:50Z","0.8.0":"2023-01-13T12:58:58Z","0.8.1":"2023-01-13T12:58:58Z","0.9.0":"2023-01-13T12:58:58Z","0.9.1":"2023-01-13T12:58:58Z","0.9.2":"2023-01-13T12:58:58Z","0.9.3":"2023-01-13T12:58:58Z","0.9.4":"2023-01-13T12:58:58Z","0.9.5":"2023-01-13T12:58:58Z","0.9.6":"2023-01-13T12:58:58Z","0.9.7":"2023-01-13T12:58:58Z","0.9.8":"2023-01-13T12:58:58Z","0.9.9":"2023-01-13T12:58:58Z","0.9.10":"2023-01-13T12:58:58Z","0.9.11":"2023-01-13T12:58:58Z","0.9.12":"2023-01-13T12:58:58Z","0.9.13":"2023-01-13T12:58:58Z","0.9.14":"2023-01-13T12:58:58Z","0.9.15":"2023-01-13T12:58:58Z","0.9.16":"2023-01-13T12:58:58Z","0.10.0":"2023-01-13T12:58:58Z","0.10.1":"2023-01-13T12:58:58Z","0.11.0":"2023-01-13T12:58:58Z","0.12.0":"2023-01-13T12:58:58Z","0.12.1":"2023-01-13T12:58:58Z","0.12.2":"2023-01-13T12:58:58Z","0.12.3":"2023-01-13T12:58:58Z","0.12.4":"2023-01-13T12:58:58Z","0.12.5":"2023-01-13T12:58:58Z","0.12.6":"2023-01-13T12:58:58Z","0.12.7":"2023-01-13T12:58:58Z","0.12.8":"2023-01-13T12:58:58Z","0.12.9":"2023-01-13T12:58:58Z","0.14.0":"2023-01-13T12:58:58Z","0.14.1":"2023-01-13T12:58:58Z","0.15.0":"2023-01-13T12:58:58Z","0.16.0":"2023-01-13T12:58:58Z","0.16.1":"2023-01-13T12:58:58Z","0.16.2":"2023-01-13T12:58:58Z","0.16.3":"2023-01-13T12:58:58Z","0.16.4":"2023-01-13T12:58:58Z","0.16.5":"2023-01-13T12:58:58Z","0.16.6":"2023-01-13T12:58:58Z","0.16.7":"2023-01-13T12:58:58Z","0.17.0":"2023-01-13T12:58:58Z","0.17.1":"2023-01-13T12:58:58Z","0.17.2":"2023-01-13T12:58:58Z","0.17.3":"2023-01-13T12:58:58Z","0.17.4":"2023-01-13T12:58:58Z","0.17.5":"2023-01-13T12:58:58Z","0.17.6":"2023-01-13T12:58:58Z","0.17.7":"2023-01-13T12:58:58Z","0.17.8":"2023-01-13T12:58:58Z","0.18.0":"2023-01-13T12:58:58Z","0.18.1":"2023-01-13T12:58:58Z","0.19.0":"2023-01-13T12:58:58Z","0.19.1":"2023-01-13T12:58:58Z","0.19.2":"2023-01-13T12:58:58Z","0.20.0":"2023-01-13T12:58:58Z","0.20.1":"2023-01-13T12:58:58Z","0.20.2":"2023-01-13T12:58:58Z","0.20.3":"2023-01-13T12:58:58Z","0.20.4":"2023-01-13T12:58:58Z","0.20.5":"2023-01-13T12:58:58Z","0.20.6":"2023-01-13T12:58:58Z","0.21.0":"2023-01-13T12:58:58Z","0.21.1":"2023-01-13T12:58:58Z","0.21.2":"2023-01-13T12:58:58Z","0.22.0":"2023-01-13T12:58:58Z","0.22.1":"2023-01-13T12:58:58Z","0.23.0":"2023-01-13T12:58:58Z","0.23.1":"2023-01-13T12:58:58Z","0.23.2":"2023-01-13T12:58:58Z","0.23.3":"2023-01-13T12:58:58Z","0.23.4":"2023-01-13T12:58:58Z","0.23.5":"2023-01-13T12:58:58Z","0.24.0":"2023-01-13T12:58:58Z","0.24.1":"2023-01-13T12:58:58Z","0.24.2":"2023-01-13T12:58:58Z","0.24.3":"2023-01-13T12:58:58Z","0.24.4":"2023-01-13T12:58:58Z","0.24.5":"2023-01-13T12:58:58Z","0.24.6":"2023-01-13T12:58:58Z","0.24.7":"2023-01-13T12:58:58Z","0.24.8":"2023-01-13T12:58:58Z","0.24.9":"2023-01-13T12:58:58Z","0.24.10":"2023-01-13T12:58:58Z","0.24.11":"2023-01-13T12:58:58Z","0.24.12":"2023-01-13T12:58:58Z","0.24.13":"2023-01-13T12:58:58Z","0.24.14":"2023-01-13T12:58:58Z","0.24.15":"2023-01-13T12:58:58Z","0.24.16":"2023-01-13T12:58:58Z","0.24.17":"2023-01-13T12:58:58Z","0.24.18":"2023-01-13T12:58:58Z","0.24.19":"2023-01-13T12:58:58Z","0.24.20":"2023-01-13T12:58:58Z","0.24.21":"2023-01-13T12:58:58Z","0.24.22":"2023-01-13T12:58:58Z","0.24.23":"2023-01-13T12:58:58Z","0.24.24":"2023-01-13T12:58:58Z","0.24.25":"2023-01-13T12:58:58Z","0.24.26":"2023-01-13T12:58:58Z","0.24.27":"2023-01-13T12:58:58Z","0.24.28":"2023-01-13T12:58:58Z","0.24.29":"2023-01-13T12:58:58Z","0.24.30":"2023-01-13T12:58:58Z","0.24.31":"2023-01-13T12:58:58Z","0.24.32":"2023-01-13T12:58:58Z","0.24.33":"2023-01-13T12:58:58Z","0.24.34":"2023-01-13T12:58:58Z","0.24.35":"2023-01-13T12:58:58Z","0.24.36":"2023-01-13T12:58:58Z","0.24.37":"2023-01-13T12:58:58Z","0.24.38":"2023-01-13T12:58:58Z","0.24.39":"2023-01-13T12:58:58Z","0.24.40":"2023-01-13T12:58:58Z","0.24.41":"2023-01-13T12:58:58Z","0.24.42":"2023-01-13T12:58:58Z","0.24.43":"2023-01-13T12:58:58Z","0.24.44":"2023-01-13T12:58:58Z","0.24.45":"2023-01-13T12:58:58Z","0.24.46":"2023-01-13T12:58:58Z","0.24.47":"2023-01-13T12:58:58Z","0.24.48":"2023-01-13T12:58:58Z","0.24.49":"2023-01-13T12:58:58Z","0.24.50":"2023-01-13T12:58:58Z","0.24.51":"2023-01-13T12:59:09Z","0.25.0":"2023-01-13T12:58:58Z","0.25.1":"2023-01-13T12:58:58Z","0.25.2":"2023-01-13T12:58:58Z","0.25.3":"2023-01-13T12:58:58Z","0.25.4":"2023-01-13T12:58:58Z","0.25.5":"2023-01-13T12:58:58Z","0.25.6":"2023-01-13T12:58:58Z","0.25.7":"2023-01-13T12:58:58Z","0.25.8":"2023-01-13T12:58:58Z","0.25.9":"2023-01-13T12:58:58Z","0.25.10":"2023-01-13T12:58:58Z","0.25.11":"2023-01-13T12:58:58Z","0.25.12":"2023-01-13T12:58:58Z","0.25.13":"2023-01-13T12:58:58Z","0.25.14":"2023-01-13T12:58:58Z","0.25.15":"2023-01-13T12:58:58Z","0.25.16":"2023-01-13T12:58:58Z","0.25.17":"2023-01-13T12:58:58Z","0.25.18":"2023-01-13T12:58:58Z","0.25.19":"2023-01-13T12:58:58Z","0.25.20":"2023-01-13T12:58:58Z","0.25.21":"2023-01-19T08:51:07Z","0.25.22":"2023-02-15T08:51:09Z","0.25.23":"2023-02-16T11:52:16Z","0.25.24":"2023-03-24T16:54:22Z","0.26.0-dev":"2023-03-17T17:39:19Z","0.26.0-dev.1":"2023-03-18T08:50:22Z","0.26.0-dev.2":"2023-03-18T11:46:03Z","0.26.0-dev.3":"2023-03-19T05:47:47Z","0.26.0-dev.4":"2023-03-19T11:53:16Z","0.26.0-dev.5":"2023-03-20T08:52:30Z","0.26.0":"2023-03-21T17:53:06Z","0.26.1":"2023-03-22T20:57:09Z","0.26.2":"2023-03-23T08:47:42Z","0.26.3":"2023-03-24T05:45:17Z","0.26.4":"2023-03-26T08:47:34Z","0.26.5":"2023-03-27T05:38:53Z","0.26.6":"2023-03-28T17:51:12Z","0.26.7":"2023-03-29T05:48:11Z","0.26.8":"2023-03-29T20:44:05Z","0.27.0":"2023-04-08T17:58:23Z","0.27.1":"2023-04-10T11:42:48Z","0.27.2":"2023-04-10T23:42:47Z","0.27.3":"2023-04-11T08:46:03Z","0.27.4":"2023-04-12T14:52:56Z","0.27.5":"2023-04-14T02:43:47Z","0.27.6":"2023-04-14T05:51:16Z","0.27.7":"2023-04-14T08:41:24Z","0.27.8":"2023-08-07T20:04:47Z","0.28.0":"2023-04-20T23:52:11Z","0.28.1":"2023-04-20T23:52:11Z","0.28.2":"2023-04-21T14:59:44Z","0.28.3":"2023-04-21T23:45:05Z","0.28.4":"2023-04-22T02:53:57Z","0.28.5":"2023-04-23T05:49:40Z","0.28.6":"2023-04-25T11:48:37Z","0.28.7":"2023-04-27T08:50:37Z","0.28.8":"2023-04-28T11:39:50Z","0.28.9":"2023-05-01T14:40:55Z","0.28.10":"2023-05-13T17:49:08Z","0.28.11":"2023-05-17T05:46:25Z","0.28.12":"2023-05-25T05:57:45Z","0.28.13":"2023-05-26T05:56:27Z","0.28.14":"2023-05-29T20:48:57Z","0.28.15":"2023-06-10T09:01:43Z","0.28.16":"2023-06-20T08:48:11Z","0.28.17":"2023-06-21T17:57:45Z","0.28.18":"2023-06-22T05:48:39Z","0.28.19":"2023-06-26T20:53:12Z","0.28.20":"2023-06-27T08:48:20Z","0.29.0":"2023-07-02T14:48:16Z","0.29.1":"2023-07-02T20:48:54Z","0.29.2":"2023-07-03T23:54:39Z","0.29.3":"2023-07-03T23:54:39Z","0.29.4":"2023-07-06T02:54:04Z","0.29.5":"2023-07-18T17:52:02Z","0.29.6":"2023-07-18T17:52:02Z","0.30.0-dev-1":"2023-07-28T17:46:16Z","0.30.0-dev-2":"2023-07-28T17:46:16Z","0.30.0-dev-3":"2023-07-28T20:50:21Z","0.30.0-dev-4":"2023-07-28T20:50:21Z","0.30.0-dev-5":"2023-07-31T08:44:45Z","0.30.0-dev-6":"2023-07-31T08:44:45Z","0.30.0-dev-7":"2023-07-31T14:58:48Z","0.30.0":"2023-08-01T08:50:22Z","0.30.1":"2023-08-02T11:51:27Z","0.30.2":"2023-08-02T11:51:27Z","0.30.3":"2023-08-05T08:49:46Z","0.30.4":"2023-08-05T14:45:30Z","0.31.0-dev-1":"2023-08-08T23:57:03Z","0.31.0-dev-2":"2023-08-08T23:57:03Z","0.31.0":"2023-08-11T23:46:50Z","0.31.1":"2023-08-14T05:44:56Z","0.31.2":"2023-08-22T20:44:45Z","0.31.3":"2023-08-25T08:49:18Z","0.31.4":"2023-08-26T08:42:20Z","0.31.5":"2023-08-27T08:59:38Z","0.31.6":"2023-08-29T11:53:58Z","0.31.7":"2023-08-29T20:41:59Z","0.31.8":"2023-08-30T20:53:08Z","0.31.9":"2023-09-03T17:48:25Z","0.31.10":"2023-09-04T20:49:04Z","0.31.11":"2023-09-05T17:50:35Z","0.31.12":"2023-09-05T17:50:35Z","0.31.13":"2023-09-05T20:44:48Z","0.31.14":"2023-09-05T20:44:48Z","0.31.15":"2023-09-14T08:45:05Z","0.31.16":"2023-09-25T08:57:55Z","0.31.17":"2023-09-26T08:47:14Z","0.31.18":"2023-10-17T17:59:32Z","0.31.19":"2023-10-25T23:44:13Z","0.31.20":"2023-10-26T14:53:35Z","0.31.21":"2023-10-29T14:55:57Z","0.31.22":"2023-11-02T20:51:14Z","0.31.23":"2023-11-07T20:49:40Z","0.31.24":"2023-11-15T11:51:25Z","0.31.25":"2023-11-15T17:50:19Z","0.31.26":"2023-11-18T14:46:16Z","0.31.27":"2023-11-19T23:42:59Z","0.31.28":"2023-11-20T17:42:18Z","0.32.0-dev-1":"2023-11-30T14:47:29Z","0.32.0-dev-10":"2023-12-02T14:40:54Z","0.32.0-dev-11":"2023-12-02T17:54:09Z","0.32.0-dev-12":"2023-12-03T20:49:56Z","0.32.0-dev-13":"2023-12-04T11:55:05Z","0.32.0-dev-14":"2023-12-05T17:51:36Z","0.32.0-dev-15":"2023-12-06T17:54:03Z","0.32.0-dev-16":"2023-12-07T11:41:24Z","0.32.0-dev-17":"2023-12-07T11:41:24Z","0.32.0-dev-18":"2023-12-08T11:46:29Z","0.32.0-dev-19":"2023-12-08T14:50:01Z","0.32.0-dev-2":"2023-11-30T17:57:46Z","0.32.0-dev-20":"2023-12-08T20:44:37Z","0.32.0-dev-21":"2023-12-10T08:47:48Z","0.32.0-dev-22":"2023-12-10T17:40:46Z","0.32.0-dev-23":"2023-12-10T17:40:46Z","0.32.0-dev-24":"2023-12-11T11:49:21Z","0.32.0-dev-25":"2023-12-12T08:55:06Z","0.32.0-dev-26":"2023-12-12T11:47:43Z","0.32.0-dev-27":"2023-12-13T02:47:03Z","0.32.0-dev-28":"2023-12-14T08:40:51Z","0.32.0-dev-3":"2023-11-30T17:57:46Z","0.32.0-dev-4":"2023-12-02T05:40:58Z","0.32.0-dev-5":"2023-12-02T08:50:50Z","0.32.0-dev-6":"2023-12-02T08:50:50Z","0.32.0-dev-7":"2023-12-02T11:50:21Z","0.32.0-dev-8":"2023-12-02T11:50:21Z","0.32.0-dev-9":"2023-12-02T14:40:54Z","0.32.0":"2023-12-22T08:51:56Z","0.32.1":"2023-12-23T08:41:36Z","0.32.2":"2023-12-24T17:51:11Z","0.32.3":"2023-12-24T20:45:21Z","0.32.4":"2023-12-29T08:48:01Z","0.32.5":"2024-01-05T08:47:56Z","0.32.6":"2024-01-10T08:47:48Z","0.32.7":"2024-01-10T14:43:15Z","0.32.8":"2024-01-10T17:44:23Z","0.32.9":"2024-01-12T20:47:17Z","0.32.10":"2024-01-17T20:42:49Z","0.32.11":"2024-01-20T23:54:37Z","0.32.12":"2024-01-21T11:45:06Z","0.32.13":"2024-01-26T02:56:27Z","0.32.14":"2024-02-11T08:42:25Z","0.32.15":"2024-03-01T11:45:15Z","0.32.16":"2024-03-19T20:40:35Z","0.32.17":"2024-03-20T14:54:47Z","0.32.18":"2024-03-21T11:49:50Z"}}
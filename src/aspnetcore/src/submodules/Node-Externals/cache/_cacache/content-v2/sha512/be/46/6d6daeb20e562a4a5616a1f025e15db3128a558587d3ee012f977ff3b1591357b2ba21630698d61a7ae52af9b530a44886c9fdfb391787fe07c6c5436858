{"_id":"@sinclair/typebox","_rev":"8e209da0-c1ae-493d-bb39-e438a5a42748","name":"@sinclair/typebox","dist-tags":{"latest":"0.32.18","dev":"0.32.0-dev-28"},"versions":{"0.8.0":{"_id":"@sinclair/typebox@0.8.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.8.0","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"npm run spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"b075e04c6e1eb3c997ce50f4638606b0a44f3515","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.8.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.8.0.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.8.0_1583359911043_0.034058186348479236"},"_hasShrinkwrap":false},"0.8.1":{"_id":"@sinclair/typebox@0.8.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.8.1","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e891f05bb706e0feedf5a09b6e3e4592114b2495","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.8.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.8.1.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.8.1_1583363401145_0.2970624065230636"},"_hasShrinkwrap":false},"0.9.0":{"_id":"@sinclair/typebox@0.9.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.0","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5aabed0a3a2205f5dad9f0a88b104752d7c02eed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.0.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.0_1583375400842_0.6495084434058633"},"_hasShrinkwrap":false},"0.9.1":{"_id":"@sinclair/typebox@0.9.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.1","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"59169451613fee4d4fc97754f6632cbf35774a7a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.1.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.1_1583375876361_0.4468361164738972"},"_hasShrinkwrap":false},"0.9.2":{"_id":"@sinclair/typebox@0.9.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.2","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"fbc48a03e5125398731d1bd9e59ac250095da54d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.2.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.2.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.2_1583468250488_0.44867105115684347"},"_hasShrinkwrap":false},"0.9.3":{"_id":"@sinclair/typebox@0.9.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.3","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"228b5aa00fc839ae9865a890ce2a36d4f7605ad1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.3.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.3.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.3_1583491102475_0.5985503932480156"},"_hasShrinkwrap":false},"0.9.4":{"_id":"@sinclair/typebox@0.9.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.4","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"80c8ed73682f59a0ece23430f87fc72beb11adcf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.4.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.4.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.4_1583498609810_0.9033757547056813"},"_hasShrinkwrap":false},"0.9.5":{"_id":"@sinclair/typebox@0.9.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.5","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"261591913fe6a76de36e478c39b640c3c7783335","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.5.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.5.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.5_1583509471723_0.6820419851638333"},"_hasShrinkwrap":false},"0.9.6":{"_id":"@sinclair/typebox@0.9.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.6","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5135f299ef19fa63dbd148ea9d60d6d6387ff74b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.6.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.6.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.6_1583514677014_0.9003093816850498"},"_hasShrinkwrap":false},"0.9.7":{"_id":"@sinclair/typebox@0.9.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.7","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"3c029f03bc6da4c34f989779e3f9c23a30cac9d3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.7.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.7.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.13.7","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.7_1583563424129_0.8510498241402402"},"_hasShrinkwrap":false},"0.9.8":{"_id":"@sinclair/typebox@0.9.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.8","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"48ddf8dd686702d2635146193347ddfe3860b102","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.8.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.8.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.8_1583644980404_0.25037394753850983"},"_hasShrinkwrap":false},"0.9.9":{"_id":"@sinclair/typebox@0.9.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.9","homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^5.2.0","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e4c74ac66eff8f86127eaa8e7e8645117d7e5a13","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.9.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.9.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.9_1584007727813_0.24434255104374758"},"_hasShrinkwrap":false},"0.9.10":{"_id":"@sinclair/typebox@0.9.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.10","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"42d7c39b605f679c96806cdb6c201eb3832dd6c5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.10.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.10.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.10_1585637031786_0.391635058577644"},"_hasShrinkwrap":false},"0.9.11":{"_id":"@sinclair/typebox@0.9.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.11","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e00974e013da43226bb0691d6a24b7e61e72926a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.11.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.11.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.11_1585637875266_0.47547938982304805"},"_hasShrinkwrap":false},"0.9.12":{"_id":"@sinclair/typebox@0.9.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.12","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"2e2edaa783a3a3734fd87ba3fd59a6e3d3e798e5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.12.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.12.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.12_1585662121351_0.37525665927037877"},"_hasShrinkwrap":false},"0.9.13":{"_id":"@sinclair/typebox@0.9.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.13","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"1536ae77fe3980d84922d95b51168529efb17b0f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.13.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.13.tgz","_nodeVersion":"12.3.1","_npmVersion":"6.14.2","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.13_1585838194388_0.057461177993584966"},"_hasShrinkwrap":false},"0.9.14":{"_id":"@sinclair/typebox@0.9.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.14","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"057e285ba686047a03a90a09045d3b01680a91f0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.14.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.14.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.14_1588575403097_0.9387609837301745"},"_hasShrinkwrap":false},"0.9.15":{"_id":"@sinclair/typebox@0.9.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.15","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.8.3","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"748db23ef34c81bdee56de3a8ebafa55ad12b083","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.15.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.15.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.15_1588994004640_0.015289996197237032"},"_hasShrinkwrap":false},"0.9.16":{"_id":"@sinclair/typebox@0.9.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.9.16","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"804b1a4b08f545ea98593c6e7e682679cf8fd5fc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.9.16.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.9.16.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.9.16_1589535296147_0.4033076836931868"},"_hasShrinkwrap":false},"0.10.0":{"_id":"@sinclair/typebox@0.10.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.10.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"ad83b7fc17cb6910f22ca80d96bbfd5106e35c72","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.10.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.10.0.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.10.0_1589783662994_0.4001287125325905"},"_hasShrinkwrap":false},"0.10.1":{"_id":"@sinclair/typebox@0.10.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.10.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^3.9.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"5239a7f3b3e51bab3c2838550639350126746079","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.10.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.10.1.tgz","_nodeVersion":"12.16.2","_npmVersion":"6.14.4","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.10.1_1590414990008_0.87007409594856"},"_hasShrinkwrap":false},"0.11.0":{"_id":"@sinclair/typebox@0.11.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.11.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"9e85f2dd1753d3e464582060d5f6a0f3b0b29b7b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.11.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.11.0.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.5","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.11.0_1602908743141_0.8280791332792752"},"_hasShrinkwrap":false},"0.12.0":{"_id":"@sinclair/typebox@0.12.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"72b742796487a8ad911f048a37f2b55dbc07625a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.0.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.0.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.0_1604170116743_0.7477237969510224"},"_hasShrinkwrap":false},"0.12.1":{"_id":"@sinclair/typebox@0.12.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"70a97c29498550279586d128185809e17e66f291","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.1.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.1.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.1_1604171665021_0.051200586153316685"},"_hasShrinkwrap":false},"0.12.2":{"_id":"@sinclair/typebox@0.12.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"7462ff99916fd8bb7c9c8abd81b44f71e590e172","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.2.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.2.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.2_1604227112292_0.4495630449154575"},"_hasShrinkwrap":false},"0.12.3":{"_id":"@sinclair/typebox@0.12.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"0add73c83ae77649fe9a5445efd89754c7138fd6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.3.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.3.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.3_1604582711962_0.9065093403811142"},"_hasShrinkwrap":false},"0.12.4":{"_id":"@sinclair/typebox@0.12.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"8d81f5e842da78b1ad860a9c6230dad95252d4de","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.4.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.4.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.4_1605120798397_0.4285299812299943"},"_hasShrinkwrap":false},"0.12.5":{"_id":"@sinclair/typebox@0.12.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"e77b76db44b878b40bf598f913fd62a501194926","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.5.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.5.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.5_1605439356050_0.36491103310682504"},"_hasShrinkwrap":false},"0.12.6":{"_id":"@sinclair/typebox@0.12.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"80273dc4e6fdaac53074b06a7e28db0cc804c00e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.6.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.6.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.6_1605490754173_0.4171287343015093"},"_hasShrinkwrap":false},"0.12.7":{"_id":"@sinclair/typebox@0.12.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.0.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4ff89150cabd1395fd8a7dc30c8a613fb6c626e1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.7.tgz"},"types":"./typebox.d.ts","_integrity":"","_from":"file:sinclair-typebox-0.12.7.tgz","_nodeVersion":"12.18.2","_npmVersion":"6.14.8","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.7_1605809372330_0.03457435847785506"},"_hasShrinkwrap":false},"0.12.8":{"_id":"@sinclair/typebox@0.12.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/ajv":"^1.0.0","@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^6.12.0","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a54bed6c7730d9c40b077c14310cd32d73e3ac5b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bJ/ZCkGKRW55pg3bkMfr4N7XDWQVTjPNhjXXAoEetpD+Sf/8ODUNTuqxHXjDSCDv+2EtDgyaE0kp7YNvXqcLVQ==","_from":"file:sinclair-typebox-0.12.8.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.8_1613870104931_0.6218090880840199"},"_hasShrinkwrap":false},"0.12.9":{"_id":"@sinclair/typebox@0.12.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.12.9","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4444c9bb2f98fcee693cbcb69256bd3dde8b4543","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.12.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-JQzO2wlZ2wJdCft30wRMmxPcTEz4cDS4Hi2izVoFgGzTo5/eJKxCpklc2WTa7K24s7f3L5DKvhlC6RKcf2WNhA==","_from":"file:sinclair-typebox-0.12.9.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.12.9_1614241022383_0.9309834514913089"},"_hasShrinkwrap":false},"0.14.0":{"_id":"@sinclair/typebox@0.14.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.14.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"83277e5fad5294d607cf9f789cedab3fa9571843","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.14.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Y49c44s0zPcVbuUPAAlO3mAx7IUo5XDbWJrHOc7IcpuragP/dKdYOy4mOLktaiJ1ciBXXH82sGVdkjGaDssr8g==","_from":"file:sinclair-typebox-0.14.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.14.0_1615896987252_0.4688064491306243"},"_hasShrinkwrap":false},"0.14.1":{"_id":"@sinclair/typebox@0.14.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.14.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a306436ff4beba1e98e635f58d6625aa56b3de6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.14.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-SPm1ttNRHTK+kcJmkjqc0PwzCxhtre32lGcsdn6s+mXrpOm3RdjclBrRhE1/t96hRKb7qXrx/SHZoor4aEkI9Q==","_from":"file:sinclair-typebox-0.14.1.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.14.1_1615897222669_0.8195024516596479"},"_hasShrinkwrap":false},"0.15.0":{"_id":"@sinclair/typebox@0.15.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.15.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","example":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"b0cc1179f8af0d244a927bf8e071ad19ef199a17","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.15.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-lKSdEZJJxzK3ll8qaCBuU18/XMZR9Yt/awOuDugMATOyLLk7lCDcdiNs2wAN60/MSTpx94NfbfVTRLrP6frkHA==","_from":"file:sinclair-typebox-0.15.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.15.0_1615974883846_0.9454264424925964"},"_hasShrinkwrap":false},"0.16.0":{"_id":"@sinclair/typebox@0.16.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"a1e0af52f26b5006bba4703c405102419f9cbc48","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+5ucTvISuUyxE4yvSjpx5vZWThK/ya0MbOIgwxfhEdZSZje0v1xiGuZWAA/7/dcalu8WGKGopyf5fsHF4giiEg==","_from":"file:sinclair-typebox-0.16.0.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.0_1616266633122_0.3824878343413336"},"_hasShrinkwrap":false},"0.16.1":{"_id":"@sinclair/typebox@0.16.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"1534198931db61e5c630106909a02743376bef10","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-M2e35t7IKJYlIIvLAHYeAHAubdW5Dlb4v6lpeH630G7ebWv5nfJKQoCOMku7OngfScN936Z9y0ZD1r4NhRVWHQ==","_from":"file:sinclair-typebox-0.16.1.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.1_1617077407522_0.5305074916974941"},"_hasShrinkwrap":false},"0.16.2":{"_id":"@sinclair/typebox@0.16.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"f81ea9def0aaf3a7152c1b73d8db9122a37219da","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-fvGbn6K+gZY/aJDCdWiA/NmdIfSSXYDTs/8DMIxFGhbvDPPJSKpKam99SAygfJsAzfhN/SIh71GCiFPWrw33lQ==","_from":"file:sinclair-typebox-0.16.2.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.2_1617732034441_0.03358383816301269"},"_hasShrinkwrap":false},"0.16.3":{"_id":"@sinclair/typebox@0.16.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"2db54d30a8e1f47d2bc0a23b665c07e650e3b645","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-jWGmkmPtxiipL3zGuoq3aX5TIyXkqUXC9BrdwsAlxQ+ufzOgRhHuwBdKc6CuD98Sn8W7e0XdoJvOx6PhEAf3IQ==","_from":"file:sinclair-typebox-0.16.3.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.3_1618064815435_0.07936137507120855"},"_hasShrinkwrap":false},"0.16.4":{"_id":"@sinclair/typebox@0.16.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.1.3","@types/mocha":"^5.2.0","@types/node":"^13.7.7","ajv":"^7.1.1","ajv-formats":"^1.5.1","chai":"^4.1.2","mocha":"^7.1.1","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"90cc259857230476bf40765ee30f79ec6012fa4d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KMDgWZ+8kmaiHW/rbJfmxk8eUWOx2sflyeeYIVmAk0Nk3/GEkDW1QhyP2/eelsv/ZkqeNwlFoSMGxB0fb/TwKQ==","_from":"file:sinclair-typebox-0.16.4.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.4_1618116566297_0.4967920424996035"},"_hasShrinkwrap":false},"0.16.5":{"_id":"@sinclair/typebox@0.16.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"c5fea69bb29f1b2a72e4d87851d8b2461b47994f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.5.tgz"},"types":"./typebox.d.ts","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.5_1618284734612_0.41774579474672136"},"_hasShrinkwrap":false},"0.16.6":{"_id":"@sinclair/typebox@0.16.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"4ef0810c8b6c9ab2da9040da87cdb4d7d3108395","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZD2FapdV8rZweAa5wqBHN7yB3HyRJdY5ty1e8b2YQjw+j4WPYNZN3FbpDUFMXD6Cd51gickYEin3Q8YF2K7Q7g==","_from":"file:sinclair-typebox-0.16.6.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.6_1621308365772_0.5174433428929068"},"_hasShrinkwrap":false},"0.16.7":{"_id":"@sinclair/typebox@0.16.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.16.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"smoke-task clean","build":"smoke-task build","start":"smoke-task example","test":"smoke-task spec"},"directories":{},"devDependencies":{"@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","smoke-run":"^1.1.2","smoke-task":"^1.1.2","typescript":"^4.1.2","typescript-bundle":"^1.0.16"},"main":"./typebox.js","dist":{"shasum":"3187369b2ff237f57477ef155be4c992e592fa7c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.16.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d12AkLZJXD30hXBhJSgf33RqGO0NMHIDzsQPYfp6WGoaSuMnSGIUanII2OUbeZFnD/j3Nbl2zifgO2+5tPClCQ==","_from":"file:sinclair-typebox-0.16.7.tgz","_nodeVersion":"14.15.5","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.16.7_1621311113811_0.2830577939602723"},"_hasShrinkwrap":false},"0.17.0":{"_id":"@sinclair/typebox@0.17.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6ddb9286a49fdc5b36fcccb6ab2de56d97f0ffd3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cHkdl1XP2EUGQVnaVgWT48VTgwI695/+W9LrDn1qTudDtmkUK6dS+Da79jZUvSeRFqglQTmDrbiXyugDx0kD/A==","_from":"file:sinclair-typebox-0.17.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.0_1624690904125_0.7974732075309647"},"_hasShrinkwrap":false},"0.17.1":{"_id":"@sinclair/typebox@0.17.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"945392b4aaab513ec7899c48ab0040e9933b46b9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-rva9A1kYSDDmXnu/YfBNlW1RbZVJJo8rzY+9gytOxpG9FF+lgL/8JHK6gJsXA1mFjO8DF7+55BiR7MP+zQMLCA==","_from":"file:sinclair-typebox-0.17.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.1_1624693263513_0.07996416645691573"},"_hasShrinkwrap":false},"0.17.2":{"_id":"@sinclair/typebox@0.17.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6d3ad611ce284d14297787e3343860bddf2a5007","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-sma4R8zamJJlGWsDOtl41z4XVinREox85eVtfVJpFFBbFk9jyDcUgzXvYY1uZV8nRsMjXcngmxpw8SVww+0r3A==","_from":"file:sinclair-typebox-0.17.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.2_1625310277122_0.9412102957062185"},"_hasShrinkwrap":false},"0.17.3":{"_id":"@sinclair/typebox@0.17.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"c140a0b3c73e4636bc7c48bfc62838ec7d4f5f56","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PnELUAhjAXJRdCJsaG5/qLrjqzy4YO8cJUbGmLsalhYsGytS6dtKJ3wz5TsYW7syY0EjLmo8FjNP+W2DdYJLyQ==","_from":"file:sinclair-typebox-0.17.3.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.3_1625332396306_0.3208711351561717"},"_hasShrinkwrap":false},"0.17.4":{"_id":"@sinclair/typebox@0.17.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"ccbc7ec86114bb963b5f30e4cfbd58349184bb38","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KCm+wGleBbpuyqE6Tfx6HONkM6EzJOLqd+yQ0wCkMLVG3/7DUMcCjaxA33eRgmRjNY+NL+vpZF2HZRGYS4AUEw==","_from":"file:sinclair-typebox-0.17.4.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.4_1625332593974_0.7107073872915799"},"_hasShrinkwrap":false},"0.17.5":{"_id":"@sinclair/typebox@0.17.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"544db2ae049bd517d7549bd3a00e01ac83c075e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-HxRZzRNAOd9WkENToiWMJ1TrBbxI5UyNo4HzC/HhoQhbv/1gkdDvy5IQvaivddyiurw3rE0kmeousXS+eTyc6g==","_from":"file:sinclair-typebox-0.17.5.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.5_1625559008954_0.9201363237884765"},"_hasShrinkwrap":false},"0.17.6":{"_id":"@sinclair/typebox@0.17.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"56c59321b6007edaa0d5e81dade49b6df89cf1cb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YuqlXKWYZkzMDJphA8M2cN1U2MBUembu1wmRsUcagwLLH0L0/m+79iH4VQk+WKTmgvtF9cbD5mi+j4cmSPyUYQ==","_from":"file:sinclair-typebox-0.17.6.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.6_1625559234364_0.3814591768050357"},"_hasShrinkwrap":false},"0.17.7":{"_id":"@sinclair/typebox@0.17.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"fdb7fa1e3ef0f2f943c0bb8f375427c27fcda280","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-eu/XpQu20LHTjMnuOkUlTYwombrAF0xLAvDNV2MVR6RHXfWRp7iEEz87Eef0FEkiitNeEoH4BtzLBKGAhfH7Ng==","_from":"file:sinclair-typebox-0.17.7.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.7_1625572234774_0.9448630897017243"},"_hasShrinkwrap":false},"0.17.8":{"_id":"@sinclair/typebox@0.17.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.17.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"9cef4c284d2437368d90fc36a002549681e7263b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.17.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-enm8ET5E31RYbzGYPB9p+CvRzURrNEUCS2EvUxYQCdnDJw6wBpn6N+TK7iIumCc6fTRKgoOX1InJO2cQYZA4mg==","_from":"file:sinclair-typebox-0.17.8.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.17.8_1626342888438_0.3249582033709708"},"_hasShrinkwrap":false},"0.18.0":{"_id":"@sinclair/typebox@0.18.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.18.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.1.0","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"c7f31bd7ba59634dc7b2468a873b78553b680342","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.18.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VfCZfx5BAF+NpJV+XIKqvQvZbbXCKWyTk2QYbQ8GD2BN7ipnITaKTNdJGzFQ1fZn/+4eh8tlisaNA0RLxG8isg==","_from":"file:sinclair-typebox-0.18.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.18.0_1626801049293_0.5774701300342711"},"_hasShrinkwrap":false},"0.18.1":{"_id":"@sinclair/typebox@0.18.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.18.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"2d01fe5109dfa9b97188aa98081b4ef2c9a29beb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.18.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bl1omaQJ7RKyEmhfQGGIqv9XxwngP0P1MpUFhyBQZcLpFQyNu213DRva8NMorkf+YpX833IUZL5VrqSkaCOL7Q==","_from":"file:sinclair-typebox-0.18.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.18.1_1627044214754_0.17873792461189275"},"_hasShrinkwrap":false},"0.19.0":{"_id":"@sinclair/typebox@0.19.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"6725fbdb1dce93d9ccff3b82d487277a1aa980a5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+jOcKa/HVQgT+UuSsupGPdyJ3L9xr399hz9DyVgbks0AESYPkOkQNgP+CwySEjqqJcgiL0AzIPz9Q6+P4WxLOw==","_from":"file:sinclair-typebox-0.19.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.0_1627211715254_0.6394675172760469"},"_hasShrinkwrap":false},"0.19.1":{"_id":"@sinclair/typebox@0.19.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"705f1ba1c007cad2a465ce9fa892ae0adb026d6e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VQW34PPRWPX4d7RpHLqkMDQhcrcWVmZtVVh0KAblBbUAaosapAb7I2G07hmkxhCYNkWAAN9tXWtb9BFSDXN4JA==","_from":"file:sinclair-typebox-0.19.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.1_1627211922333_0.10952095893133129"},"_hasShrinkwrap":false},"0.19.2":{"_id":"@sinclair/typebox@0.19.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.19.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"3a526594d6f652ada78e6c00be84463ae48047e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.19.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0U/RVPZQw1QxhrbKV0o281ZWI1Ve3osJnyEYnwOp3slydIQHyXumbJANJeNv9BqABDiHWlmzsxSVopPHMvt3Aw==","_from":"file:sinclair-typebox-0.19.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.19.2_1627212356267_0.12027053311482261"},"_hasShrinkwrap":false},"0.20.0":{"_id":"@sinclair/typebox@0.20.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.1.2"},"main":"./typebox.js","dist":{"shasum":"f0e620ea3a4f82b2fbbd16d89a92fbe5c869ba90","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-qFKbghRt4sutWEQYchceiErGVhunbCoCssCcOjLXN6vtMMyaycCQGGEgd1kGyueucONnnO+nNYUXLXATU35j7w==","_from":"file:sinclair-typebox-0.20.0.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.0_1627406584783_0.6071930571258608"},"_hasShrinkwrap":false},"0.20.1":{"_id":"@sinclair/typebox@0.20.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"7a4636960dc31d95d26d831f177d39d58682744e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-uJdygXCzArkBE7sjqPljYaCKcWP3frqye46DLYJCjGgWKAKlMdMdO2g4K33uxAiRdnTAItBu6k8nQzpVLE9dxA==","_from":"file:sinclair-typebox-0.20.1.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.1_1627409280763_0.06865223521231445"},"_hasShrinkwrap":false},"0.20.2":{"_id":"@sinclair/typebox@0.20.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"9b43ce3b143083b4aa67bab8653005c506a6a158","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-AL347st6ZPLjvN/Pncs1O1C6MXOPgcEmgbt7+AQVfXPhwMtedn9EpzvjbvyveDPBF6iuwSZN9D6UVgPJybUgng==","_from":"file:sinclair-typebox-0.20.2.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.2_1627467495986_0.24338420645370618"},"_hasShrinkwrap":false},"0.20.3":{"_id":"@sinclair/typebox@0.20.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"597c30cbb2c20c6ee2ceaa9fd5146c1af968eb99","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8qopxzSWCfjKtVrjbFmIoQRJI/x7fVXQc0JrV3XJw4lzaREpRUh7OBsRcxube3T3RXxv1ztPH+BSTqwPx4peng==","_from":"file:sinclair-typebox-0.20.3.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.3_1627495156970_0.4899278222479988"},"_hasShrinkwrap":false},"0.20.4":{"_id":"@sinclair/typebox@0.20.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"d1c68a9aa320f2e1ae77d1bed595c03b3853176b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cWmUFRMdGanzrrDzE1uHyWG0FeDGf8EWtzxbGQ0zD+Dad8Y4f0xSBe1kK+27TWQKQKcC9/GuOTysmOqaQfK3Aw==","_from":"file:sinclair-typebox-0.20.4.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.4_1627496927349_0.32029499895032143"},"_hasShrinkwrap":false},"0.20.5":{"_id":"@sinclair/typebox@0.20.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.12.1","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^8.3.2","typescript":"^4.3.5"},"main":"./typebox.js","dist":{"shasum":"d5828bbb8237876d7937dd229e3dac71d1220771","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-WNiVFcS1rdz5KyEutpl3Wmp/AwSQHBUFTyJz7KqMLkpLhOXCj1dnvMytBM6uMS5OTwhwwq877T7EC4vDGrX5Eg==","_from":"file:sinclair-typebox-0.20.5.tgz","_nodeVersion":"16.2.0","_npmVersion":"7.5.2","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.5_1629432705504_0.5948338219699616"},"_hasShrinkwrap":false},"0.20.6":{"_id":"@sinclair/typebox@0.20.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.20.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"98b08aafb4556b85e9ba78d5075aed23cf04eca1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.20.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8/y8a2Xerrfym1W0lNtFe2+1OsWSao5S7A3b2375+vcAIh0pdf6Sgz4FH2dwpVnH9bJeIiq+RvT5pbEgM9Q28Q==","_from":"file:sinclair-typebox-0.20.6.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.20.6_1637232143952_0.6897018829331245"},"_hasShrinkwrap":false},"0.21.0":{"_id":"@sinclair/typebox@0.21.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"fd0fbdcc760a00354a99218ce78e00c05e78fead","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-UVtAtxCHhixACtlZAvRCS3pBNOPGwYkpY6zpHbSEyOBuTmYunGTzXlnsD/+Hu61l9xdF8mqyebg8lnzMOr/Vlg==","_from":"file:sinclair-typebox-0.21.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.0_1637263354464_0.8851163995993059"},"_hasShrinkwrap":false},"0.21.1":{"_id":"@sinclair/typebox@0.21.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","test":"hammer task spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"e89170c12da6369a2099f47d5dfcdb1b5239f5db","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-pdD7wcj7WOu0F7s2ITLGJjwS8y+Vzbh96cHi5PccKFD/0NV4HmnW+1rVQhSnQ0g9K6zUGiHu1JZIasdljGWHaw==","_from":"file:sinclair-typebox-0.21.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.1_1637298148539_0.654900276264692"},"_hasShrinkwrap":false},"0.21.2":{"_id":"@sinclair/typebox@0.21.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.21.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.7","@types/chai":"^4.2.16","@types/mocha":"^8.2.2","@types/node":"^14.14.37","ajv":"^8.6.2","ajv-formats":"^2.0.2","chai":"^4.3.4","mocha":"^9.1.2","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"d23a42adafc482f4893994e22916b0b54e18c23d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.21.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YeGOsWyjmGS26VxfvxbDgO7In4em8riCI5hEe/NnjM72ifoLQNUeHxwFNufXVIcaaPEK4fCV+fYoLKgmpPKjsA==","_from":"file:sinclair-typebox-0.21.2.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.21.2_1637311102264_0.5226018427532988"},"_hasShrinkwrap":false},"0.22.0":{"_id":"@sinclair/typebox@0.22.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.22.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"503448f3b76d86f87342739621610e766103a5ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.22.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KEB7UiEMw43/x2urIAlUD1bu0JUTiTNcEMcGVM0pYq2mAHg8CbVQHMP1xGSCbPWpmoej/oaz3lGLO7XZN9AN9Q==","_from":"file:sinclair-typebox-0.22.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.22.0_1637572808394_0.7562884039335187"},"_hasShrinkwrap":false},"0.22.1":{"_id":"@sinclair/typebox@0.22.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.22.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"718162cb38d5cf732ea348821cce00d88a10d2b3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.22.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cYkZ5oYd/KrzwcocLtGI4QRi6oniV4eP8IEefEhZp8YjLhrsrHiiaeChs8a9T/YKIlIjHMoxoOCWOUkZ/vviNw==","_from":"file:sinclair-typebox-0.22.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.22.1_1637656814938_0.17706449883164566"},"_hasShrinkwrap":false},"0.23.0":{"_id":"@sinclair/typebox@0.23.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"67da07e1e3be6d18f861728ba0a83cc7fee462e3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-G8+yjtQlXVBOSWqsi8ezmmt2Y4VyR+FJOvYV/3DwKcJiAvyU+WcSA9chS5X3H+2VN3L/MEHm/puenGo9S6kbcw==","_from":"file:sinclair-typebox-0.23.0.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.0_1638210430014_0.15507066709494866"},"_hasShrinkwrap":false},"0.23.1":{"_id":"@sinclair/typebox@0.23.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"14a945aa26a41a875a219db00b293c0bbe4fb804","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XsmyWfps86gFmZhK97HDesbCe/pR+8qf/VveZaADI6oCk0cHGq6WeKdUHM/a8NeSetv/vpUf19ubwU34C2PVWw==","_from":"file:sinclair-typebox-0.23.1.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.1_1638559461750_0.1201321149718595"},"_hasShrinkwrap":false},"0.23.2":{"_id":"@sinclair/typebox@0.23.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.15.8","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"387c20aacf9c9f7e55f8b6fc80ebef946ca818d8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Q2+xTM1zfzYt0TnSFQooG8RY3i39qi3VZRfTS75h5V2qGqqk6ZHHTTtuB1fBtolPRO8+cNCT7nny9bdFmW787w==","_from":"file:sinclair-typebox-0.23.2.tgz","_nodeVersion":"14.18.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.2_1640184987543_0.15811760414373"},"_hasShrinkwrap":false},"0.23.3":{"_id":"@sinclair/typebox@0.23.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.2.22","@types/mocha":"^9.0.0","@types/node":"^16.11.9","ajv":"^8.8.2","ajv-formats":"^2.1.1","chai":"^4.3.4","mocha":"^9.1.3","tsd":"^0.19.0","typescript":"^4.5.2"},"main":"./typebox.js","dist":{"shasum":"83e127d1c5f9d79d76004a1b36f7b483f5056918","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zIjVOx3n08kLSAE6o4BhOUtgkpvbrZmR6B+lJLl/tP78GB7KpLrOK15FC9sKaWZHLtnObIDAQV5kihLbisgYYw==","_from":"file:sinclair-typebox-0.23.3.tgz","_nodeVersion":"16.13.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.3_1642896498399_0.7081304169967535"},"_hasShrinkwrap":false},"0.23.4":{"_id":"@sinclair/typebox@0.23.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"6ff93fd2585ce44f7481c9ff6af610fbb5de98a4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0/WqSvpVbCBAV1yPeko7eAczKbs78dNVAaX14quVlwOb2wxfKuXCx91h4NrEfkYK9zEnyVSW4JVI/trP3iS+Qg==","_from":"file:sinclair-typebox-0.23.4.tgz","_nodeVersion":"16.13.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.4_1645103577540_0.8454530339502178"},"_hasShrinkwrap":false},"0.23.5":{"_id":"@sinclair/typebox@0.23.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.23.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","build":"hammer task build","example":"hammer task example","spec":"hammer task spec","spec:types":"hammer task spec_types","spec:schemas":"hammer task spec_schemas","test":"npm run spec"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"93f7b9f4e3285a7a9ade7557d9a8d36809cbc47d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.23.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-AFBVi/iT4g20DHoujvMH1aEDn8fGJh4xsRGCP6d8RpLPMqsNPvW01Jcn0QysXTsg++/xj25NmJsGyH9xug/wKg==","_from":"file:sinclair-typebox-0.23.5.tgz","_nodeVersion":"16.13.1","_npmVersion":"8.5.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.23.5_1651218905582_0.6088332311992679"},"_hasShrinkwrap":false},"0.24.0":{"_id":"@sinclair/typebox@0.24.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.0","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"07f233080e6840f41c4fe8eadb172102a7328092","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-UsOG+42zjQrmAAdxXitRI43fUYNwef9bq5jSwWKOe9q0NWrR1zkWe1ceXSYwuf3tkC7rJitiT0kHWMkCKiSfzA==","_from":"file:sinclair-typebox-0.24.0.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.0_1656508059136_0.7187567085541802"},"_hasShrinkwrap":false},"0.24.1":{"_id":"@sinclair/typebox@0.24.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.1","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"b4ff200fb4f18dfd15c53e984d8801e2c8df1526","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-v59jW0KQIy4iMP0Pn7gcpQ48YDXa9vOopsRhaPWmsStTxaVNYIqFY3eK6y4PU+53hlQoaQ8pAxU4cPIaMFEJwg==","_from":"file:sinclair-typebox-0.24.1.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.1_1656514181831_0.0032912113645298113"},"_hasShrinkwrap":false},"0.24.2":{"_id":"@sinclair/typebox@0.24.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.2","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"29f290d20a144ee47106206309eceb1488166d41","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-EpdWGQtmnZbXMioI90e+JSL0DnYINu8OX4ruVEXhoXAbgUgSmkpz5FWTiLai1sfg8AfpX8XDCLF50gzlEcBv2A==","_from":"file:sinclair-typebox-0.24.2.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.2_1656604011535_0.5667895059651575"},"_hasShrinkwrap":false},"0.24.3":{"_id":"@sinclair/typebox@0.24.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.3","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"dd74a836233305bca4078c23d7ab926ad53e8ed6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/h/IFTmwpLQeHbtkPb7DUr/jtl7VW8xZgIIAZOK5vRpKQRuJPUdJY1ltAR2Ba7n8vQLP4porDyg20oobIvXcUQ==","_from":"file:sinclair-typebox-0.24.3.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.3_1656646724930_0.6549617611621041"},"_hasShrinkwrap":false},"0.24.4":{"_id":"@sinclair/typebox@0.24.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.4","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"a22231479a4291924e424729f92ab5cb394eace4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KpJwpDfG4o4DM+zm4k4hGVH5pRRTgmxptFzU6QtXTKsuNW8UPkxapEOUDXMnBj+FhsfVHM3fUVAvAVj0ki6lAQ==","_from":"file:sinclair-typebox-0.24.4.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.4_1656662213259_0.867266456483494"},"_hasShrinkwrap":false},"0.24.5":{"_id":"@sinclair/typebox@0.24.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.5","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"b43b65329e2b78d4260997899d28965171315afc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Te3ZdSGjvNg9knge4ZvHpAn4Pjr5jV1GfKKWJtZzWtyDB0tIWIVVJLqaD0sXFyWqFnKKzjzFsRbDRvd/5ejawQ==","_from":"file:sinclair-typebox-0.24.5.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.5_1656668737338_0.8168874372446935"},"_hasShrinkwrap":false},"0.24.6":{"_id":"@sinclair/typebox@0.24.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.6","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"ea71148b019cd40cc1a51f644abac33cad81a2d2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ziqHFbpqzAuXtDFx4hwwPR1fm6SyfzhQoYXkmLZq4rFzRob1TDtjhI68rV84V7voqhb0yrwVJSwbOc3nm+0avQ==","_from":"file:sinclair-typebox-0.24.6.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.6_1656735761379_0.011198753759123159"},"_hasShrinkwrap":false},"0.24.7":{"_id":"@sinclair/typebox@0.24.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.7","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"633f3f223db742469bc59221bd636f18bbc2a964","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-K/sf9yfEU3Z8rmd2t4HCPLsatI5Fovzf+aODyCez5RMqgy/ZLv1bHLobFnXH90UAi9UBYUXWCxYBsUznSqZYkg==","_from":"file:sinclair-typebox-0.24.7.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.7_1656739273782_0.5094830765394163"},"_hasShrinkwrap":false},"0.24.8":{"_id":"@sinclair/typebox@0.24.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.8","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"2e41fb3b48f1985749aee8fe7ca16c15a5b021fb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4Cf8AFKViEeTifdga3mQxNmWbLPQJ0Ab5nAODCWulf58rWEqFEiBBsqc/RoRdugW0QyMwl0pZTKDyrVhGEYOYA==","_from":"file:sinclair-typebox-0.24.8.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.8_1656914288705_0.38293575683211767"},"_hasShrinkwrap":false},"0.24.9":{"_id":"@sinclair/typebox@0.24.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.9","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"5e66a3c9adff81efe06a80dd189fca2810987588","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ID/my8r4g0fp9aefo+bmEApgEgG6Sid42i5bmBXXXGqOK00aTMjHTNwSV2zTt7ddJn0IcevUxS7JzFn0WjwrGg==","_from":"file:sinclair-typebox-0.24.9.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.9_1656934898640_0.5637896161342006"},"_hasShrinkwrap":false},"0.24.10":{"_id":"@sinclair/typebox@0.24.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.10","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"a2459ccf83cfe83085022563b13d119ba5df73b6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+0jinSndYKPW9xGO/hj8M/y+i8g9c7RBiXp+st9ZWaYe9Fn2yNC1uQ1JwSHhm6hyQPdriC4R069K9AGGP5ChYg==","_from":"file:sinclair-typebox-0.24.10.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.10_1656994275698_0.03916689453030098"},"_hasShrinkwrap":false},"0.24.11":{"_id":"@sinclair/typebox@0.24.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.11","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.9.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"e9f4aa5056e367ed419ff60c26808f385688b521","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-oHAgeyktMgCNPu4+oDAlwgqcHYn8piH8Nw0OngLeu2HIJM7EFxzU4VrK8ACrgbXAiXWedXL4nrfMb+bALMWD6w==","_from":"file:sinclair-typebox-0.24.11.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.11_1657175119472_0.19069613441115174"},"_hasShrinkwrap":false},"0.24.12":{"_id":"@sinclair/typebox@0.24.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.12","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"0b964ab272909a41bc45d8c0454d2b04fa259b1a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-FZs52BqpKMXNzUPCLpyWjMVVkNAuN//YpgARUp8wWfBhFyt12a2C9hAITyD9Ursiju4XsP4Lk6GNJcNllHwbgw==","_from":"file:sinclair-typebox-0.24.12.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.12_1657274789279_0.4967427577895378"},"_hasShrinkwrap":false},"0.24.13":{"_id":"@sinclair/typebox@0.24.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.13","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"4705841912ea7ddfb8795bac3db8df17948f5277","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-MzpUqze7Gmj1ZNNanFov1QtyXu+aPYV6KZILEqgKnKlbMTgS6HRZ6aAlaEmrFPHSN4KG+yoOACDkJqA+/oXwFQ==","_from":"file:sinclair-typebox-0.24.13.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.13_1657372780221_0.027267967886738687"},"_hasShrinkwrap":false},"0.24.14":{"_id":"@sinclair/typebox@0.24.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.14","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.5.5"},"main":"./typebox.js","dist":{"shasum":"463720b9209ddf519454ba46e27f86915c8f1b04","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+dld7HhmwiDD8nEYqdUQ/OpCMmiFnuu0huWbZ18hY6RL7ByIc4tdvvEDXPJJyCbbyaKR0R7P6gWmmdpv4btX7A==","_from":"file:sinclair-typebox-0.24.14.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.14_1657440012523_0.5778926619289857"},"_hasShrinkwrap":false},"0.24.15":{"_id":"@sinclair/typebox@0.24.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.15","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"423bc636cf47d039aa79f20cf5fc248576931290","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VtII20dRdDzJy7hk9Zh2u8wbNhFeOm7P8S9dpVIagkP7cJLDeOP5YRdSWbiZF29nkxFXhI6Axj/pZbRkT2lTTg==","_from":"file:sinclair-typebox-0.24.15.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.15_1657470943181_0.23398543355131052"},"_hasShrinkwrap":false},"0.24.16":{"_id":"@sinclair/typebox@0.24.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.16","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"d911c31b9b604084c725385369a4f1de52382517","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aWqQhrghjG38ymiiIPDhH5M2skStc5CepTBC6m0tYIdKqm5CDDPf0niJ8gC2vrRkCW6tjmJnoMucrp2j+dJvkg==","_from":"file:sinclair-typebox-0.24.16.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.16_1657471764960_0.4763035063154706"},"_hasShrinkwrap":false},"0.24.17":{"_id":"@sinclair/typebox@0.24.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.17","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","tsd":"^0.19.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"5e5ac39cc54bdcbb002555a0bdfc79f5188e63e4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KyXzbBBYly+wSwbhPTKecqIWFST/anAXTlA2o23rDUMzVnFUrDyC0Gk96yL8zQw5O5OqdqALomdih6wwSdRc2Q==","_from":"file:sinclair-typebox-0.24.17.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.17_1657535071738_0.24289360767777013"},"_hasShrinkwrap":false},"0.24.18":{"_id":"@sinclair/typebox@0.24.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.18","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"962c259235908047cf4367df31bec953a2e0d1c2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-H16DM4E7fyY5X6ggtYDViOHCrHLKs8/khz6akaJ3FN+l2a/pAp1lLy921KqwR4eP40tJWaaDogU+stCnuurahQ==","_from":"file:sinclair-typebox-0.24.18.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.18_1657611092323_0.33665250524951484"},"_hasShrinkwrap":false},"0.24.19":{"_id":"@sinclair/typebox@0.24.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.19","keywords":["json-schema","typescript","static-types","runtime-typechecking"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"5297278e0d8a1aea084685a3216074910ac6c113","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gHJu8cdYTD5p4UqmQHrxaWrtb/jkH5imLXzuBypWhKzNkW0qfmgz+w1xaJccWVuJta1YYUdlDiPHXRTR4Ku0MQ==","_from":"file:sinclair-typebox-0.24.19.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.19_1657688215343_0.586927087906"},"_hasShrinkwrap":false},"0.24.20":{"_id":"@sinclair/typebox@0.24.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"11a657875de6008622d53f56e063a6347c51a6dd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-kVaO5aEFZb33nPMTZBxiPEkY+slxiPtqC7QX8f9B3eGOMBvEfuMfxp9DSTTCsRJPumPKjrge4yagyssO4q6qzQ==","_from":"file:sinclair-typebox-0.24.20.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.20_1657875101153_0.9598524901428978"},"_hasShrinkwrap":false},"0.24.21":{"_id":"@sinclair/typebox@0.24.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"f2e435ac4c1919ae89c2b693a0d4213d09899290","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-II2SIjvxBVJmrGkkZYza/BqNjwx3PWROIA8CZ0/Hn7LV0Mv0CVpZxoyHGBVsQqfFLMv9DmArIeRHTwo76bE6oA==","_from":"file:sinclair-typebox-0.24.21.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.21_1658915961048_0.05577125064089539"},"_hasShrinkwrap":false},"0.24.22":{"_id":"@sinclair/typebox@0.24.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.22","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"0da18e6e75701d6609c7c68fe18002bb1f47345f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-JsBe3cOFpNZ6yjBYnXKhcENWy5qZE3PQZwExQ5ksA/h8qp4bwwxFmy07A6bC2R6qv6+RF3SfrbQTskTwYNTXUQ==","_from":"file:sinclair-typebox-0.24.22.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.22_1659059392761_0.6928466614416711"},"_hasShrinkwrap":false},"0.24.23":{"_id":"@sinclair/typebox@0.24.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"ce30c80e93a69e8f18fd77f8995b3afdb6bb9974","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dhpD3rztStcXgwuhJhg10CA2YJfwx799VlzZpuEi/8ijKriQST6rEpA8mDYlyaVkxWlTiVFme1s1fc6rx8+BhA==","_from":"file:sinclair-typebox-0.24.23.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.23_1659348705517_0.457725377235221"},"_hasShrinkwrap":false},"0.24.24":{"_id":"@sinclair/typebox@0.24.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"1c201951882b0954b0689b0047584776e0053c1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.24.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YaQ015FMwcveHbmI7w7X19f979CUCut2sf1gryWVV5nkAFr598jUhSpByKaC2BSBtJLT9lrDBfEo0Y2IFNipMQ==","_from":"file:sinclair-typebox-0.24.24.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.24_1659372851814_0.4984057280664649"},"_hasShrinkwrap":false},"0.24.25":{"_id":"@sinclair/typebox@0.24.25","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.25","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"61234177664cf161b621443a18f9e6714f757e2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.25.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Z0b1gkfeHzRQen7juqXIZ4P2nvI6vZV+m/PhxBlVsNH/jSg2FuqJ+x4haFFIbbct6LMA7m6x2sBob/Giecj09A==","_from":"file:sinclair-typebox-0.24.25.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.25_1659375414468_0.08659865534070899"},"_hasShrinkwrap":false},"0.24.26":{"_id":"@sinclair/typebox@0.24.26","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.26","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"84f9e8c1d93154e734a7947609a1dc7c7a81cc22","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.26.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1ZVIyyS1NXDRVT8GjWD5jULjhDyM3IsIHef2VGUMdnWOlX2tkPjyEX/7K0TGSH2S8EaPhp1ylFdjSjUGQ+gecg==","_from":"file:sinclair-typebox-0.24.26.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.26_1659412722826_0.890120941889464"},"_hasShrinkwrap":false},"0.24.27":{"_id":"@sinclair/typebox@0.24.27","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.27","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.16.3","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"d55643516a1546174e10da681a8aaa81e757452d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.27.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-K7C7IlQ3zLePEZleUN21ceBA2aLcMnLHTLph8QWk1JK37L90obdpY+QGY8bXMKxf1ht1Z0MNewvXxWv0oGDYFg==","_from":"file:sinclair-typebox-0.24.27.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.27_1659602158872_0.053863671780329136"},"_hasShrinkwrap":false},"0.24.28":{"_id":"@sinclair/typebox@0.24.28","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.28","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.0","@types/chai":"^4.3.0","@types/mocha":"^9.1.0","@types/node":"^17.0.12","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.5","mocha":"^9.2.0","prettier":"^2.7.1","typescript":"^4.7.4"},"main":"./typebox.js","dist":{"shasum":"15aa0b416f82c268b1573ab653e4413c965fe794","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.28.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dgJd3HLOkLmz4Bw50eZx/zJwtBq65nms3N9VBYu5LTjJ883oBFkTyXRlCB/ZGGwqYpJJHA5zW2Ibhl5ngITfow==","_from":"file:sinclair-typebox-0.24.28.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.28_1660321975386_0.24358698133975487"},"_hasShrinkwrap":false},"0.24.29":{"_id":"@sinclair/typebox@0.24.29","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.29","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"acf9799f22e04cb13146e3946f71561d5e33ff5b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.29.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ohR2BnUhkCCUyiYnw3Rp/MspBLXImFMnrhSjdbCmkL7RgwfFwfLKJi7sPl7Ifq93UfZq7PCyFLcyO+D/qI5Jyg==","_from":"file:sinclair-typebox-0.24.29.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.29_1661807382053_0.9060904271778507"},"_hasShrinkwrap":false},"0.24.30":{"_id":"@sinclair/typebox@0.24.30","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.30","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"70d94661a065373b7330cc2dce79424bc8e957a1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.30.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-YTlUf5iAfDZEVmI4SWOBGcxpufY2XQhWqSwyLeR2Qg1pkjlM6+Pvc+9MA/+zUaiEFuuX3F3KdhqS5bcasgLc5A==","_from":"file:sinclair-typebox-0.24.30.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.30_1661808091434_0.8675767253573601"},"_hasShrinkwrap":false},"0.24.31":{"_id":"@sinclair/typebox@0.24.31","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.31","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"3f3752bc830a9daa4a0185573f0bf870089c3222","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.31.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-uWZaAsh9WFhcY1rWLLcMU/omiIIAQ/PmgqplaF6UWY6ULPH0ZO8hupJRAydzlTQZJIK3Voz8o8dYlEx+Cm6BAA==","_from":"file:sinclair-typebox-0.24.31.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.31_1661852125649_0.1806011388853752"},"_hasShrinkwrap":false},"0.24.32":{"_id":"@sinclair/typebox@0.24.32","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.32","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"214a03e430122d239a6414a5d5412c23964cafbd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.32.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-NWNTW284AOFhxgYofPef5IqDq6Y7ghZkZAkWJcUBp1r9ljfrFOKBDsiQJnLNp9tLcaSXFK9OgsS72W4RXe0jvw==","_from":"file:sinclair-typebox-0.24.32.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.32_1661930337600_0.40031395568692063"},"_hasShrinkwrap":false},"0.24.33":{"_id":"@sinclair/typebox@0.24.33","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.33","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"e7852f8cdd2fd93a9ea4de17a2dccd788a8bf50a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.33.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-c5p4Ib38ILOGfeYZWIu2Ms6EDdc2PGehzEYLevsvZ1njIt4Jt66E++4pjpBpgh+yJFj4ahnbKfYahOyLxvTBCw==","_from":"file:sinclair-typebox-0.24.33.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.33_1661968681124_0.7511750957402077"},"_hasShrinkwrap":false},"0.24.34":{"_id":"@sinclair/typebox@0.24.34","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.34","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"35b799cf98a203d1940c8ce06688f9a09fbc0f50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.34.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-x3ejWKw7rpy30Bvm6U0AQMOHdjqe2E3YJrBHlTxH0KFsp77bBa+MH324nJxtXZFpnTy/JW2h5HPYVm0vG2WPnw==","_from":"file:sinclair-typebox-0.24.34.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.34_1661970917660_0.845779932585563"},"_hasShrinkwrap":false},"0.24.35":{"_id":"@sinclair/typebox@0.24.35","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.35","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7b5ca127aefe3ed482bb60f874bebbe3143e82f5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.35.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-iN6ehuDndiTiDz2F+Orv/+oHJR+PrGv+38oghCddpsW4YEZl5qyLsWxSwYUWrKEOfjpGtXDFW6scJtjpzSLeSw==","_from":"file:sinclair-typebox-0.24.35.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.35_1662307420328_0.637072737663672"},"_hasShrinkwrap":false},"0.24.36":{"_id":"@sinclair/typebox@0.24.36","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.36","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8d44cf34fac7226c61f57b174c0b4b47652a2f8f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.36.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-KxQQnSP+5x+JbBbnz0ZwCK0KQ06Wsvt8eYCUsBkt+h80+iXaVJzfDQ9GmAcypfUk/HrQL+l1Hjz1Fjeznfs+Uw==","_from":"file:sinclair-typebox-0.24.36.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.36_1662492763720_0.5023570082155973"},"_hasShrinkwrap":false},"0.24.37":{"_id":"@sinclair/typebox@0.24.37","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.37","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"3ea4cf8f3cf8a943c17baf5bb7b33587afa5f76b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.37.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8xuD57tNMHs7R0YUzFp0xqIVOTJDbFHnEN/JTej5d5o/dTx4OSsURKTT9dkWl6ghMk4zs3AYe1bi7UK0NnJ4oA==","_from":"file:sinclair-typebox-0.24.37.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.37_1662496509637_0.761011118057821"},"_hasShrinkwrap":false},"0.24.38":{"_id":"@sinclair/typebox@0.24.38","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.38","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7f68d9c5775c4c2cec0524b3b990263dd009c968","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.38.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-IbYB6vdhLFmzGEyXXEdFAJKyq7S4/RsivkgxNzs/LzwYuUJHmeNQ0cHkjG/Yqm6VgUzzZDLMZAf0XgeeaZAocA==","_from":"file:sinclair-typebox-0.24.38.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.38_1662541793172_0.5151982994861768"},"_hasShrinkwrap":false},"0.24.39":{"_id":"@sinclair/typebox@0.24.39","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.39","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"21d0c56c295a00e391e20a88a48c11d4a1210ac5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.39.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GqtkxoAjhTzoMwFg/JYRl+1+miOoyvp6mkLpbMSd2fIQak2KvY00ndlXxxkDBpuCPYkorZeEZf0LEQn9V9NRVQ==","_from":"file:sinclair-typebox-0.24.39.tgz","_nodeVersion":"18.4.0","_npmVersion":"8.12.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.39_1662678347047_0.6267658698062895"},"_hasShrinkwrap":false},"0.24.40":{"_id":"@sinclair/typebox@0.24.40","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.40","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"00ee9b48537b147f6ffc80ebc28ab16d6016ed5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.40.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Xint60L8rF0+nRy+6fCjW9jQMmu7fTpbwTBrXZiK6eq/RHDJS7LvWX/0oXC8O7fCePmrY/XdfaTv2HiUDeCq4g==","_from":"file:sinclair-typebox-0.24.40.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.40_1662843973863_0.42825022842374283"},"_hasShrinkwrap":false},"0.24.41":{"_id":"@sinclair/typebox@0.24.41","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.41","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"45470b8bae32a28f1e0501066d0bacbd8b772804","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.41.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-TJCgQurls4FipFvHeC+gfAzb+GGstL0TDwYJKQVtTeSvJIznWzP7g3bAd5gEBlr8+bIxqnWS9VGVWREDhmE8jA==","_from":"file:sinclair-typebox-0.24.41.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.41_1663008300066_0.4697474671574682"},"_hasShrinkwrap":false},"0.24.42":{"_id":"@sinclair/typebox@0.24.42","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.42","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"a74b608d494a1f4cc079738e050142a678813f52","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.42.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d+2AtrHGyWek2u2ITF0lHRIv6Tt7X0dEHW+0rP+5aDCEjC3fiN2RBjrLD0yU0at52BcZbRGxLbAtXiR0hFCjYw==","_from":"file:sinclair-typebox-0.24.42.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.42_1663400920184_0.6415183789971715"},"_hasShrinkwrap":false},"0.24.43":{"_id":"@sinclair/typebox@0.24.43","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.43","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"2e2bce0e5e493aaf639beed0cd6c88cfde7dd3d7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.43.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1orQTvtazZmsPeBroJjysvsOQCYV2yjWlebkSY38pl5vr2tdLjEJ+LoxITlGNZaH2RE19WlAwQMkH/7C14wLfw==","_from":"file:sinclair-typebox-0.24.43.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.43_1664044907407_0.898384977300209"},"_hasShrinkwrap":false},"0.24.44":{"_id":"@sinclair/typebox@0.24.44","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.44","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"0a0aa3bf4a155a678418527342a3ee84bd8caa5c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.44.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ka0W0KN5i6LfrSocduwliMMpqVgohtPFidKdMEOUjoOFCHcOOYkKsPRxfs5f15oPNHTm6ERAm0GV/+/LTKeiWg==","_from":"file:sinclair-typebox-0.24.44.tgz","_nodeVersion":"18.4.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.44_1664394561505_0.19586846035770056"},"_hasShrinkwrap":false},"0.24.45":{"_id":"@sinclair/typebox@0.24.45","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.45","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"a2ea1d151276646e1c6498b06d4183c0b660d5c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.45.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tD/Zg4RR7/pVVPjgHjnbCeBshwj/4FYfkSwIew8/YmMOalXPilcQiQIbif7DR/SM/e2sZAmy4qrFKDtTjAvz8w==","_from":"file:sinclair-typebox-0.24.45.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.45_1665562222401_0.04729360562723528"},"_hasShrinkwrap":false},"0.24.46":{"_id":"@sinclair/typebox@0.24.46","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.46","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"57501b58023776dbbae9e25619146286440be34c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.46.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ng4ut1z2MCBhK/NwDVwIQp3pAUOCs/KNaW3cBxdFB2xTDrOuo1xuNmpr/9HHFhxqIvHrs1NTH3KJg6q+JSy1Kw==","_from":"file:sinclair-typebox-0.24.46.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.46_1665565152309_0.15009511973909162"},"_hasShrinkwrap":false},"0.24.47":{"_id":"@sinclair/typebox@0.24.47","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.47","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"530b67163714356f93e82bdb871e7db4b7bc564e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.47.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J4Xw0xYK4h7eC34MNOPQi6IkNxGRck6n4VJpWDzXIFVTW8I/D43Gf+NfWz/v/7NHlzWOPd3+T4PJ4OqklQ2u7A==","_from":"file:sinclair-typebox-0.24.47.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.47_1666104615693_0.5433373763742027"},"_hasShrinkwrap":false},"0.24.48":{"_id":"@sinclair/typebox@0.24.48","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.48","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"bd558c6059df563d49a4d94df8e8e0510b662e3f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.48.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-WPGpRNHbkOsfBDmh8QHU7a5NWzEuYNThST8x1cISvX0RpP+1+V8zjuJqNwGJkHGIlhdIIhv6qVYqXz2q5/gjAA==","_from":"file:sinclair-typebox-0.24.48.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.48_1666396498631_0.49574597891436323"},"_hasShrinkwrap":false},"0.24.49":{"_id":"@sinclair/typebox@0.24.49","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.49","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"7a3a5569fe9e4faa47d8019246d37541c2d7a058","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.49.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-qWgJVeCThMWTJSAZHyHDlHBkJY0LARFoq/96RH4oIFAwJptMwB3Isq62c4zRVRIAF2r4RMOc2WOhtOLj5C4InA==","_from":"file:sinclair-typebox-0.24.49.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.49_1666513726610_0.7686200519134401"},"_hasShrinkwrap":false},"0.24.50":{"_id":"@sinclair/typebox@0.24.50","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.50","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"35ee4db4ab8f3a8ff56490c51f92445d2776451e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.50.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-k8ETQOOQDg5FtK7y9KJWpsGLik+QlPmIi8zzl/dGUgshV2QitprkFlCR/AemjWOTyKn9UwSSGRTzLVotvgCjYQ==","_from":"file:sinclair-typebox-0.24.50.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.24.50_1666515742111_0.05366137589442843"},"_hasShrinkwrap":false},"0.24.51":{"_id":"@sinclair/typebox@0.24.51","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.24.51","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"645f33fe4e02defe26f2f5c0410e1c094eac7f5f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.24.51.tgz"},"types":"./typebox.d.ts"},"0.25.0":{"_id":"@sinclair/typebox@0.25.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"90babb116b331fabd7ac598092c21a4679ee3ee4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Eb0KGwpkjo2JGj3FM5X6HjXzTONm12RsWUNInY+pa53EzV3MlwFEOBvuhY2tW7wNWrkR4XIKoRgonkJZk4lG5Q==","_from":"file:sinclair-typebox-0.25.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.0_1666987341238_0.993780588977329"},"_hasShrinkwrap":false},"0.25.1":{"_id":"@sinclair/typebox@0.25.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8caa80c24e0be5f909ce2439a0600dae3937c23c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ij7duiwNUyqplvhAqBXJAHNAT+ozsyUhmC5mLO7PqyHOAk1G91d3ITF2h9LIDbYLP5PSTNYpcxYstU+4Y4i3aQ==","_from":"file:sinclair-typebox-0.25.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.1_1666991081635_0.5035445488242405"},"_hasShrinkwrap":false},"0.25.2":{"_id":"@sinclair/typebox@0.25.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8de5684b8ef7c46444d3ee54f6711d6f4e74aa6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QWjo2shO8oUWM6rSwIz7tUY8+WxP0fhUYQvaFA5eq+sECaQjQaRZIBXgWhWzzsB+lbgjljB1zRFfyX8mudn1gQ==","_from":"file:sinclair-typebox-0.25.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.2_1667219548150_0.8859022009937798"},"_hasShrinkwrap":false},"0.25.3":{"_id":"@sinclair/typebox@0.25.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"84517e087003ad1156807dc6a48422a1ed32d65b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zIxm0hEDwflBaa/hPjiRulXK+67sPp22V5jUwb3T58MitHBVGgM+cutxneeXY2vgj3990c4L06A0oKeZT+1hhw==","_from":"file:sinclair-typebox-0.25.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.3_1667892148418_0.016709778667588937"},"_hasShrinkwrap":false},"0.25.4":{"_id":"@sinclair/typebox@0.25.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"6ddb4fd0ef420bfd32b6b10460dbfcfe87c2b897","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4orhjT9lSj61BBH77hz3whIKZRnxNGiO3nKVheNfpXhmhUEWEMBRw5Go1IFRERYqH3afFlXJzElJOZpcG5b4Sw==","_from":"file:sinclair-typebox-0.25.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.4_1667982968451_0.914500510756804"},"_hasShrinkwrap":false},"0.25.5":{"_id":"@sinclair/typebox@0.25.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"8f8d6650efbe318db20616687278f7d2d37f7164","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cjauXt7Has9yaVcQ0c/DEckBTVimsty3ycyzpAJfQM/zTcfC4r6+CF8J/Ax7AHNxAhDA903OSe7Fs5TPFdLiLA==","_from":"file:sinclair-typebox-0.25.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.5_1667986063039_0.8602852731781716"},"_hasShrinkwrap":false},"0.25.6":{"_id":"@sinclair/typebox@0.25.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"1631c286161cdfeacf65e11654898c62a5b4a338","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZX6NlLpBZ13bovy93T2eEwnar7SzpKtI+ezEFa6g9o1ztYXMOCQaDfS/7PQuPH/8FNRGGU4o4Nv7i4eN77M+3w==","_from":"file:sinclair-typebox-0.25.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.6_1668079066728_0.20150445556475294"},"_hasShrinkwrap":false},"0.25.7":{"_id":"@sinclair/typebox@0.25.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"91653bc8e7d85c5c7d657a8baceb31b2e1db34b1","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-P1akWHXV7H4gl4mxM6ln/4Blk74QRbCW3kmiYkNai3nDpClxF2/rwElyuz/YjBfwgdcOiSiEcrQEtoNrUnUHgQ==","_from":"file:sinclair-typebox-0.25.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.7_1668080384388_0.378414048388116"},"_hasShrinkwrap":false},"0.25.8":{"_id":"@sinclair/typebox@0.25.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"882d969dfc433cbd362f1876f8ea29b743dc32d3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/7GXgMOCfnxpIov52cPetqQ7bxRBaTBJAgp04Se2UQB1J0vUfEOIMpn63cLc3S5JXDUflCWxELKDV8eiPpmUTQ==","_from":"file:sinclair-typebox-0.25.8.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.8_1668139965070_0.04553424337229672"},"_hasShrinkwrap":false},"0.25.9":{"_id":"@sinclair/typebox@0.25.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.7.13","ajv":"^8.11.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.8.2"},"main":"./typebox.js","dist":{"shasum":"e36fe28d002cb17d1ed245da465733d0b045b94d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-FDfpDJJ589OME6W01GUbPoNDovU72N8LPtCTopmRttzWpeDVNFefWzzJVXmL9lw7712kXgPfcyb3/AkGZfHNeg==","_from":"file:sinclair-typebox-0.25.9.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.9_1669121786421_0.02569458297374183"},"_hasShrinkwrap":false},"0.25.10":{"_id":"@sinclair/typebox@0.25.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"98b928abc37c57bafc98147b02a1e5ae76950163","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-B7yEaT5yPZUS7kL/Ogh94n7Rb7p1DJEjCqOaPMuwAy4XXnlZchFrxIeE5pbrPsHOn5NMhWZtOnKtksaNQzCq1A==","_from":"file:sinclair-typebox-0.25.10.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.10_1669355363228_0.6727215363154413"},"_hasShrinkwrap":false},"0.25.11":{"_id":"@sinclair/typebox@0.25.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"476bad310092de48af7a9807ecd75019ac01f3d7","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GgUJN0Drvh74i8gOl2S8SkHuAgkZJtzzd6EmfBVxpNDB6QmzXdZ3tyUt02Kr42X58as5I187CKiWpLCMJmdLbw==","_from":"file:sinclair-typebox-0.25.11.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.11_1670349507251_0.02501615056276907"},"_hasShrinkwrap":false},"0.25.12":{"_id":"@sinclair/typebox@0.25.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"3157d3be38a1df18f784640bb19739a38436366c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-xm46HDwYz69z8xcNh9esHYKpvhXmA02sD+K9cur6XZvwjZTSBJ8PNbK5xeSO0IYZqRzpxkXYsbpsF/hF0WdPew==","_from":"file:sinclair-typebox-0.25.12.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.12_1670587551634_0.5722623185062437"},"_hasShrinkwrap":false},"0.25.13":{"_id":"@sinclair/typebox@0.25.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"c12956684a9c57271bdf10e4686b8f85531f75af","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XiEwzYpUwE5y/k333Cy0Ujmxvw/mA4zIyEmwUyA0EDDik7ba8S/HClvz3ylOsABfYSj+/skQq4QJl0k/Z1eDLg==","_from":"file:sinclair-typebox-0.25.13.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.13_1670746429585_0.9806831578766027"},"_hasShrinkwrap":false},"0.25.14":{"_id":"@sinclair/typebox@0.25.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"2063552e614b77d5d4f2ae404449084d7e90172c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QHPtRqD95nGnJZHWolgKFNmpuY8gpqVEfyasUSJO78X62f4nKmxPbDjd8FpMmwj2J8d0gQWChLtuBtH4yw0qpA==","_from":"file:sinclair-typebox-0.25.14.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.14_1671457881070_0.005727986855571965"},"_hasShrinkwrap":false},"0.25.15":{"_id":"@sinclair/typebox@0.25.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"38d60f82e3b092043ea0fb52007de82ec040c35a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J0C9JoAFbuRx37ofnpv6ZDgPMFogUBgtVPiHyq69ictcS1E3onLWBrzxTJuByV5ngUyLEXymtYMf3TppNbJWLw==","_from":"file:sinclair-typebox-0.25.15.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.15_1671504435626_0.8804388901004891"},"_hasShrinkwrap":false},"0.25.16":{"_id":"@sinclair/typebox@0.25.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"daf07d14d93897d6f7849159d8242808b956b069","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-5sclbtYBKQ0W5hY8ovF/cBbQV+FWBZArd738hQpLgWUdlWyuOA0HOuYN178jUJRz0pXuL1+UYR+LCMvoR47osg==","_from":"file:sinclair-typebox-0.25.16.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.16_1671647711794_0.5478055902673016"},"_hasShrinkwrap":false},"0.25.17":{"_id":"@sinclair/typebox@0.25.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"77661d05d203f027745edaf92d3ab621c426ddc4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-OLQlcfNZn2Qy59LE7Fzt2dLAxvVx3F7GsAGpQPKWq1nsdzPpudaSNjwhrjc1HgtbidSxxJmSe7RNTbedFlSqkg==","_from":"file:sinclair-typebox-0.25.17.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.17_1673096700958_0.6526373102814131"},"_hasShrinkwrap":false},"0.25.18":{"_id":"@sinclair/typebox@0.25.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"e21e025d085ca3ecd41884c06f13cd3ebdad5c2a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-kJV6/P2PZmvcOY0V+Nm0pazyHMYYmuuKzTUZjnsyJHRdHRPQX/G53AwpA+39CP5k4rx2BIz3hJzRG0c8KtzLGQ==","_from":"file:sinclair-typebox-0.25.18.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.18_1673265372739_0.05607049293827315"},"_hasShrinkwrap":false},"0.25.19":{"_id":"@sinclair/typebox@0.25.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"714a62f4b6b4385dc89c7f8ff9aadf122f33feb0","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-q99nbqFtmyn/3mP53ORoG/hEQIh+zK0dR5nUr2eSor/SyxsNE5qHNuZHrbMXPYnv2MAZ/F+YyVOtGFqz3uY4rw==","_from":"file:sinclair-typebox-0.25.19.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.19_1673274550837_0.8368252918825929"},"_hasShrinkwrap":false},"0.25.20":{"_id":"@sinclair/typebox@0.25.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"6378757820642d6a56d9fdde33ab8abcd603df66","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7cPrp+XyulftbrBIH0MjUvrn0cFgLe/Tpqi8WPE+iigBiyKCItWKWfY743OI4nLcNbZkz9t0u8Tb3r2t5csE9Q==","_from":"file:sinclair-typebox-0.25.20.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.20_1673274859971_0.02779927896990797"},"_hasShrinkwrap":false},"0.25.21":{"_id":"@sinclair/typebox@0.25.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"763b05a4b472c93a8db29b2c3e359d55b29ce272","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gFukHN4t8K4+wVC+ECqeqwzBDeFeTzBXroBTqE6vcWrQGbEUpHO7LYdG0f4xnvYq4VOEwITSlHlp0JBAIFMS/g==","_from":"file:sinclair-typebox-0.25.21.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.21_1674109512899_0.18768693784600465"},"_hasShrinkwrap":false},"0.25.22":{"_id":"@sinclair/typebox@0.25.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.22","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"2808d895e9c2722b20a622a9c8cb332f6720eb4a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-6U6r2L7rnM7EG8G1tWzIjdB3QlsHF4slgcqXNN/SF0xJOAr0nDmT2GedlkyO3mrv8mDTJ24UuOMWR3diBrCvQQ==","_from":"file:sinclair-typebox-0.25.22.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.22_1676444428763_0.15672591255167512"},"_hasShrinkwrap":false},"0.25.23":{"_id":"@sinclair/typebox@0.25.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"1c15b0d2b872d89cc0f47c7243eacb447df8b8bd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-VEB8ygeP42CFLWyAJhN5OklpxUliqdNEUcXb4xZ/CINqtYGTjL5ukluKdKzQ0iWdUxyQ7B0539PAUhHKrCNWSQ==","_from":"file:sinclair-typebox-0.25.23.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.25.23_1676544824274_0.4543425226292541"},"_hasShrinkwrap":false},"0.25.24":{"_id":"@sinclair/typebox@0.25.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.25.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"8c7688559979f7079aacaf31aa881c3aa410b718","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.25.24.tgz"},"types":"./typebox.d.ts"},"0.26.0-dev":{"_id":"@sinclair/typebox@0.26.0-dev","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"edfae6b019fa7efb799c1fe94de35b8debbe3feb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-CLrRa33JcUM2vBCKTWe8VGxhgeOoBMyeROc2zF8ofPfLQMDPxG5CK0whqC4I9AClELI2kyc4xJtgICjBvH7rNQ==","_from":"file:sinclair-typebox-0.26.0-dev.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev_1679069743308_0.3441310875842185"},"_hasShrinkwrap":false},"0.26.0-dev.1":{"_id":"@sinclair/typebox@0.26.0-dev.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"aa8ea8b0a359923f269171ddc60e577e2cbef0ef","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-hS1IAUsBrSwUcsSoYqo2JKJQDj6nsv7yPuxwWmthO/5j/Xh8jBqP//dfrokEkcfMU8f9F4DtxbDV+j5I6XuhZg==","_from":"file:sinclair-typebox-0.26.0-dev.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.1_1679121614153_0.23910352672296353"},"_hasShrinkwrap":false},"0.26.0-dev.2":{"_id":"@sinclair/typebox@0.26.0-dev.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^4.9.3"},"main":"./typebox.js","dist":{"shasum":"ad32ff42ace97962297dcbbbc9957c6dd09e1f1b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-r5ZFF4gkBEko5XYeE0Xx5u0cELYP0ysJrHOo1NPNcJ7k83Xh6QA2AJuQBwFnAvxH2mRYkpFbJBVSmjf23xqI5g==","_from":"file:sinclair-typebox-0.26.0-dev.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.2_1679132517965_0.737655923271626"},"_hasShrinkwrap":false},"0.26.0-dev.3":{"_id":"@sinclair/typebox@0.26.0-dev.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"cf5694e8ac3c0cb463110206da482d7cb1b7f79b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QfMYpAl5ES8xqmKJ3yGCWuBKluIeAXXqSJmbOwsTkwKsYBBYkAsVcPefzZLreyfvqsIcAOOToojFXkx2uTswyQ==","_from":"file:sinclair-typebox-0.26.0-dev.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.3_1679198545037_0.7240979723421632"},"_hasShrinkwrap":false},"0.26.0-dev.4":{"_id":"@sinclair/typebox@0.26.0-dev.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"31024cfdb89382647f2c38317871dbae3cca4c3c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ogxik7EzihqGDxkp8kBUU83Mq1OwymalXjof3bdxb5EN0HQHWqgoFiV3cfa2L2jWM+Kp7aYW0tsDcK4fWRYDXA==","_from":"file:sinclair-typebox-0.26.0-dev.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.4_1679221409627_0.2946865632078246"},"_hasShrinkwrap":false},"0.26.0-dev.5":{"_id":"@sinclair/typebox@0.26.0-dev.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0-dev.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ee5656823fb2eda6d495f5e43087ad31b8d28e50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0-dev.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-DshtQKfuHxawadWK6YgEhF9l3aag/rlSI29EL2AeOks0XvohwR/RzGIiseeP8B7Y4ez9SgygJLiCI9ySXGzQJw==","_from":"file:sinclair-typebox-0.26.0-dev.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0-dev.5_1679301222356_0.08870351623844708"},"_hasShrinkwrap":false},"0.26.0":{"_id":"@sinclair/typebox@0.26.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"49b2b2f52147e4145486c778a727dcdcd65d4682","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tpJrwq/npjYCZ5x//33zRKlgOg8lsBKuQ7MhmItrde/URJshRwDJsJzPwGSUqVetRCDDmcUP5P3Ux1XtAU7l1g==","_from":"file:sinclair-typebox-0.26.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.0_1679414849072_0.5486670804900116"},"_hasShrinkwrap":false},"0.26.1":{"_id":"@sinclair/typebox@0.26.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"34c9a6c5356d5a54b6e9c74bb1b7229073d875a8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-6tJPRp4iDOLXvjuiB5O96Dgseex4B7at91koonQ000Fk+MC4Ix7B56ULS9cBJgakWb5P8QsytLigkAve17g86Q==","_from":"file:sinclair-typebox-0.26.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.1_1679511990564_0.40399211925751666"},"_hasShrinkwrap":false},"0.26.2":{"_id":"@sinclair/typebox@0.26.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"4f60dc028629c3d91bdcca769053a7d00d3fcbea","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ltt0X5VwgBdDfgJ9j37jNMQ/QIsarKZqLUhcW7SpREcdGZZ8RupBhchWkJiJzhnwwnxq+nIhAi1EJzygwbEIFg==","_from":"file:sinclair-typebox-0.26.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.2_1679559412147_0.6873424568984425"},"_hasShrinkwrap":false},"0.26.3":{"_id":"@sinclair/typebox@0.26.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"4f2d33038f9d7fa9514c1c00903fe641cdb59472","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7ePab2ecv+Qsn2N9cKY31gQpXBd+jtQvT2lmknEbi4k0n5nwQQ43AOnhdy/TkECIO//fM+OdefPDc1eexeEN0A==","_from":"file:sinclair-typebox-0.26.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.3_1679633809270_0.03535487432492879"},"_hasShrinkwrap":false},"0.26.4":{"_id":"@sinclair/typebox@0.26.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ea23bee1f9121cd404134bbf891372e93ca61c28","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZJgx9iRQ6ngcRevS/JrYfBYD1ZKT21c4MAvAUIQgzcHRuD2HJ3WwrSKxmVhfE/MbrGLsMBQ6Wpc3tMPVXOBYuA==","_from":"file:sinclair-typebox-0.26.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.4_1679818703438_0.5080452710070835"},"_hasShrinkwrap":false},"0.26.5":{"_id":"@sinclair/typebox@0.26.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"565335597bf1876197848b27335b518a043aab43","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bCAUB2mTRhSCbDKjtlsqfmIAahNLdW7T854jnbruGHsH8p7CZKJQgU84x9b59HQ6NKvI9GUCimxBJSrp5f7fbA==","_from":"file:sinclair-typebox-0.26.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.5_1679887824369_0.5914031809042886"},"_hasShrinkwrap":false},"0.26.6":{"_id":"@sinclair/typebox@0.26.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"d66a26ce4e09af10a4a6a85a26dceafc956b6162","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7BT4sRfeCV5j/CK/+cXu05B2IxrNBhD1rR3HJ8XG3/oqZfJIA60GnNKo+N4VHA47JTg8zlXuYTLYMVxI3pwMEQ==","_from":"file:sinclair-typebox-0.26.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.6_1680015114894_0.9936326930420853"},"_hasShrinkwrap":false},"0.26.7":{"_id":"@sinclair/typebox@0.26.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"34faf7d8beffefb5ed9c2d6de3900db6709cd6a8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-lDClq3usrxGZ30W/ILuIJyPNM27lhLDpMEKnKp7QklMtU3tmEfs5v8Qdlcw2JHmhlzsH5tKGCAkd28xp2jOOxQ==","_from":"file:sinclair-typebox-0.26.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.7_1680063626254_0.3986138887108903"},"_hasShrinkwrap":false},"0.26.8":{"_id":"@sinclair/typebox@0.26.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.26.8","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.11.2","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"daea92a69f2903b1f1d9582b9539553f144aba6b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.26.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-fvAkOrUWndf5vjptkW+4TeTH84/bILWQHgk7rbbzT8trZxW+b84lr8dZQPM/r7cGNRFxDaJYsMjHCikEYyAHaw==","_from":"file:sinclair-typebox-0.26.8.tgz","_nodeVersion":"16.17.1","_npmVersion":"8.15.0","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.26.8_1680113568871_0.48686976653214553"},"_hasShrinkwrap":false},"0.27.0":{"_id":"@sinclair/typebox@0.27.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"e8fe35461a1ee1a2fd78ac56b8c40f4a18195299","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-nqCvfid613HckrkVcHw/OJv7Lbkd9PTQV3U/unOsUjdsoHhx9l7sEBNzdTfXxanreHOKV4tbmokLOGMXOQm4yw==","_from":"file:sinclair-typebox-0.27.0.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.0_1680970391716_0.16761637968069132"},"_hasShrinkwrap":false},"0.27.1":{"_id":"@sinclair/typebox@0.27.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"99ace29708c8da1cdc323b1e685a36abafc5b987","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+BzPidY3shay9ue8Qa2v6Z5HO4HWP0+irwMQcs6PEDWf//Iu7U7+b+W3+aXdovFFl/Sh3yyKKXlJhQ0h3zIMBg==","_from":"file:sinclair-typebox-0.27.1.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.1_1681126425938_0.8257015919976811"},"_hasShrinkwrap":false},"0.27.2":{"_id":"@sinclair/typebox@0.27.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"d178f8b8845dc6da2d947706549d69fa7a9bf179","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-nm4jY2hG2w51Qug+qSw8aSLatstdDy2JA3f6vpJRQttnXcZZ6k+EBzQWPdvW3+tBbw7NPoQ9N287F6PTzGVzMg==","_from":"file:sinclair-typebox-0.27.2.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.2_1681162887482_0.828106181670214"},"_hasShrinkwrap":false},"0.27.3":{"_id":"@sinclair/typebox@0.27.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"af668779cbead6b1f9e5df7ff8918fba3cbc840f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-mzSyMA75B1kVzw6P/mo9J9cBCOqtA0GvbIOhlSonRtDSR4jQyla1opsgNnHKzXuCqhVef/Nv+F+z2ueNrIVLVQ==","_from":"file:sinclair-typebox-0.27.3.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.3_1681191839786_0.2745561800150049"},"_hasShrinkwrap":false},"0.27.4":{"_id":"@sinclair/typebox@0.27.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"ab9e302179f67254b21b330ca55bfbd755cc61de","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PwDIJ41Wl/Rn8DbBC4tIEG8nONKyKfbf5P32frIvm6VrJqjukjqOs4VR+iR3khQVC91k9SopeRo4B+SrfNW2YA==","_from":"file:sinclair-typebox-0.27.4.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.4_1681304030918_0.20240948080889365"},"_hasShrinkwrap":false},"0.27.5":{"_id":"@sinclair/typebox@0.27.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"fb31a0068036def8466a3b6e5a6c999b6139b945","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-SwsnzCF2nqxuoXx+hhDWGFA37/x6V94SCcYUfYIqUunhvQka4ii0uCW7/dmtE6MQs3dk42TISf6gRUooiR5FBA==","_from":"file:sinclair-typebox-0.27.5.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.5_1681437503155_0.2711753051399677"},"_hasShrinkwrap":false},"0.27.6":{"_id":"@sinclair/typebox@0.27.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"21bc37a16b4032f1643545141c267a85fc65c71f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Mp7BRgoCKdukKBxCaSWf7kGMd0lA4yaz7fQTYTe4pTEwBBcXNih7/xynWApgOsFGMQe5fwJR7Av952E1BVQOtw==","_from":"file:sinclair-typebox-0.27.6.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.6_1681445590188_0.31040865002974183"},"_hasShrinkwrap":false},"0.27.7":{"_id":"@sinclair/typebox@0.27.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"85bc2d03d4a404a6fba98f56661a2f7cdbcd78ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-sNK1gp9TPArdNMR5QWyNKhGYez2G/NXi6zXlOON9i88fLfGLiubYfkGVPpswPTqnJ4Y9PSnQfKWdwnE01qsaTg==","_from":"file:sinclair-typebox-0.27.7.tgz","_nodeVersion":"16.17.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.27.7_1681459830240_0.642138542463379"},"_hasShrinkwrap":false},"0.27.8":{"_id":"@sinclair/typebox@0.27.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.27.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":null,"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"6667fac16c436b5434a387a34dedb013198f6e6e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.27.8.tgz"},"types":"./typebox.d.ts"},"0.28.0":{"_id":"@sinclair/typebox@0.28.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"9b24037202c25fc11f148cf3e1d105923dcadc74","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-9Nk7ny/CiaManM7DZ+NAFqBpnNKEPjAzn+Fqb/xID2uaIYTlqsWrm6ph8x4wxhfQFdpDFF3qvToC6GD5xyCwsA==","_from":"file:sinclair-typebox-0.28.0.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.0_1682027280870_0.6438497127374865"},"_hasShrinkwrap":false},"0.28.1":{"_id":"@sinclair/typebox@0.28.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"51d72db9d0d42da23c2bbd4434eee33f3d601e84","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Qmrojy+++InUpF782bGcDYP5VFXiZzEN5EduD33TuESjTSLTljCdeeGWlIh42E37LMlYJB3jCpbABZV7lnVX1w==","_from":"file:sinclair-typebox-0.28.1.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.1_1682032904696_0.7706299931177147"},"_hasShrinkwrap":false},"0.28.2":{"_id":"@sinclair/typebox@0.28.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"7d310ab33eb73729fed751469fc90147209b9d45","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3CdUgXqd6ud7tKvEvo5h2c1lx87DsR9pwZeDJ1AVdG9fFK87uTXBR7/b5BeHowjkFgrPmvaYyc+xo407laUceA==","_from":"file:sinclair-typebox-0.28.2.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.2_1682081125860_0.0926610422734575"},"_hasShrinkwrap":false},"0.28.3":{"_id":"@sinclair/typebox@0.28.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"e1261c202721b5b2b1178381e1d07b3214b3bf00","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aF0PAXDI5+jidu9WuhJumF6JEaQfIbM2bR0UbGc/UhHrHm7LQ76UenXGgvIcQNDYjghjoPssTxdx9ElNUaGG9g==","_from":"file:sinclair-typebox-0.28.3.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.3_1682112626986_0.8397945073300612"},"_hasShrinkwrap":false},"0.28.4":{"_id":"@sinclair/typebox@0.28.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"753a48f9b88e0a9589c244fd8c5ae86a3556f145","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Yqxz+dK/AFu9p03Q7XmajxDsNDLEfaQFFdEE4krqi+1otLkEgOrQD5IrWiq26Mbie5R6bPR6BljarufOdlCqQA==","_from":"file:sinclair-typebox-0.28.4.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.4_1682121075325_0.1179759392987445"},"_hasShrinkwrap":false},"0.28.5":{"_id":"@sinclair/typebox@0.28.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"5bb0568c9bca97a1f031c3a30ac625976d22d235","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3BjziLrALI2q+KpSKMwQdHP0MwmBpiu3oH0LM3mr7Aob9xO2z1hbGxjorTH7l5msuevXH7TU7YLt3Qs7U6Iokg==","_from":"file:sinclair-typebox-0.28.5.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.5_1682225459473_0.04868811451395172"},"_hasShrinkwrap":false},"0.28.6":{"_id":"@sinclair/typebox@0.28.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.6","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"a762715e46313afc0038ab5495b41cac76f40e1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dIlAWjH0O0zK2w0YDhLX0vYy75sE0Ie+w9NL3hWCXbegQZMgTc7RVMeNLUem6PDwN1YvKo8oZIFXEsqTM7pVDw==","_from":"file:sinclair-typebox-0.28.6.tgz","_nodeVersion":"20.0.0","_npmVersion":"9.6.4","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.6_1682417842949_0.0631929121055268"},"_hasShrinkwrap":false},"0.28.7":{"_id":"@sinclair/typebox@0.28.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"6ae0cb14c98917340654847c2969d02f58b72156","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Ubom8FLHLw0tKXpsbDrcljkGUJpD+FlcLdALsTx+cQNjv3NxW87JaAvqnmHKmLxvI7SQCmdxFcIPytW9Jal3Iw==","_from":"file:sinclair-typebox-0.28.7.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.7_1682577871859_0.20216079986839963"},"_hasShrinkwrap":false},"0.28.8":{"_id":"@sinclair/typebox@0.28.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"876fc57190cd3f169dbf054d66963ff4bf424fdd","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-OerNjE43mIb2RDy/RJfjS+OHfJHq3caePlVe/GXkLwLzcYevA2JPzHWSFMkpGgfoFKWdQdckKRiMVMsz40yHgw==","_from":"file:sinclair-typebox-0.28.8.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.8_1682673580224_0.6107443338530492"},"_hasShrinkwrap":false},"0.28.9":{"_id":"@sinclair/typebox@0.28.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"594e4e752839868074be70a8cbb35f264de79d07","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-m98m37J9CBZ8XinStjpss2ZOW50KG45XB4cAva2NGoQHiGPxhfNL2BzUXYCs6ahXdK7/F1NIjOGh+MPP5dK8Rw==","_from":"file:sinclair-typebox-0.28.9.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.9_1682951412838_0.9389784001271382"},"_hasShrinkwrap":false},"0.28.10":{"_id":"@sinclair/typebox@0.28.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"dddd3243c3020166b52d46d2ced8073ed89759e8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZRpJZFpr2yq1vAenq2qspUKs34CBC97LOMghUuTTEveFONVExQAYEB8Tcjy9NlPj8oVlSysK15Hzkf7Ox6x3lA==","_from":"file:sinclair-typebox-0.28.10.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.10_1683993972980_0.8615084344613271"},"_hasShrinkwrap":false},"0.28.11":{"_id":"@sinclair/typebox@0.28.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.2"},"main":"./typebox.js","dist":{"shasum":"f094caefc315e1a9b4e649056f661ddb20fcea97","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8QPhkOowccAdXa/ra54pq+UVYvzbKjYMuojxCOTFq+yyEfcWZJSdlIVdivTRrIq7Mgjx1n4E37t8Js/RXwyvUg==","_from":"file:sinclair-typebox-0.28.11.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.11_1684294039059_0.8682479788384345"},"_hasShrinkwrap":false},"0.28.12":{"_id":"@sinclair/typebox@0.28.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"b84895fdc96ca8d32a2f241a6eaead268044ba35","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-v/jftJeCY+qsfAY3l75tmEJ+3MlCkWG3gO7tSFwg+g5/Sfh8rdA278DFIRezt5JX/T0LB+TNmHnSXnMo5ok3Xw==","_from":"file:sinclair-typebox-0.28.12.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.12_1684993930311_0.15879279548934067"},"_hasShrinkwrap":false},"0.28.13":{"_id":"@sinclair/typebox@0.28.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"83bc090f29e0d7c1fdc27000c3ebbb990391a52f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bSHHPYPB3UGMoa1n85cpzpMXksFabJA2ZUNojojg4gqfaSUgSmtAG+AbCAGJSylQYbk5slOxkQymqWXEv492aw==","_from":"file:sinclair-typebox-0.28.13.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.13_1685075725991_0.9860249042663369"},"_hasShrinkwrap":false},"0.28.14":{"_id":"@sinclair/typebox@0.28.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.0.4"},"main":"./typebox.js","dist":{"shasum":"31653c1ecb93af1eec673c771971620060dfde40","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aB3ddagwMFz2cSLg0/gUt7yaUHJUKnT+rEHGdb/srtEFILB0zdL7a2mcbA7kskOCFHicAOV1POeeZdwoevFgAQ==","_from":"file:sinclair-typebox-0.28.14.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.14_1685388202169_0.6524188764257999"},"_hasShrinkwrap":false},"0.28.15":{"_id":"@sinclair/typebox@0.28.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"44ef4cf4138740f0e17051cbf5217e0fed578256","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-IUHNXCbehBRC1yC1PVtzOHuDaqb30NnCquY3T8VFChu8Jy+wwl1l/XJ0VhC/EEUPi9MBQ8KTeWGT/KmbhztU4g==","_from":"file:sinclair-typebox-0.28.15.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.15_1686384602381_0.02191716081197881"},"_hasShrinkwrap":false},"0.28.16":{"_id":"@sinclair/typebox@0.28.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"4416f4a88c12eb9ab53f8473c0053f368a4cb328","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0MqOedIj2ZjvCtUwibzubKdVzIDihAdCAEtoMAEDzuRpdlRtw/MlXbkNZaM+cjU8h0ApR0uctmakKgSY9kQqLg==","_from":"file:sinclair-typebox-0.28.16.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.16_1687245353206_0.8000202031127268"},"_hasShrinkwrap":false},"0.28.17":{"_id":"@sinclair/typebox@0.28.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"b28f0d444f866500c4ce4674c3b9cb042a42a689","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/twakA+gA4KgkXMiMjWwmV57xmDrm1fp+OaIMz01R3+q7AOSPhnTPZPwxqOzPDslfelxwzZx0Ttp3YdyS1+F4Q==","_from":"file:sinclair-typebox-0.28.17.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.17_1687366646711_0.14255705302644794"},"_hasShrinkwrap":false},"0.28.18":{"_id":"@sinclair/typebox@0.28.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"4a13c7ea3393d00e581717a8a750128e631c0831","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-I19d36CXlLAsm+nrl7VKsYyirFLtdebT2nlfV3Knvo0tnk8B8UKyt3DEqNJexEb/2pKPtdXNLcr72aJtfl6whA==","_from":"file:sinclair-typebox-0.28.18.tgz","_nodeVersion":"20.0.0","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.18_1687408941166_0.08137537353268143"},"_hasShrinkwrap":false},"0.28.19":{"_id":"@sinclair/typebox@0.28.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"bcc9b0fb26082ea8d052e59cacadf096b60fcf81","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-J08onOXZeCXEwB/Kpri/1l3b8Fs1EzG301kDCEikf5+E0TH8SzY1Edfq8T4ebNzXFcs34gonv20LjMn4Bzthow==","_from":"file:sinclair-typebox-0.28.19.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.19_1687807678899_0.4743302968422367"},"_hasShrinkwrap":false},"0.28.20":{"_id":"@sinclair/typebox@0.28.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.28.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.3"},"main":"./typebox.js","dist":{"shasum":"978652a10ced0102aec86e8e088837ab7d0d5871","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.28.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-QCF3BGfacwD+3CKhGsMeixnwOmX4AWgm61nKkNdRStyLVu0mpVFYlDSY8gVBOOED1oSwzbJauIWl/+REj8K5+w==","_from":"file:sinclair-typebox-0.28.20.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.28.20_1687854435283_0.02745105650222257"},"_hasShrinkwrap":false},"0.29.0":{"_id":"@sinclair/typebox@0.29.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"a19842180595a9a77d57407091707a2739feb508","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-htPaB6O/USun7JviXuzHnIchTbwgSdKijwt/ho8l9agmvbFcYnrSPOi2qNRzqNOBnHjXMUPoCXri4C6SwkOy3g==","_from":"file:sinclair-typebox-0.29.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.0_1688305512100_0.22106198380612407"},"_hasShrinkwrap":false},"0.29.1":{"_id":"@sinclair/typebox@0.29.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"28946ecc70e421f2e6b9c3eed55dc2b46a18c947","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ML/pdD3MnCijK8jzB+E/rTWtZ/2JAbwq196AzlsDBXPzLAjtCRHFAp5VvrWClmzJ8CVMBxOjeraoQX3s9XwXHA==","_from":"file:sinclair-typebox-0.29.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.1_1688324358677_0.28638665236245653"},"_hasShrinkwrap":false},"0.29.2":{"_id":"@sinclair/typebox@0.29.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"f7316d26a3bcb8c6088a2885f9f39690bc970410","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-dbQjPyqrfo7vC10e/iEfrGnuT0z8WJyCSXmAX7fpnPg3UjduU8mZmQp9HW5u4nfG7Jf5rFWPK51VudVJ5B4e3A==","_from":"file:sinclair-typebox-0.29.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.2_1688419876446_0.8912109746052437"},"_hasShrinkwrap":false},"0.29.3":{"_id":"@sinclair/typebox@0.29.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"clean":"hammer task clean","format":"hammer task format","start":"hammer task start","test":"hammer task test","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"26a8f5ee265ce487166568c3796723e1a9958f50","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-j793DNq5m+GdEp7s8O4CUyumrjEwu9Kj8vsokAdeK/3aHQ35eFYOJn5WWIFexVOCWjLTZhWir04vsBLCaZM2xw==","_from":"file:sinclair-typebox-0.29.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.3_1688423547706_0.6284180650580198"},"_hasShrinkwrap":false},"0.29.4":{"_id":"@sinclair/typebox@0.29.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"88bcfbd6252ae935dec45022e2c98d6fd9d0c643","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XSEM1jjL9CPI4pZ0RZs84Oq+jcONXFHljufxrp70rTYTbslDuYDj1wnDCzDb3XC9Tf5C36sGO1Fu7VFXXDTgFw==","_from":"file:sinclair-typebox-0.29.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.4_1688610729420_0.08153613499443546"},"_hasShrinkwrap":false},"0.29.5":{"_id":"@sinclair/typebox@0.29.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"95d666b799a2f52a3374a635379ce37bfe0ec240","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-hmwtss82axitE4y/koJvkvZ4e3xfWH+CcxlCEGZYrXC9p3YBkbtG98bs1WHQi+cpfr/Q6cXj8Mk3Fsq6tHK1JA==","_from":"file:sinclair-typebox-0.29.5.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.5_1689700183703_0.17997743680384137"},"_hasShrinkwrap":false},"0.29.6":{"_id":"@sinclair/typebox@0.29.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.29.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"4cd8372f9247372edd5fc5af44f67e2032c46e2f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.29.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-aX5IFYWlMa7tQ8xZr3b2gtVReCvg7f3LEhjir/JAjX2bJCMVJA5tIPv30wTD4KDfcwMd7DDYY3hFDeGmOgtrZQ==","_from":"file:sinclair-typebox-0.29.6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.29.6_1689701212880_0.982377218694056"},"_hasShrinkwrap":false},"0.30.0-dev-1":{"_id":"@sinclair/typebox@0.30.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"2d8e2f378df5cd3a343cd812fe9d85dbe92ecf23","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-1.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that can be composed into more complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 6 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │      type: 'number'            │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │      type: 'string'            │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │      type: 'number'            │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pattern('^xy$') │ type T = string             │ const T = {                    │\r\n│                                │                             │    type: 'string',             │\r\n│                                │                             │    pattern: '^xy$'             │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [...A, ...B]       │   items: [                     │\r\n│ ])                             │                             │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │                             │     { const: 1 },              │\r\n|   Type.Literal(2),             │                             │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions constrained to type `TSchema`. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nThe following creates a generic `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Type.Ref`. The target type must specify a valid `$id`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //    $id: 'T',\r\n                                                     //    type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref(T)                                // const R = {\r\n                                                     //    $ref: 'T'\r\n                                                     // }\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Type.Recursive`.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Type.Extends`. This type will perform a structural assignment check for the first two parameters and return a `true` or `false` type from the second two parameters. The types `Type.Exclude` and `Type.Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1>\r\n  Type.Union([\r\n    Type.Literal(1), \r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]>\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `Type.TemplateLiteral`. This type implements an embedded DSL syntax to match the TypeScript template literal syntax. This type can also be composed by passing an array of union and literal types as parameters. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype P = `/post/${string}/user/${number}`            // type P = `/post/${string}/user/${number}`\r\n\r\ntype T = `option${'A'|'B'}`                          // type T = 'optionA' | 'optionB'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst P = Type.TemplateLiteral('/post/${string}/user/${number}')\r\n\r\n                                                     // const P = {\r\n                                                     //   type: 'string',\r\n                                                     //   pattern: '^/post/(.*)/user/(0|[1-9][0-9]*)$'\r\n                                                     // }\r\n\r\nconst T = Type.TemplateLiteral('option${A|B}')       // const T = {\r\n                                                     //   pattern: '^option(A|B)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Type.Index`. This type provides a consistent way to access interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Type.Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nThis type can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the values `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\n\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Type.Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well as for variadic functions.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nUse `Type.Unsafe` to create custom schematics with user defined inference rules.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThe `Type.Unsafe` type can be useful to express specific OpenAPI schema representations.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a `TypeGuard` module that can be used for reflection and asserting values as types.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = Type.String()\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 6 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    232 ms' │ '      8 ms' │ '   29.00 x' │\r\n│ Literal_Number             │    1000    │ '    179 ms' │ '      6 ms' │ '   29.83 x' │\r\n│ Literal_Boolean            │    1000    │ '    154 ms' │ '      3 ms' │ '   51.33 x' │\r\n│ Primitive_Number           │    1000    │ '    160 ms' │ '      7 ms' │ '   22.86 x' │\r\n│ Primitive_String           │    1000    │ '    149 ms' │ '      6 ms' │ '   24.83 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    191 ms' │ '      9 ms' │ '   21.22 x' │\r\n│ Primitive_Boolean          │    1000    │ '    135 ms' │ '      4 ms' │ '   33.75 x' │\r\n│ Primitive_Null             │    1000    │ '    144 ms' │ '      6 ms' │ '   24.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1144 ms' │ '     30 ms' │ '   38.13 x' │\r\n│ Object_Constrained         │    1000    │ '   1228 ms' │ '     24 ms' │ '   51.17 x' │\r\n│ Object_Vector3             │    1000    │ '    380 ms' │ '      9 ms' │ '   42.22 x' │\r\n│ Object_Box3D               │    1000    │ '   1771 ms' │ '     30 ms' │ '   59.03 x' │\r\n│ Tuple_Primitive            │    1000    │ '    471 ms' │ '     11 ms' │ '   42.82 x' │\r\n│ Tuple_Object               │    1000    │ '   1272 ms' │ '     15 ms' │ '   84.80 x' │\r\n│ Composite_Intersect        │    1000    │ '    606 ms' │ '     17 ms' │ '   35.65 x' │\r\n│ Composite_Union            │    1000    │ '    560 ms' │ '     22 ms' │ '   25.45 x' │\r\n│ Math_Vector4               │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Math_Matrix4               │    1000    │ '    419 ms' │ '      9 ms' │ '   46.56 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    382 ms' │ '      6 ms' │ '   63.67 x' │\r\n│ Array_Primitive_String     │    1000    │ '    324 ms' │ '      6 ms' │ '   54.00 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    301 ms' │ '      4 ms' │ '   75.25 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1734 ms' │ '     21 ms' │ '   82.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1509 ms' │ '     20 ms' │ '   75.45 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1619 ms' │ '     16 ms' │ '  101.19 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    773 ms' │ '     16 ms' │ '   48.31 x' │\r\n│ Array_Composite_Union      │    1000    │ '    822 ms' │ '     17 ms' │ '   48.35 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1131 ms' │ '     13 ms' │ '   87.00 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    661 ms' │ '     10 ms' │ '   66.10 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     13 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_String           │  1000000   │ '     19 ms' │ '     16 ms' │ '     10 ms' │ '    1.60 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    150 ms' │ '     41 ms' │ '     35 ms' │ '    1.17 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     17 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     18 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1001 ms' │ '     31 ms' │ '     24 ms' │ '    1.29 x' │\r\n│ Object_Constrained         │  1000000   │ '   1288 ms' │ '     50 ms' │ '     36 ms' │ '    1.39 x' │\r\n│ Object_Vector3             │  1000000   │ '    439 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2109 ms' │ '     52 ms' │ '     45 ms' │ '    1.16 x' │\r\n│ Object_Recursive           │  1000000   │ '   5337 ms' │ '    356 ms' │ '    162 ms' │ '    2.20 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    164 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    744 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    764 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Composite_Union            │  1000000   │ '    516 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    262 ms' │ '     20 ms' │ '     11 ms' │ '    1.82 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1089 ms' │ '     37 ms' │ '     27 ms' │ '    1.37 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    276 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    228 ms' │ '     21 ms' │ '     14 ms' │ '    1.50 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    159 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5695 ms' │ '     77 ms' │ '     69 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5701 ms' │ '    127 ms' │ '    110 ms' │ '    1.15 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21267 ms' │ '   1664 ms' │ '    573 ms' │ '    2.90 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    702 ms' │ '     40 ms' │ '     32 ms' │ '    1.25 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3141 ms' │ '     68 ms' │ '     51 ms' │ '    1.33 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3145 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2134 ms' │ '     68 ms' │ '     31 ms' │ '    2.19 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1197 ms' │ '     37 ms' │ '     25 ms' │ '    1.48 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5323 ms' │ '    111 ms' │ '     96 ms' │ '    1.16 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '128.2 kb' │ ' 58.2 kb' │  '2.20 x'   │\r\n│ typebox/errors       │ '110.4 kb' │ ' 49.5 kb' │  '2.23 x'   │\r\n│ typebox/system       │ ' 75.2 kb' │ ' 31.1 kb' │  '2.42 x'   │\r\n│ typebox/value        │ '179.6 kb' │ ' 78.7 kb' │  '2.28 x'   │\r\n│ typebox              │ ' 74.1 kb' │ ' 30.6 kb' │  '2.42 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-K6gloE8tUV3W73mbN+/N0lsUeTTs93ed8w9Lc9OUSazu+sRzI/tiXXw2m2pL2dLg7+iq5XdJzItwtFxZV6kvag==","_from":"file:sinclair-typebox-0.30.0-dev-1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-1_1690560461697_0.5176429348681768"},"_hasShrinkwrap":false},"0.30.0-dev-2":{"_id":"@sinclair/typebox@0.30.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"77d02fbb224e29c5f922c6190a3aa722c4062400","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-2.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that can be composed into more complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 6 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │      type: 'number'            │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │      type: 'string'            │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │      type: 'number'            │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pattern('^xy$') │ type T = string             │ const T = {                    │\r\n│                                │                             │    type: 'string',             │\r\n│                                │                             │    pattern: '^xy$'             │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [...A, ...B]       │   items: [                     │\r\n│ ])                             │                             │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │                             │     { const: 1 },              │\r\n|   Type.Literal(2),             │                             │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions constrained to type `TSchema`. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nThe following creates a generic `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Type.Ref`. The target type must specify a valid `$id`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //    $id: 'T',\r\n                                                     //    type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref(T)                                // const R = {\r\n                                                     //    $ref: 'T'\r\n                                                     // }\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Type.Recursive`.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Type.Extends`. This type will perform a structural assignment check for the first two parameters and return a `true` or `false` type from the second two parameters. The types `Type.Exclude` and `Type.Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1>\r\n  Type.Union([\r\n    Type.Literal(1), \r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]>\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `Type.TemplateLiteral`. This type implements an embedded DSL syntax to match the TypeScript template literal syntax. This type can also be composed by passing an array of union and literal types as parameters. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype P = `/post/${string}/user/${number}`            // type P = `/post/${string}/user/${number}`\r\n\r\ntype T = `option${'A'|'B'}`                          // type T = 'optionA' | 'optionB'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst P = Type.TemplateLiteral('/post/${string}/user/${number}')\r\n\r\n                                                     // const P = {\r\n                                                     //   type: 'string',\r\n                                                     //   pattern: '^/post/(.*)/user/(0|[1-9][0-9]*)$'\r\n                                                     // }\r\n\r\nconst T = Type.TemplateLiteral('option${A|B}')       // const T = {\r\n                                                     //   pattern: '^option(A|B)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Type.Index`. This type provides a consistent way to access interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Type.Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nThis type can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the values `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\n\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Type.Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well as for variadic functions.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nUse `Type.Unsafe` to create custom schematics with user defined inference rules.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThe `Type.Unsafe` type can be useful to express specific OpenAPI schema representations.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a `TypeGuard` module that can be used for reflection and asserting values as types.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = Type.String()\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 6 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    232 ms' │ '      8 ms' │ '   29.00 x' │\r\n│ Literal_Number             │    1000    │ '    179 ms' │ '      6 ms' │ '   29.83 x' │\r\n│ Literal_Boolean            │    1000    │ '    154 ms' │ '      3 ms' │ '   51.33 x' │\r\n│ Primitive_Number           │    1000    │ '    160 ms' │ '      7 ms' │ '   22.86 x' │\r\n│ Primitive_String           │    1000    │ '    149 ms' │ '      6 ms' │ '   24.83 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    191 ms' │ '      9 ms' │ '   21.22 x' │\r\n│ Primitive_Boolean          │    1000    │ '    135 ms' │ '      4 ms' │ '   33.75 x' │\r\n│ Primitive_Null             │    1000    │ '    144 ms' │ '      6 ms' │ '   24.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1144 ms' │ '     30 ms' │ '   38.13 x' │\r\n│ Object_Constrained         │    1000    │ '   1228 ms' │ '     24 ms' │ '   51.17 x' │\r\n│ Object_Vector3             │    1000    │ '    380 ms' │ '      9 ms' │ '   42.22 x' │\r\n│ Object_Box3D               │    1000    │ '   1771 ms' │ '     30 ms' │ '   59.03 x' │\r\n│ Tuple_Primitive            │    1000    │ '    471 ms' │ '     11 ms' │ '   42.82 x' │\r\n│ Tuple_Object               │    1000    │ '   1272 ms' │ '     15 ms' │ '   84.80 x' │\r\n│ Composite_Intersect        │    1000    │ '    606 ms' │ '     17 ms' │ '   35.65 x' │\r\n│ Composite_Union            │    1000    │ '    560 ms' │ '     22 ms' │ '   25.45 x' │\r\n│ Math_Vector4               │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Math_Matrix4               │    1000    │ '    419 ms' │ '      9 ms' │ '   46.56 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    382 ms' │ '      6 ms' │ '   63.67 x' │\r\n│ Array_Primitive_String     │    1000    │ '    324 ms' │ '      6 ms' │ '   54.00 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    301 ms' │ '      4 ms' │ '   75.25 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1734 ms' │ '     21 ms' │ '   82.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1509 ms' │ '     20 ms' │ '   75.45 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1619 ms' │ '     16 ms' │ '  101.19 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    773 ms' │ '     16 ms' │ '   48.31 x' │\r\n│ Array_Composite_Union      │    1000    │ '    822 ms' │ '     17 ms' │ '   48.35 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1131 ms' │ '     13 ms' │ '   87.00 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    661 ms' │ '     10 ms' │ '   66.10 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     13 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_String           │  1000000   │ '     19 ms' │ '     16 ms' │ '     10 ms' │ '    1.60 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    150 ms' │ '     41 ms' │ '     35 ms' │ '    1.17 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     17 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     18 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1001 ms' │ '     31 ms' │ '     24 ms' │ '    1.29 x' │\r\n│ Object_Constrained         │  1000000   │ '   1288 ms' │ '     50 ms' │ '     36 ms' │ '    1.39 x' │\r\n│ Object_Vector3             │  1000000   │ '    439 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2109 ms' │ '     52 ms' │ '     45 ms' │ '    1.16 x' │\r\n│ Object_Recursive           │  1000000   │ '   5337 ms' │ '    356 ms' │ '    162 ms' │ '    2.20 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    164 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    744 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    764 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Composite_Union            │  1000000   │ '    516 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    262 ms' │ '     20 ms' │ '     11 ms' │ '    1.82 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1089 ms' │ '     37 ms' │ '     27 ms' │ '    1.37 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    276 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    228 ms' │ '     21 ms' │ '     14 ms' │ '    1.50 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    159 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5695 ms' │ '     77 ms' │ '     69 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5701 ms' │ '    127 ms' │ '    110 ms' │ '    1.15 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21267 ms' │ '   1664 ms' │ '    573 ms' │ '    2.90 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    702 ms' │ '     40 ms' │ '     32 ms' │ '    1.25 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3141 ms' │ '     68 ms' │ '     51 ms' │ '    1.33 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3145 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2134 ms' │ '     68 ms' │ '     31 ms' │ '    2.19 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1197 ms' │ '     37 ms' │ '     25 ms' │ '    1.48 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5323 ms' │ '    111 ms' │ '     96 ms' │ '    1.16 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '128.2 kb' │ ' 58.2 kb' │  '2.20 x'   │\r\n│ typebox/errors       │ '110.4 kb' │ ' 49.5 kb' │  '2.23 x'   │\r\n│ typebox/system       │ ' 75.2 kb' │ ' 31.1 kb' │  '2.42 x'   │\r\n│ typebox/value        │ '179.6 kb' │ ' 78.7 kb' │  '2.28 x'   │\r\n│ typebox              │ ' 74.1 kb' │ ' 30.6 kb' │  '2.42 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-155Dim6Deo1ntkUP5xZfFBYMiwhD+2ERJ/mjBicP43qUiDmNp/T2yebLG7ViFyWHfKqCfLSAb5VvrTjmc6V9JA==","_from":"file:sinclair-typebox-0.30.0-dev-2.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-2_1690562544587_0.1543345304983419"},"_hasShrinkwrap":false},"0.30.0-dev-3":{"_id":"@sinclair/typebox@0.30.0-dev-3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-3","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"8aa4d7fa62b6e35280195a5c4ca968c421acce6f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-3.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n  - [Transform](#values-transform)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that compose into complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │      type: 'number'            │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │      type: 'string'            │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │      type: 'number'            │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pattern('^xy$') │ type T = string             │ const T = {                    │\r\n│                                │                             │    type: 'string',             │\r\n│                                │                             │    pattern: '^xy$'             │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [...A, ...B]       │   items: [                     │\r\n│ ])                             │                             │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │                             │     { const: 1 },              │\r\n|   Type.Literal(2),             │                             │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types are created with generic functions. All TypeBox types extend the sub type `TSchema` so it is common to constrain function arguments to this type. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types can be used to create aliases for more complex types. The following creates a `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Ref`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //   $id: 'T',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref<typeof T>('T')                    // const R = {\r\n                                                     //   $ref: 'T'\r\n                                                     // }\r\n\r\ntype R = Static<typeof R>                            // type R = string\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Recursive`. Recursive type inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Extends`. This type performs a structural assignment check against the first two parameters and returns either the `true` or `false` type as given from the second two parameters. The conditional types `Exclude` and `Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false> = {\r\n  Type.String(),                                     //   type: 'boolean',\r\n  Type.Number(),                                     //   const: false\r\n  Type.Literal(true),                                // }\r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1> = {\r\n  Type.Union([                                       //   type: 'number',\r\n    Type.Literal(1),                                 //   const: 1\r\n    Type.Literal(2),                                 // }\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]> = {\r\n    Type.Literal(3)                                 //   anyOf: [{\r\n  ]),                                               //     type: 'number',\r\n  Type.Literal(1)                                   //     const: 2\r\n)                                                   //   }, {\r\n                                                    //     type: 'number',\r\n                                                    //     const: 3\r\n                                                    //   }]\r\n                                                    // }\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `TemplateLiteral`. This type provides an embedded DSL syntax that is similar to the TypeScript template literal syntax. These type can also be composed by passing a tuple of exterior union and literal types. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = `option${'A'|'B'|'C'}`                      // type T = 'optionA' | 'optionB' | 'optionC'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     //   optionC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst T = Type.TemplateLiteral('option${A|B|C}')     // const T = {\r\n                                                     //   pattern: '^option(A|B|C)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //     optionC: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Index`. This type provides a consistent way of accessing interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nType negation can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the numbers `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well function parameter assignment.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports the creation of user defined schematics with user defined inference rules using the Unsafe type.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThis type can be useful to create various extended schematics, such as those used by OpenAPI.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a TypeGuard module to assert JavaScript values are valid TypeBox types.\r\n\r\n```typescript\r\nimport { Type, Kind, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. It's return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 7 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## Workbench\r\n\r\nTypeBox offers a web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    232 ms' │ '      8 ms' │ '   29.00 x' │\r\n│ Literal_Number             │    1000    │ '    179 ms' │ '      6 ms' │ '   29.83 x' │\r\n│ Literal_Boolean            │    1000    │ '    154 ms' │ '      3 ms' │ '   51.33 x' │\r\n│ Primitive_Number           │    1000    │ '    160 ms' │ '      7 ms' │ '   22.86 x' │\r\n│ Primitive_String           │    1000    │ '    149 ms' │ '      6 ms' │ '   24.83 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    191 ms' │ '      9 ms' │ '   21.22 x' │\r\n│ Primitive_Boolean          │    1000    │ '    135 ms' │ '      4 ms' │ '   33.75 x' │\r\n│ Primitive_Null             │    1000    │ '    144 ms' │ '      6 ms' │ '   24.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1144 ms' │ '     30 ms' │ '   38.13 x' │\r\n│ Object_Constrained         │    1000    │ '   1228 ms' │ '     24 ms' │ '   51.17 x' │\r\n│ Object_Vector3             │    1000    │ '    380 ms' │ '      9 ms' │ '   42.22 x' │\r\n│ Object_Box3D               │    1000    │ '   1771 ms' │ '     30 ms' │ '   59.03 x' │\r\n│ Tuple_Primitive            │    1000    │ '    471 ms' │ '     11 ms' │ '   42.82 x' │\r\n│ Tuple_Object               │    1000    │ '   1272 ms' │ '     15 ms' │ '   84.80 x' │\r\n│ Composite_Intersect        │    1000    │ '    606 ms' │ '     17 ms' │ '   35.65 x' │\r\n│ Composite_Union            │    1000    │ '    560 ms' │ '     22 ms' │ '   25.45 x' │\r\n│ Math_Vector4               │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Math_Matrix4               │    1000    │ '    419 ms' │ '      9 ms' │ '   46.56 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    382 ms' │ '      6 ms' │ '   63.67 x' │\r\n│ Array_Primitive_String     │    1000    │ '    324 ms' │ '      6 ms' │ '   54.00 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    301 ms' │ '      4 ms' │ '   75.25 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1734 ms' │ '     21 ms' │ '   82.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1509 ms' │ '     20 ms' │ '   75.45 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1619 ms' │ '     16 ms' │ '  101.19 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    773 ms' │ '     16 ms' │ '   48.31 x' │\r\n│ Array_Composite_Union      │    1000    │ '    822 ms' │ '     17 ms' │ '   48.35 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1131 ms' │ '     13 ms' │ '   87.00 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    661 ms' │ '     10 ms' │ '   66.10 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     13 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_String           │  1000000   │ '     19 ms' │ '     16 ms' │ '     10 ms' │ '    1.60 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    150 ms' │ '     41 ms' │ '     35 ms' │ '    1.17 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     17 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     18 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1001 ms' │ '     31 ms' │ '     24 ms' │ '    1.29 x' │\r\n│ Object_Constrained         │  1000000   │ '   1288 ms' │ '     50 ms' │ '     36 ms' │ '    1.39 x' │\r\n│ Object_Vector3             │  1000000   │ '    439 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2109 ms' │ '     52 ms' │ '     45 ms' │ '    1.16 x' │\r\n│ Object_Recursive           │  1000000   │ '   5337 ms' │ '    356 ms' │ '    162 ms' │ '    2.20 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    164 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    744 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    764 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Composite_Union            │  1000000   │ '    516 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    262 ms' │ '     20 ms' │ '     11 ms' │ '    1.82 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1089 ms' │ '     37 ms' │ '     27 ms' │ '    1.37 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    276 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    228 ms' │ '     21 ms' │ '     14 ms' │ '    1.50 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    159 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5695 ms' │ '     77 ms' │ '     69 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5701 ms' │ '    127 ms' │ '    110 ms' │ '    1.15 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21267 ms' │ '   1664 ms' │ '    573 ms' │ '    2.90 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    702 ms' │ '     40 ms' │ '     32 ms' │ '    1.25 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3141 ms' │ '     68 ms' │ '     51 ms' │ '    1.33 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3145 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2134 ms' │ '     68 ms' │ '     31 ms' │ '    2.19 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1197 ms' │ '     37 ms' │ '     25 ms' │ '    1.48 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5323 ms' │ '    111 ms' │ '     96 ms' │ '    1.16 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '128.2 kb' │ ' 58.2 kb' │  '2.20 x'   │\r\n│ typebox/errors       │ '110.4 kb' │ ' 49.5 kb' │  '2.23 x'   │\r\n│ typebox/system       │ ' 75.2 kb' │ ' 31.1 kb' │  '2.42 x'   │\r\n│ typebox/value        │ '179.6 kb' │ ' 78.7 kb' │  '2.28 x'   │\r\n│ typebox              │ ' 74.1 kb' │ ' 30.6 kb' │  '2.42 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-vN2HaqkAaNjED53FH3QOqDiANehLP+506SjM5r+NdxzEQKmpjQ6YfhD0pil/tIP6DqKUfzMMcJgCIwOVHvjlRw==","_from":"file:sinclair-typebox-0.30.0-dev-3.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-3_1690567519383_0.36335670387324015"},"_hasShrinkwrap":false},"0.30.0-dev-4":{"_id":"@sinclair/typebox@0.30.0-dev-4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"35e87e52bcef9849ab7c199c3518bc93ce17fbc8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-zAC4tVTnIZlbahxDbqHkENnzbCeQVFHVU+IbwJwFFjqZaSgHCB1EzzWLvDEcHpqtDdtcIiqIWuf0ZYeZhrBn4Q==","_from":"file:sinclair-typebox-0.30.0-dev-4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-4_1690574123221_0.12092975496664948"},"_hasShrinkwrap":false},"0.30.0-dev-5":{"_id":"@sinclair/typebox@0.30.0-dev-5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"2e21a2da583aa7f6ca4ed58c4d3e680f8307baae","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-5.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n#### Deno\r\n```typescript\r\nimport { Static, Type } from 'npm:@sinclair/typebox'\r\n```\r\n\r\n#### Esm\r\n\r\n```typescript\r\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript language. TypeBox allows one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Features](#features)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Standard](#types-standard)\r\n  - [Extended](#types-extended)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Negated](#types-negated)\r\n  - [Rest](#types-rest)\r\n  - [Guards](#types-guards)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Cast](#values-cast)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Types](#typesystem-types)\r\n  - [Formats](#typesystem-formats)\r\n  - [Policies](#typesystem-policies)\r\n- [Transform](#Transform)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Static, Type } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as JSON schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are JSON schema fragments that compose into complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-standard'></a>\r\n\r\n### Standard Types\r\n\r\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │      type: 'number'            │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │      type: 'string'            │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │      type: 'number'            │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pattern('^xy$') │ type T = string             │ const T = {                    │\r\n│                                │                             │    type: 'string',             │\r\n│                                │                             │    pattern: '^xy$'             │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [...A, ...B]       │   items: [                     │\r\n│ ])                             │                             │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │                             │     { const: 1 },              │\r\n|   Type.Literal(2),             │                             │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-extended'></a>\r\n\r\n### Extended Types\r\n\r\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   return: {                    │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with `readonly` or `optional`. The following table shows how these modifiers map between TypeScript and JSON Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types are created with generic functions. All TypeBox types extend the sub type `TSchema` so it is common to constrain function arguments to this type. The following creates a generic `Vector<T>` type.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types can be used to create aliases for more complex types. The following creates a `Nullable<T>` type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                   // const T = {\r\n                                                    //   anyOf: [\r\n                                                    //     { type: 'string' },\r\n                                                    //     { type: 'null' }\r\n                                                    //   ]\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types are supported with `Ref`.\r\n\r\n```typescript\r\nconst T = Type.String({ $id: 'T' })                  // const T = {\r\n                                                     //   $id: 'T',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Ref<typeof T>('T')                    // const R = {\r\n                                                     //   $ref: 'T'\r\n                                                     // }\r\n\r\ntype R = Static<typeof R>                            // type R = string\r\n```\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nRecursive types are supported with `Recursive`. Recursive type inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports conditional types with `Extends`. This type performs a structural assignment check against the first two parameters and returns either the `true` or `false` type as given from the second two parameters. The conditional types `Exclude` and `Extract` are also supported.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T0 = string extends number ? true : false       // type T0 = false\r\n\r\ntype T1 = Extract<(1 | 2 | 3), 1>                    // type T1 = 1\r\n\r\ntype T2 = Exclude<(1 | 2 | 3), 1>                    // type T2 = 2 | 3\r\n\r\n// TypeBox\r\n\r\nconst T0 = Type.Extends(                             // const T0: TLiteral<false> = {\r\n  Type.String(),                                     //   type: 'boolean',\r\n  Type.Number(),                                     //   const: false\r\n  Type.Literal(true),                                // }\r\n  Type.Literal(false)\r\n)\r\n\r\nconst T1 = Type.Extract(                             // const T1: TLiteral<1> = {\r\n  Type.Union([                                       //   type: 'number',\r\n    Type.Literal(1),                                 //   const: 1\r\n    Type.Literal(2),                                 // }\r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\nconst T2 = Type.Exclude(                            // const T2: TUnion<[\r\n  Type.Union([                                      //   TLiteral<2>,\r\n    Type.Literal(1),                                //   TLiteral<3>\r\n    Type.Literal(2),                                // ]> = {\r\n    Type.Literal(3)                                 //   anyOf: [{\r\n  ]),                                               //     type: 'number',\r\n  Type.Literal(1)                                   //     const: 2\r\n)                                                   //   }, {\r\n                                                    //     type: 'number',\r\n                                                    //     const: 3\r\n                                                    //   }]\r\n                                                    // }\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with `TemplateLiteral`. This type provides an embedded DSL syntax that is similar to the TypeScript template literal syntax. These type can also be composed by passing a tuple of exterior union and literal types. The following example shows the DSL syntax.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = `option${'A'|'B'|'C'}`                      // type T = 'optionA' | 'optionB' | 'optionC'\r\n\r\ntype R = Record<T, string>                           // type R = {\r\n                                                     //   optionA: string\r\n                                                     //   optionB: string\r\n                                                     //   optionC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst T = Type.TemplateLiteral('option${A|B|C}')     // const T = {\r\n                                                     //   pattern: '^option(A|B|C)$',\r\n                                                     //   type: 'string'\r\n                                                     // }\r\n\r\nconst R = Type.Record(T, Type.String())              // const R = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['optionA', 'optionB'],\r\n                                                     //   properties: {\r\n                                                     //     optionA: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     optionB: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //     optionC: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types using `Index`. This type provides a consistent way of accessing interior property and array element types without having to extract them from the underlying schema representation. Indexed access types are supported for object, array, tuple, union and intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.String(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Boolean()                                  //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'string' },\r\n                                                     //     z: { type: 'string' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A = { type: 'number' }\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'number' },\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'boolean' }\r\n                                                     //   ]\r\n                                                     // }\r\n```\r\n\r\n<a name='types-negated'></a>\r\n\r\n### Negated Types\r\n\r\nTypeBox has support for type negation with `Not`. This type will always infer as `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Not(Type.String())                   // const T = {\r\n                                                    //   not: { type: 'string' }\r\n                                                    // }\r\n\r\ntype T = Static<typeof T>                           // type T = unknown\r\n                                                    //\r\n                                                    // where T could be any type other than string\r\n```\r\nType negation can be useful for certain forms of type narrowing. For example, consider a type that represents a `number` but not the numbers `1, 2, 3`. The example below shows an imaginary TypeScript syntax to express such a type followed by the TypeBox representation.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = number & not (1 | 2 | 3)                    // not actual syntax\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Intersect([                           // const T = {\r\n  Type.Number(),                                     //   allOf: [\r\n  Type.Not(Type.Union([                              //     { type: \"number\" },\r\n    Type.Literal(1),                                 //     {\r\n    Type.Literal(2),                                 //       not: {\r\n    Type.Literal(3)                                  //         anyOf: [\r\n  ]))                                                //           { const: 1, type: \"number\" },\r\n])                                                   //           { const: 2, type: \"number\" },\r\n                                                     //           { const: 3, type: \"number\" }\r\n                                                     //         ]\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = number\r\n```\r\nThis type can be used with constraints to create schematics that would otherwise be difficult to express.\r\n```typescript\r\nconst Even = Type.Number({ multipleOf: 2 })\r\n\r\nconst Odd = Type.Intersect([Type.Number(), Type.Not(Even)])          \r\n```\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nRest parameters are supported with `Rest`. This function is used to extract interior type elements from tuples which enables them to compose with the JavaScript spread operator `...`. This type can be used for tuple concatenation as well function parameter assignment.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype T = [number, number]                            // type T = [number, number]\r\n\r\ntype C = [...T, number]                              // type C = [number, number, number]\r\n\r\ntype F = (...param: C) => void                       // type F = (\r\n                                                     //   param0: number,\r\n                                                     //   param1: number,\r\n                                                     //   param2: number\r\n                                                     // ) => void\r\n\r\n// TypeBox\r\n\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.Number(),                                     //   TNumber,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst C = Type.Tuple([                               // const C: TTuple<[\r\n  ...Type.Rest(T),                                   //   TNumber,\r\n  Type.Number()                                      //   TNumber,\r\n])                                                   //   TNumber\r\n                                                     // ]>\r\n\r\nconst F = Type.Function(Type.Rest(C), Type.Void())   // const F: TFunction<[\r\n                                                     //   TNumber,\r\n                                                     //   TNumber,\r\n                                                     //   TNumber\r\n                                                     // ], TVoid>\r\n```\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports the creation of user defined schematics with user defined inference rules using the Unsafe type.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string\r\n```\r\n\r\nThis type can be useful to create various extended schematics, such as those used by OpenAPI.\r\n\r\n```typescript\r\nimport { Type, Static, TSchema } from '@sinclair/typebox'\r\n\r\n// Nullable<T>\r\n\r\nfunction Nullable<T extends TSchema>(schema: T) {\r\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\r\n}\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\n// StringEnum<string[]>\r\n\r\nfunction StringEnum<T extends string[]>(values: [...T]) {\r\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\r\n}\r\n\r\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\r\n```\r\n\r\n<a name='types-guards'></a>\r\n\r\n### Type Guards\r\n\r\nTypeBox provides a TypeGuard module to assert JavaScript values are valid TypeBox types.\r\n\r\n```typescript\r\nimport { Type, Kind, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.TString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. It's return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to produce a sequence of edits to transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                               // const E = [\r\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\r\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\r\n                                                    //   { type: 'delete', path: '/x' }\r\n                                                    // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply edits\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\n\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\n\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\n\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\n\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\n\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target JSON Schema draft 7 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\r\n\r\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst C = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the `Compile(...)` function to compile a type. Note that compilation is an expensive operation that should typically be performed once per type during application start up. TypeBox does not cache previously compiled types, so applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst errors = [...C.Errors(value)]                  // const errors = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nCompiled routines can be inspected with the `.Code()` function.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\r\n\r\nconsole.log(C.Code())                                // return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion policies. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\r\n\r\nThe TypeSystem module is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeSystem } from '@sinclair/typebox/system'\r\n```\r\n\r\n<a name='typesystem-types'></a>\r\n\r\n### Types\r\n\r\nUse the `Type(...)` function to create custom types. This function lets you specify custom value assertion logic and will return a type factory function which is used to instance the type. This function accepts two generic arguments, the first is the inference type, the second is options used to constrain the type. The following creates a Vector type.\r\n\r\n```typescript\r\ntype VectorOptions = { abs: boolean }\r\n\r\ntype Vector = { x: number, y: number }\r\n\r\nconst Vector = TypeSystem.Type<Vector, VectorOptions>('Vector', (options, value) => {\r\n  return (\r\n    typeof value === 'object' && value !== null &&\r\n    'x' in value && typeof value.x === 'number' &&\r\n    'y' in value && typeof value.y === 'number' &&\r\n    (options.abs ? (value.x === Math.abs(value.x) && value.y === Math.abs(value.y)) : true)\r\n  )\r\n})\r\n\r\nconst T = Vector({ abs: true })\r\n\r\ntype T = Static<typeof T>                            // type T = Vector\r\n\r\nconst R1 = Value.Check(T, { x: 1, y: 1 })            // const R1 = true\r\n\r\nconst R2 = Value.Check(T, { x: 1, y: '1' })          // const R2 = false\r\n\r\nconst R3 = Value.Check(T, { x: 1, y: -1 })           // const R3 = false\r\n```\r\n\r\n<a name='typesystem-formats'></a>\r\n\r\n### Formats\r\n\r\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\r\n\r\n```typescript\r\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\r\n\r\nconst T = Type.String({ format: 'lowercase' })\r\n\r\nconst A = Value.Check(T, 'Hello')                    // const A = false\r\n\r\nconst B = Value.Check(T, 'hello')                    // const B = true\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard JSON Schema assertion policies by default. It is possible to override some of these policies to have TypeBox assert inline with TypeScript static assertion rules. The following policy overrides are available.\r\n\r\n```typescript\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystem.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystem.AllowArrayObjects = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystem.AllowNaN = true\r\n```\r\n\r\n<a name='transform'></a>\r\n\r\n## TypeBox Transform\r\n\r\nTypeBox offers a small web based code generation tool that can be used to convert TypeScript types into TypeBox types as well as a variety of other runtime type representations.\r\n\r\n[TypeBox Transform Link Here](https://sinclairzx81.github.io/typebox-transform/)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that provide general tooling and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from JSON schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-client](https://github.com/flodlc/typebox-client) | Type safe http client library for Fastify |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    232 ms' │ '      8 ms' │ '   29.00 x' │\r\n│ Literal_Number             │    1000    │ '    179 ms' │ '      6 ms' │ '   29.83 x' │\r\n│ Literal_Boolean            │    1000    │ '    154 ms' │ '      3 ms' │ '   51.33 x' │\r\n│ Primitive_Number           │    1000    │ '    160 ms' │ '      7 ms' │ '   22.86 x' │\r\n│ Primitive_String           │    1000    │ '    149 ms' │ '      6 ms' │ '   24.83 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    191 ms' │ '      9 ms' │ '   21.22 x' │\r\n│ Primitive_Boolean          │    1000    │ '    135 ms' │ '      4 ms' │ '   33.75 x' │\r\n│ Primitive_Null             │    1000    │ '    144 ms' │ '      6 ms' │ '   24.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1144 ms' │ '     30 ms' │ '   38.13 x' │\r\n│ Object_Constrained         │    1000    │ '   1228 ms' │ '     24 ms' │ '   51.17 x' │\r\n│ Object_Vector3             │    1000    │ '    380 ms' │ '      9 ms' │ '   42.22 x' │\r\n│ Object_Box3D               │    1000    │ '   1771 ms' │ '     30 ms' │ '   59.03 x' │\r\n│ Tuple_Primitive            │    1000    │ '    471 ms' │ '     11 ms' │ '   42.82 x' │\r\n│ Tuple_Object               │    1000    │ '   1272 ms' │ '     15 ms' │ '   84.80 x' │\r\n│ Composite_Intersect        │    1000    │ '    606 ms' │ '     17 ms' │ '   35.65 x' │\r\n│ Composite_Union            │    1000    │ '    560 ms' │ '     22 ms' │ '   25.45 x' │\r\n│ Math_Vector4               │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Math_Matrix4               │    1000    │ '    419 ms' │ '      9 ms' │ '   46.56 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    382 ms' │ '      6 ms' │ '   63.67 x' │\r\n│ Array_Primitive_String     │    1000    │ '    324 ms' │ '      6 ms' │ '   54.00 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    301 ms' │ '      4 ms' │ '   75.25 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1734 ms' │ '     21 ms' │ '   82.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1509 ms' │ '     20 ms' │ '   75.45 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    824 ms' │ '     14 ms' │ '   58.86 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1619 ms' │ '     16 ms' │ '  101.19 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    773 ms' │ '     16 ms' │ '   48.31 x' │\r\n│ Array_Composite_Union      │    1000    │ '    822 ms' │ '     17 ms' │ '   48.35 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1131 ms' │ '     13 ms' │ '   87.00 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    661 ms' │ '     10 ms' │ '   66.10 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     13 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Primitive_String           │  1000000   │ '     19 ms' │ '     16 ms' │ '     10 ms' │ '    1.60 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    150 ms' │ '     41 ms' │ '     35 ms' │ '    1.17 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     17 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     18 ms' │ '     16 ms' │ '      9 ms' │ '    1.78 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1001 ms' │ '     31 ms' │ '     24 ms' │ '    1.29 x' │\r\n│ Object_Constrained         │  1000000   │ '   1288 ms' │ '     50 ms' │ '     36 ms' │ '    1.39 x' │\r\n│ Object_Vector3             │  1000000   │ '    439 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2109 ms' │ '     52 ms' │ '     45 ms' │ '    1.16 x' │\r\n│ Object_Recursive           │  1000000   │ '   5337 ms' │ '    356 ms' │ '    162 ms' │ '    2.20 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    164 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    744 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    764 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Composite_Union            │  1000000   │ '    516 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    262 ms' │ '     20 ms' │ '     11 ms' │ '    1.82 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1089 ms' │ '     37 ms' │ '     27 ms' │ '    1.37 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    276 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    228 ms' │ '     21 ms' │ '     14 ms' │ '    1.50 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    159 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5695 ms' │ '     77 ms' │ '     69 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5701 ms' │ '    127 ms' │ '    110 ms' │ '    1.15 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21267 ms' │ '   1664 ms' │ '    573 ms' │ '    2.90 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    702 ms' │ '     40 ms' │ '     32 ms' │ '    1.25 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3141 ms' │ '     68 ms' │ '     51 ms' │ '    1.33 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3145 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2134 ms' │ '     68 ms' │ '     31 ms' │ '    2.19 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1197 ms' │ '     37 ms' │ '     25 ms' │ '    1.48 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5323 ms' │ '    111 ms' │ '     96 ms' │ '    1.16 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '129.4 kb' │ ' 58.6 kb' │  '2.21 x'   │\r\n│ typebox/errors       │ '111.6 kb' │ ' 50.1 kb' │  '2.23 x'   │\r\n│ typebox/system       │ ' 76.5 kb' │ ' 31.7 kb' │  '2.41 x'   │\r\n│ typebox/value        │ '180.7 kb' │ ' 79.3 kb' │  '2.28 x'   │\r\n│ typebox              │ ' 75.4 kb' │ ' 31.3 kb' │  '2.41 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./typebox.d.ts","readmeFilename":"readme.md","_integrity":"sha512-AKj1g4O094yFQieQ/RDcuguUMA4T2WfZetcmttk8uVA/Cw+94SS2fMOraB3dfRJuyTLM20Z63p6jayWxlyHBug==","_from":"file:sinclair-typebox-0.30.0-dev-5.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-5_1690787321247_0.7262271003183987"},"_hasShrinkwrap":false},"0.30.0-dev-6":{"_id":"@sinclair/typebox@0.30.0-dev-6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"ba14756b110f34fae377d0f53f86ea0b129fc152","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-DGMcWvxLJYOygHeqEX9cmEsqeTR5R4OepZNNHPykqbf6aCEw/6cZGYSc5WW7xu2EyWXD9HFbNlHppB9vNZ9tAg==","_from":"file:sinclair-typebox-0.30.0-dev-6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-6_1690791404666_0.878776167597586"},"_hasShrinkwrap":false},"0.30.0-dev-7":{"_id":"@sinclair/typebox@0.30.0-dev-7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0-dev-7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"39b9fcb9427895ebca077c5db3ed861e6aef1650","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0-dev-7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-TZcJVBlSs4tFA0XBG/rkyEwJ1qcD0n21k1FPSwufr7SVTijAKIw9Zqknhscnzjf32mqxrfzkTUGWLYGSJo4ynw==","_from":"file:sinclair-typebox-0.30.0-dev-7.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0-dev-7_1690812339986_0.09473113343279382"},"_hasShrinkwrap":false},"0.30.0":{"_id":"@sinclair/typebox@0.30.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"3ab85aaa4bce87b108bf3a1d4841ea84e0ae247b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-7v+I+UuRm7S8rV6u1rz3MkXO5skN1QiqlTeIY6ShiuvhcEnzRIrj/bqzHQNb9M2O9d8Q1mepW7lJ9cNUA1HEVg==","_from":"file:sinclair-typebox-0.30.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.0_1690873305700_0.2641088922239663"},"_hasShrinkwrap":false},"0.30.1":{"_id":"@sinclair/typebox@0.30.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"e34963817dad11a39f18f704c533d3a641639fdf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gEhL8rDxir3+Q0uYMeT9rQgp1g9YazEphp4tBdc10e0zMm/0pT3G1FlLHyN1DMZUI4Vk6nebZvtt1evB0nXdiw==","_from":"file:sinclair-typebox-0.30.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.1_1690972066124_0.6792638178712562"},"_hasShrinkwrap":false},"0.30.2":{"_id":"@sinclair/typebox@0.30.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"6036b17f2ccf0ef8a308d8c352e3081075c43c57","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-PNEojrBZGQL+llfGfGn6EZNHUXxyvA3LeySMUxMk+i+GrtuT1nBBP3BPzzgJKW9b7lUMa9KxHVx+CIPEy5bL5w==","_from":"file:sinclair-typebox-0.30.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.2_1690974068622_0.9966290001682034"},"_hasShrinkwrap":false},"0.30.3":{"_id":"@sinclair/typebox@0.30.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"fedbaa4543ec80056f5df43c89253cfdc1d32b40","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Cho1WteNnbVrd6jYVr1mLeGF6nVkUVgMJdYV0FeGI+I1iSNIUu1O8lQbfz+Gh3DczZT7qoYeOuZS/wck2rtO8Q==","_from":"file:sinclair-typebox-0.30.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.3_1691224694549_0.8205580707831439"},"_hasShrinkwrap":false},"0.30.4":{"_id":"@sinclair/typebox@0.30.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.30.4","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/chai":"^4.3.3","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","chai":"^4.3.6","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"8c918bc127385272a9f988fa2bcf7d3259599e5e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.30.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-wFuuDR+O1OAE2GL0q68h1Ty00RE6Ihcixr55A6TU5RCvOUHnwJw9LGuDVg9NxDiAp7m/YJpa+UaOuLAz0ziyOQ==","_from":"file:sinclair-typebox-0.30.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.30.4_1691239420930_0.135149747192846"},"_hasShrinkwrap":false},"0.31.0-dev-1":{"_id":"@sinclair/typebox@0.31.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"a3c755b97d9db5e9e6a4f7767fe6d88235d605f2","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0-dev-1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Xu0ci9wK3HvjzO1wCJQ9SRyWGAEvLcsQhJeO55B9Yg9riBCDbR1Tawv4SUBqi6HzanTH2Az5NP5ay1ZVmaUIKQ==","_from":"file:sinclair-typebox-0.31.0-dev-1.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0-dev-1_1691532899325_0.440843669369682"},"_hasShrinkwrap":false},"0.31.0-dev-2":{"_id":"@sinclair/typebox@0.31.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"0c256d48b44d6afb712fa67adad675d420800d47","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0-dev-2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Pp50GMRKmBjtB5cmCUFJxvy63R/xj2v2WhTwBeWBoMDmtATOskfUKxHiiYfpJC9/acjErVsddK2GSUGw9+ozPg==","_from":"file:sinclair-typebox-0.31.0-dev-2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0-dev-2_1691535759005_0.9622796716288109"},"_hasShrinkwrap":false},"0.31.0":{"_id":"@sinclair/typebox@0.31.0","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.0","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"afd4478bf839b276be62e93b4df474d5b01eeb60","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.0.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bL3KIy1cqi4wyKwJZ3szckq0k/IuLluwQ9IB8QMNS2ogHGiqkempV7uO52Tjr79oBgOnlRaOhIf5qkc8HH9KhA==","_from":"file:sinclair-typebox-0.31.0.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.0_1691789746220_0.6147373461731431"},"_hasShrinkwrap":false},"0.31.1":{"_id":"@sinclair/typebox@0.31.1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"f9edccb4447481e62d93639361bf643c911dfa8a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-oAGsVU6u4k7pNGfDZG1ujFuku25yV3lFmyxZXXLylm0Pf2Qh9pgGFpGwPbyyFZl9PYH4thS9qRcfs3C2Sn3/SA==","_from":"file:sinclair-typebox-0.31.1.tgz","_nodeVersion":"20.3.1","_npmVersion":"9.6.7","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.1_1691984972683_0.05885190593091738"},"_hasShrinkwrap":false},"0.31.2":{"_id":"@sinclair/typebox@0.31.2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.1.6"},"main":"./typebox.js","dist":{"shasum":"88b998a269479e343718996d920938e2f7b30ed4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.2.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-+LlOCOcCcsq6zxt1Ld9VkOSTMY6189dBtHHxb2nUftYpiUFXX0mKuK/UgtX84haktCs/x8j8k29v//ohdjlToA==","_from":"file:sinclair-typebox-0.31.2.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.2_1692732914608_0.7840422654140333"},"_hasShrinkwrap":false},"0.31.3":{"_id":"@sinclair/typebox@0.31.3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"0ddee232d923704e5e4b9b70a28a34c6a30fc849","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.3.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-9ie8Vuvtw+7CzFhTbwmqtnpTMuMl1TU1WhY/P3LZopp/oruyKHO7uO9FqDq/m7r0vAavZnsSmBI7EMOjtpaqow==","_from":"file:sinclair-typebox-0.31.3.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.3_1692948129652_0.1448890577198747"},"_hasShrinkwrap":false},"0.31.4":{"_id":"@sinclair/typebox@0.31.4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"d191cf12fb88cc987fecd439c6af7ec786b600ed","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.4.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-bNZ4CwuZYxJ7yvCVE2zANanEsXUtPfdPQyLe3tT7i30QwfndMbVyVCK3wmHQQSybaK+vUu4SYWlxdAQqshIBHA==","_from":"file:sinclair-typebox-0.31.4.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.4_1693034773978_0.8455569852993023"},"_hasShrinkwrap":false},"0.31.5":{"_id":"@sinclair/typebox@0.31.5","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.5","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"10ae6c60fc523d7d695a730df1ac3dd9725ce207","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.5.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-4fbqH1ONle98ULTQakJFVNwGwSx+rv90HEnjZGt1GoApMKooUw1WXw3ub+Ew7rInmyDcwsjIxiHt39bkWzeCBA==","_from":"file:sinclair-typebox-0.31.5.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.5_1693116207042_0.7289156502756995"},"_hasShrinkwrap":false},"0.31.6":{"_id":"@sinclair/typebox@0.31.6","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"cbe60cc433595ba9c69f472688110526285e4899","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.6.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-u6Y0wqb1VAO+WwfRgJTzxNsv5P8QmF50Q2tVTDSdyLZcEwhcTujibc9vfPzJB9pYMvLNQtQGKyvlcexUoHYkKg==","_from":"file:sinclair-typebox-0.31.6.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.6_1693301295065_0.11727929055730257"},"_hasShrinkwrap":false},"0.31.7":{"_id":"@sinclair/typebox@0.31.7","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.7","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"758c8e6de5403f85cbdb377c19f92eab6e1fa076","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.7.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-cl6qKMXSK95aMwIzSQJeenKBtPmE1+hqts3vJe93EaSa7cIaNjz3A5yMKkgW/bAhjnOpa/yiCCV1pOG1bzzv0A==","_from":"file:sinclair-typebox-0.31.7.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.7_1693334778025_0.5379311470690515"},"_hasShrinkwrap":false},"0.31.8":{"_id":"@sinclair/typebox@0.31.8","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"61023e06173069e7fcadaeb8c0905d2a097e47ae","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.8.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-1FdxgmuUqQWprlAHzGKTH3qSeNzbYnHXD65WIZOI037hcCZVw+r8SoFd8OIFUrbQxEI+MhHArCvKlndLvfw/bg==","_from":"file:sinclair-typebox-0.31.8.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.8_1693428016234_0.10418235844936508"},"_hasShrinkwrap":false},"0.31.9":{"_id":"@sinclair/typebox@0.31.9","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f6eebba4f3631624d0895283723116d3e1d8d91d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.9.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-p73UG4m/1h/1hraNZtabquOkryCbqpqrwok9T3XqPwp8H7V4+t12mzeZLVzxSNvtasI/44f5IZxNwpwjPX+Uwg==","_from":"file:sinclair-typebox-0.31.9.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.9_1693752879003_0.20649502754230475"},"_hasShrinkwrap":false},"0.31.10":{"_id":"@sinclair/typebox@0.31.10","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"70fa2eaface2de6a16fa2965b64fa2cb261bfcd5","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.10.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-d4xyuqhmWHQk3glt5hS2GXJ2IM9ZkUbMWJeKLpHbpQ1G80CGXZfem2smpbXlazQmbGSWNekjSrMVgCstiz1xoQ==","_from":"file:sinclair-typebox-0.31.10.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.10_1693849932650_0.5600767668152526"},"_hasShrinkwrap":false},"0.31.11":{"_id":"@sinclair/typebox@0.31.11","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"8f3aa21a672101036c177d7b9d98e9cec2b345ee","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.11.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-jTrfYeIdeU0ZZ3M5b2Mbf86Zc+STPjsPU6TJAauapqWippeybZGM8GZEHM3r03jt+ggrnZrQyeYTzw1m9eT7HQ==","_from":"file:sinclair-typebox-0.31.11.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.11_1693928926880_0.4989610280240433"},"_hasShrinkwrap":false},"0.31.12":{"_id":"@sinclair/typebox@0.31.12","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"672f66a4c7af4fd9d8f36c037c3df27d3419dd1a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.12.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-XeIsBp4yYM92lHfVBCFyhImXlUt3EbyY+4FNCW+Lr7U+8pjli//9WVYo3tALrcB7frOOQxXiL2SOu0tY0mNYEw==","_from":"file:sinclair-typebox-0.31.12.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.12_1693933075100_0.5416820601349286"},"_hasShrinkwrap":false},"0.31.13":{"_id":"@sinclair/typebox@0.31.13","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"e91b39b79c35b52e4eb56b1b89ec505b2e02b605","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.13.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-V4UoNN1XlRiQd/s1iWlLUTmfGCKDB+B7KteI/m6OKPBXPsVeZ7bqTDrdD+9mAWwFXaXqYnX06+tzVjK3bcvS9g==","_from":"file:sinclair-typebox-0.31.13.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.13_1693936359664_0.25284302427485184"},"_hasShrinkwrap":false},"0.31.14":{"_id":"@sinclair/typebox@0.31.14","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"0c1f3f8dbb6c866088faab04af7fa7cda7f8e8c3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.14.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-2spk0ie6J/4r+nwb55OtBXUn5cZLF9S98fopIjuutBVoq8yLRNh+h8QvMkCjMu5gWBMnnZ/PUSXeHE3xGBPKLQ==","_from":"file:sinclair-typebox-0.31.14.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.14_1693944954668_0.4943767959973815"},"_hasShrinkwrap":false},"0.31.15":{"_id":"@sinclair/typebox@0.31.15","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.15","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"182bff2527c2953540f0b5e8d1851888fb57b2eb","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.15.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-gheE0Z2QWB/EuUwirniP+vq17N0MdQ+9bKyy2lPJzcBin6piBxOrazTYOB18N+oeBwVVepAmlqqo9KbpSl9DOA==","_from":"file:sinclair-typebox-0.31.15.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.15_1694675896349_0.7995434864007394"},"_hasShrinkwrap":false},"0.31.16":{"_id":"@sinclair/typebox@0.31.16","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.16","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"29e9b9644111d86bf4093c55c2337810a6ae7e21","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.16.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-US3ytBkDVP1JqooE1pBXgh97c8ljW05RkZj0MM6eVAsnZOtjalurleXy6LwssfazPDqQk/Vy64Ood77L4jG7Dw==","_from":"file:sinclair-typebox-0.31.16.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.16_1695625181372_0.41246447406395026"},"_hasShrinkwrap":false},"0.31.17":{"_id":"@sinclair/typebox@0.31.17","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.17","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.17.1","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f9ceed480957b919b203bb0b3e27bc559d1e8e19","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.17.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-GVYVHHOGINx+DT2DwjXoCQO0mRpztYKyb3d48tucuqhjhHpQYGp7Xx7dhhQGzILx/beuBrzfITMC7/5X7fw+UA==","_from":"file:sinclair-typebox-0.31.17.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.17_1695712949768_0.15572870385508786"},"_hasShrinkwrap":false},"0.31.18":{"_id":"@sinclair/typebox@0.31.18","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.18","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"556a3de891d5daa004875f6d86c69754084428a6","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.18.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-p2JGz+SciGJVl1zokCIK15f7LYDrI2ZsxItcLhkAyx50hEYEj/Qdy7z30qRYiakzdIu8dV4DfBi+e6xEZuugiQ==","_from":"file:sinclair-typebox-0.31.18.tgz","_nodeVersion":"20.3.1","_npmVersion":"7.24.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.18_1697551093030_0.0032364591017253197"},"_hasShrinkwrap":false},"0.31.19":{"_id":"@sinclair/typebox@0.31.19","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.19","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"99f7b9746546b2b38b9d02e1fbd5d07e558b04c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.19.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-8GznR/3FgDgA20Its5gd+BZqbtE0amjEidsIX4T2stmDFcaAcQviGsBmzlBtJ0E1Gxk8VtHxL4rt4/KSc/UdxQ==","_from":"file:sinclair-typebox-0.31.19.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.19_1698258870408_0.2736483475559721"},"_hasShrinkwrap":false},"0.31.20":{"_id":"@sinclair/typebox@0.31.20","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.20","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"74e855ba87a795f10c1eb9d791c7316d930d292e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.20.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-pqkf2X6fc1yk6c3Rk41cT8NYFKmzngl8TVHy375X7ihlONCsX7/YTReRLyZX7zZhuUUBx9KTZPFFDZo6AIERCw==","_from":"file:sinclair-typebox-0.31.20.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.20_1698312280235_0.11409787401523608"},"_hasShrinkwrap":false},"0.31.21":{"_id":"@sinclair/typebox@0.31.21","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.21","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"d52d8e35f71e5651042aa0237e918e4b21fbbbf8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.21.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Wtq/K44EMkREaXytK+2c5DrygtYsH7ZxT0StQL8HMJz2BoOM7NZ/xfrUFBVuZxDrhJCoXf5Im282P2CCz5DHwQ==","_from":"file:sinclair-typebox-0.31.21.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.21_1698580122964_0.44984771980197724"},"_hasShrinkwrap":false},"0.31.22":{"_id":"@sinclair/typebox@0.31.22","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.22","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f13fa4050a7e883d252365902e38186fa0dc8ab8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.22.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-CKviMgpcXd8q8IsQQD8cCleswe4/EkQRcOqtVQcP1e+XUyszjJYjgL5Dtf3XunWZc2zEGmQPqJEsq08NiW9xfw==","_from":"file:sinclair-typebox-0.31.22.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.22_1698940182867_0.7848260405558538"},"_hasShrinkwrap":false},"0.31.23":{"_id":"@sinclair/typebox@0.31.23","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.23","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"5ae0235824e63b595952dceb001b813349688b1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.23.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-ZzrzE8yCrWWU4mcBstBgdlBMjB8My3ESY9nZ/v996GptIJb4+MU1p7s1Qxrc2xvZeOiDDnAheLLmdHjPgZV79g==","_from":"file:sinclair-typebox-0.31.23.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.23_1699371263183_0.9664026554798715"},"_hasShrinkwrap":false},"0.31.24":{"_id":"@sinclair/typebox@0.31.24","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.24","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"3b718fbb4240953e83faa49be43b43ec9506adba","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.24.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-3zmHQ+4ta05eLGjm/gq+hkFWS4rfr3/zUw8331Yg1X1IdqyDnt5FvoRx5LkK/YdvvJuO04x+E+Y/09Kde588Ng==","_from":"file:sinclair-typebox-0.31.24.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.24_1700030003352_0.2159360944541322"},"_hasShrinkwrap":false},"0.31.25":{"_id":"@sinclair/typebox@0.31.25","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.25","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"6ad0dca016c5a4a8f4578118815c3e4fe340c3fe","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.25.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-tc075wfx6qCftSuNHq7kPNVTNhb5qBDf7B+c7pBdLkzxGsXdsqeinlRZQuGzrSowSh7nxEKvZKRUdbRGqy0GCA==","_from":"file:sinclair-typebox-0.31.25.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.25_1700056121068_0.7892015606687566"},"_hasShrinkwrap":false},"0.31.26":{"_id":"@sinclair/typebox@0.31.26","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.26","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"f17fbefcfb38311e7ee2b9a3071f86cc62ab43cc","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.26.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-0S5BGB/Tle1kVa1pT2k2sc+wHTCB28+ivuetmZDCRV8I0iFKaNfk6HbvVyLEFBzZy56dp0dw+YDJ9Ed+YAAL7A==","_from":"file:sinclair-typebox-0.31.26.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.26_1700299362858_0.544186268354792"},"_hasShrinkwrap":false},"0.31.27":{"_id":"@sinclair/typebox@0.31.27","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.27","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"9776614f4c5ee4434043e0ba1499d297800b3d46","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.27.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-Gf/P/hssx1ew6VNA5yLw3eLQb+fuuo63mlobVUSQHNCrQLXx4OzRa7Yt/mTZNGImBSrJo1a0bWR1NmpVjrU6xw==","_from":"file:sinclair-typebox-0.31.27.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.27_1700423117480_0.17875870350417"},"_hasShrinkwrap":false},"0.31.28":{"_id":"@sinclair/typebox@0.31.28","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.31.28","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.2.2"},"main":"./typebox.js","dist":{"shasum":"b68831e7bc7d09daac26968ea32f42bedc968ede","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.31.28.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-/s55Jujywdw/Jpan+vsy6JZs1z2ZTGxTmbZTPiuSL2wz9mfzA2gN1zzaqmvfi4pq+uOt7Du85fkiwv5ymW84aQ==","_from":"file:sinclair-typebox-0.31.28.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.31.28_1700485032007_0.8377792278241056"},"_hasShrinkwrap":false},"0.32.0-dev-1":{"_id":"@sinclair/typebox@0.32.0-dev-1","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-1","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","build":"hammer task build","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^18.11.9","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./typebox.js","dist":{"shasum":"3edc8ab536bca3dd153045fb26e7d7da1f6ec947","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-1.tgz"},"types":"./typebox.d.ts","_integrity":"sha512-w1FOdYZ7SvVMVFJvI7y0z9oK2c042rjUXTNEVYcyzsWBNppYp318sAg3vDAQlzDHNUeAXVLMxffrA6d8wjl+uw==","_from":"file:sinclair-typebox-0.32.0-dev-1.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-1_1701339204704_0.9492457449975578"},"_hasShrinkwrap":false},"0.32.0-dev-10":{"_id":"@sinclair/typebox@0.32.0-dev-10","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-10","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"ec8744d9029cfa7000acf32d35c97aa74b458099","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-10.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-FYb+t0IhNIBRPLlK7OSm7kWJjuku7cMpkKyG9GVVgd57fDiBBzwxIS1v1lYCu3E/+t28CAupvIwbnlpIAC3H1Q==","_from":"file:sinclair-typebox-0.32.0-dev-10.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-10_1701508816106_0.8616030386948672"},"_hasShrinkwrap":false},"0.32.0-dev-11":{"_id":"@sinclair/typebox@0.32.0-dev-11","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-11","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"55244d6d1cdec3b42b2d483460b5c2f025348857","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-11.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-qNU9nI/7qGkNREpp1PGq2Pv5GNdOhOFRF548U4HqUBoIdCKnen3vUbesGjtcMoLe3P6tbrWU0gNXb52PtfB7Xw==","_from":"file:sinclair-typebox-0.32.0-dev-11.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-11_1701524144522_0.8767059968626214"},"_hasShrinkwrap":false},"0.32.0-dev-12":{"_id":"@sinclair/typebox@0.32.0-dev-12","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-12","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"040168caf430bc4bef3f629c4cc9d246d8c2b713","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-12.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-JpW4q+5kErpuBSK9XFNxaIC0OXJtK2e1zlgLyrgSzRhSSVl92gcL9I9GdQRiR+PWWYH4Trfz03t3Kp9H6t0/mw==","_from":"file:sinclair-typebox-0.32.0-dev-12.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-12_1701617086836_0.42992935497086693"},"_hasShrinkwrap":false},"0.32.0-dev-13":{"_id":"@sinclair/typebox@0.32.0-dev-13","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-13","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"c1b163a73ac7b7933bd09e60f10ac6150d75de4e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-13.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-mY04jGlpuzF6rLoGs3ypVVoH48881HeOaoP2V2YBPdzwlktYcYRCjEBwO3bqYM+AhcAqL8E29E6cyhdUdhebHw==","_from":"file:sinclair-typebox-0.32.0-dev-13.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-13_1701678614384_0.07321368713450904"},"_hasShrinkwrap":false},"0.32.0-dev-14":{"_id":"@sinclair/typebox@0.32.0-dev-14","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-14","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"d94de0600e5f3461ae8bdf041317e4e4d2ad5647","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-14.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-qY/dg4OCxbkNl/5AWgzsC3FlqsUV3FpPwvUzQzayjfMPFf0Z9GHTlS78Tc8ua/Xxy+c4CS8jm+Jtols4h36b7A==","_from":"file:sinclair-typebox-0.32.0-dev-14.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-14_1701786126823_0.6916619598532394"},"_hasShrinkwrap":false},"0.32.0-dev-15":{"_id":"@sinclair/typebox@0.32.0-dev-15","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-15","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"57f446458f6805723b6e39de39021203f6193080","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-15.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Modular](#types-modular)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modular'></a>\r\n\r\n### Modular Types\r\n\r\nTypeBox implements a modular type system. The following imports the full type system (recommended)\r\n\r\n```typescript\r\nimport { Type } from '@sinclair/typebox'             // 36.5 kb minified\r\n```\r\nThe following imports types individually which enables modern bundlers to optimize bundle sizes via tree shaking.\r\n```typescript\r\nimport { Object, Number } from '@sinclair/typebox'   // 6.4 kb minified\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports Template Literal types with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript Template Literal syntax. TypeBox encodes Template Literals as regular expression string patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.3 kb' │ ' 52.4 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.0 kb' │ ' 61.5 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.0 kb' │ ' 36.5 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-6qOG/AGmazd6CtkoHxhZiQn/VxBjfQZV2n3tyuokemCLfjOLPiFLhA1IKK6VHaFLnodTYw2O6+hg70au0JY+sA==","_from":"file:sinclair-typebox-0.32.0-dev-15.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-15_1701870711300_0.9724360760426025"},"_hasShrinkwrap":false},"0.32.0-dev-16":{"_id":"@sinclair/typebox@0.32.0-dev-16","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-16","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"39a096eef89dc0beddc077d0dc11527c4d494eda","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-16.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Type Modules\r\n\r\nTypeBox uses a modular type system and supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique allows modern bundlers to tree shake unused types. This can reduce overall bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-2ZU4e0Jy9r4+yN//XduC/JhijPM7XxUfsYxrw+t5DJfIGTqceLLBDYGmWE0hsRsP0APU+uyFwwqTRHxCElsoFA==","_from":"file:sinclair-typebox-0.32.0-dev-16.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-16_1701934907703_0.14809380003578898"},"_hasShrinkwrap":false},"0.32.0-dev-17":{"_id":"@sinclair/typebox@0.32.0-dev-17","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-17","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"c078255189ca290eab7207b0deb79bcb4c878b07","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-17.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-OmvOC9TKFsGD7m+v+M23PQ4jsbodzFtIsjeGYQYx902kyDwiUbuomKrQ+ANs1Y/5elDQ+Q85DeDdBsvMIopfkg==","_from":"file:sinclair-typebox-0.32.0-dev-17.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-17_1701938116742_0.8082912823199455"},"_hasShrinkwrap":false},"0.32.0-dev-18":{"_id":"@sinclair/typebox@0.32.0-dev-18","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-18","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"97b8373b4b49180dad74c576d48f0165e3dadf2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-18.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-xf4IZEwDLDkEfqtQsTU8PN2mB2O7YqwtFGYGEVWkao0oaEXkGtsnvRyo9eGxwW2urFR93UcaA90v9fOksUNeJA==","_from":"file:sinclair-typebox-0.32.0-dev-18.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-18_1702022672297_0.022591453628886482"},"_hasShrinkwrap":false},"0.32.0-dev-19":{"_id":"@sinclair/typebox@0.32.0-dev-19","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-19","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"d9e6b34abf618799491e815029f26efe450ab5aa","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-19.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox has a modular type system that supports selective type imports. Using selective imports can be useful in resource constrained environments as the technique enables modern bundlers to tree shake unused code leading to reduced bundle sizes. The following selectively imports a few types.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts each key (`K`) as the second. This type can be used with Conditional and Indexed Access types to allow for generalized property remapping irrespective of property type. The following example remaps each property of `T` to be `T[K] | null`.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Union([                                //   [K in keyof T]: T[K] | null\r\n    Type.Index(T, K),                                // }\r\n    Type.Null()                                      //\r\n  ])                                                 // ... runtime mapped as\r\n})                                                   //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TUnion<[TNumber, TNull]>,\r\n                                                     //   y: TUnion<[TString, TNull]>,\r\n                                                     //   z: TUnion<[TBoolean, TNull]>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-7euPCdhmlAVMl7ocKJGRf8OCtnG4p60F14rGiK1pynf4KSwAfYHrztonXzFYFv+KGzPqsNvhBYX61nSDtTUjTQ==","_from":"file:sinclair-typebox-0.32.0-dev-19.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-19_1702030362425_0.5497631686403808"},"_hasShrinkwrap":false},"0.32.0-dev-2":{"_id":"@sinclair/typebox@0.32.0-dev-2","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-2","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build:esm":"hammer task build_esm","build:cjs":"hammer task build_cjs","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./cjs/index.js","dist":{"shasum":"6aa3f8d2d218596d16acf9b941b3639d3913632d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-2.tgz"},"module":"./esm/index.mjs","types":"./esm/index.d.mts","_integrity":"sha512-89x/4VrgjDuPqftJm1O/V7g1N/x0u/efEKHW+FZzPoZ2ZzZ5EMtgD8jtkCWRbn07cACFYONn0vy96zKCck8uUw==","_from":"file:sinclair-typebox-0.32.0-dev-2.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-2_1701351674965_0.31282098806285075"},"_hasShrinkwrap":false},"0.32.0-dev-20":{"_id":"@sinclair/typebox@0.32.0-dev-20","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-20","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"11d3eba86a2f02bff8255f319980f4eaab517088","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-20.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types, this leading to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts a union of property keys as the first argument, and a type mapping function which accepts a distributive key (`K`) as the second. The following remaps each property of `T` to be optional.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = {\r\n  return Type.Optional(Type.Index(T, K))             //   [K in keyof T]?: T[K]\r\n})                                                   // }\r\n                                                     //\r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-mwP83V9TA+aIBfpkCyM4EVYlOic5Y1BvcQEy/NEgCXzu6jPPoqLZbSDLA5mqQ251xpGoJU9ZgVoxLoozFUhXeg==","_from":"file:sinclair-typebox-0.32.0-dev-20.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-20_1702049584265_0.2553132108844789"},"_hasShrinkwrap":false},"0.32.0-dev-21":{"_id":"@sinclair/typebox@0.32.0-dev-21","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-21","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"16578f9373a2f4da1ae3bf3f6a5803be087be90c","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-21.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-9UwbKjIIxp05SlEQV+ba3A6lUy1SsXd2neL46YUgdw2gks1vXfzzsPEdntTjIaxFLPDyO3GGU8xte1bjnVXVZg==","_from":"file:sinclair-typebox-0.32.0-dev-21.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-21_1702183933100_0.8610675907485126"},"_hasShrinkwrap":false},"0.32.0-dev-22":{"_id":"@sinclair/typebox@0.32.0-dev-22","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-22","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"f00f0b2c7d68de5beb01c8881783f914a0136b79","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-22.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-fYL6U/77HUyDSeXo+LAlIxAM6kcAmdxeEzCBUURXnmQatP9HugEK5MfvE7KfpuJ6FI+xtvLy9ny6IjniRKvXpg==","_from":"file:sinclair-typebox-0.32.0-dev-22.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-22_1702217724193_0.03962458512595357"},"_hasShrinkwrap":false},"0.32.0-dev-23":{"_id":"@sinclair/typebox@0.32.0-dev-23","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-23","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ac29755cbcc17d9bf0686dfc9691776af7c90347","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-23.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The Json Schema produced by this library is designed to match the static type checking rules of the TypeScript compiler. TypeBox provides a unified type that can be statically checked by the TypeScript compiler and runtime asserted using standard Json Schema validation.\r\n\r\nThis library enables Json Schema to be created with the same expressiveness as TypeScript's type system. It can be used either as a simple tool to build up complex schematics or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Modules](#types-modules)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Conditional](#types-conditional)\r\n  - [Mapped](#types-mapped)\r\n  - [Indexed](#types-indexed)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-modules'></a>\r\n\r\n### Modules\r\n\r\nTypeBox supports a modular type system that allows for selective type imports. Using selective imports can be helpful in resource constrained environments as it enables modern bundlers to tree shake unused types. This can lead to reduced bundle sizes.\r\n\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Object({                                   // const T: TObject<{\r\n  x: Number(),                                       //  x: TNumber,\r\n  y: String(),                                       //  y: TString,\r\n  z: Boolean()                                       //  z: TBoolean\r\n})                                                   // }>\r\n\r\ntype T = Static<typeof T>                            // type T = { \r\n                                                     //   x: number, \r\n                                                     //   y: string, \r\n                                                     //   z: boolean \r\n                                                     // }\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This will replace any `$ref` with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literals with Type.TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expression patterns which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime Conditional types with Type.Extends. This type runs a structural assignability check against the first and second arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports Mapped types with Type.Mapped. This type accepts two arguments, the first a union of literal keys and the second a type mapping function which receives a mapping key `K`. The following remaps the type `T` to be `Partial<T>` using type mapping.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst M = Type.Mapped(Type.KeyOf(T), K => {          // type M = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // \r\n                                                     \r\n                                                     // ... runtime mapped as\r\n                                                     //\r\n                                                     // const M: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access types with Type.Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T: unknown = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '118.7 kb' │ ' 52.5 kb' │  '2.26 x'   │\r\n│ typebox/errors       │ ' 55.1 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.6 kb' │ '  2.0 kb' │  '2.31 x'   │\r\n│ typebox/value        │ '144.8 kb' │ ' 61.8 kb' │  '2.34 x'   │\r\n│ typebox              │ ' 87.7 kb' │ ' 36.7 kb' │  '2.39 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-yfd7OK2sBv4ITjirkmgDpDnpEmq2IzpYh5hKzI/L8U/hVdW4Uncs45wtjFpNcSUQsOB74pg2cb39wxZB37KDLQ==","_from":"file:sinclair-typebox-0.32.0-dev-23.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-23_1702219093715_0.09320221532624906"},"_hasShrinkwrap":false},"0.32.0-dev-24":{"_id":"@sinclair/typebox@0.32.0-dev-24","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-24","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"f28f525a63614a8dab39ebd5cacdaa4f03556ea4","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-24.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluates as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '119.9 kb' │ ' 52.5 kb' │  '2.29 x'   │\r\n│ typebox/errors       │ ' 55.5 kb' │ ' 25.2 kb' │  '2.21 x'   │\r\n│ typebox/system       │ '  4.7 kb' │ '  2.0 kb' │  '2.33 x'   │\r\n│ typebox/value        │ '146.8 kb' │ ' 61.9 kb' │  '2.37 x'   │\r\n│ typebox              │ ' 90.7 kb' │ ' 37.7 kb' │  '2.40 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-o0wRofs4pondSFt3q8Xvbq3Gv2XOXzLBouGeQBsTNexdr4HTklRjKRbIgBKIw8BkQ+mI+sXzfb7qcrZyGFd6PA==","_from":"file:sinclair-typebox-0.32.0-dev-24.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-24_1702276394587_0.9137285489766649"},"_hasShrinkwrap":false},"0.32.0-dev-25":{"_id":"@sinclair/typebox@0.32.0-dev-25","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-25","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"5e394b938cda6d466d26d00c9abc9af2b999f05f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-25.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '120.5 kb' │ ' 52.7 kb' │  '2.29 x'   │\r\n│ typebox/errors       │ ' 55.5 kb' │ ' 25.2 kb' │  '2.20 x'   │\r\n│ typebox/system       │ '  4.7 kb' │ '  2.0 kb' │  '2.33 x'   │\r\n│ typebox/value        │ '147.4 kb' │ ' 62.2 kb' │  '2.37 x'   │\r\n│ typebox              │ ' 91.3 kb' │ ' 38.0 kb' │  '2.40 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-ZA154KxWufyWQDKvwDzOqlIIysCY6fThKcCydlB/eLWsMQzngGqWVEDO5EPq6ih1o0C5OQCpSfyCjUL/tqnKTA==","_from":"file:sinclair-typebox-0.32.0-dev-25.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-25_1702355895087_0.8391608982725174"},"_hasShrinkwrap":false},"0.32.0-dev-26":{"_id":"@sinclair/typebox@0.32.0-dev-26","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-26","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"0355e3b1535f914df77fadcf194a4037343f3a2b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-26.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is designed to be a runtime type system with capabilities similar to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    236 ms' │ '      9 ms' │ '   26.22 x' │\r\n│ Literal_Number             │    1000    │ '    205 ms' │ '     13 ms' │ '   15.77 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      4 ms' │ '   42.00 x' │\r\n│ Primitive_Number           │    1000    │ '    170 ms' │ '      8 ms' │ '   21.25 x' │\r\n│ Primitive_String           │    1000    │ '    162 ms' │ '      7 ms' │ '   23.14 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    211 ms' │ '     10 ms' │ '   21.10 x' │\r\n│ Primitive_Boolean          │    1000    │ '    139 ms' │ '      4 ms' │ '   34.75 x' │\r\n│ Primitive_Null             │    1000    │ '    146 ms' │ '      5 ms' │ '   29.20 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1160 ms' │ '     33 ms' │ '   35.15 x' │\r\n│ Object_Constrained         │    1000    │ '   1257 ms' │ '     26 ms' │ '   48.35 x' │\r\n│ Object_Vector3             │    1000    │ '    393 ms' │ '      8 ms' │ '   49.13 x' │\r\n│ Object_Box3D               │    1000    │ '   1795 ms' │ '     30 ms' │ '   59.83 x' │\r\n│ Tuple_Primitive            │    1000    │ '    542 ms' │ '     16 ms' │ '   33.88 x' │\r\n│ Tuple_Object               │    1000    │ '   1330 ms' │ '     17 ms' │ '   78.24 x' │\r\n│ Composite_Intersect        │    1000    │ '    624 ms' │ '     17 ms' │ '   36.71 x' │\r\n│ Composite_Union            │    1000    │ '    565 ms' │ '     19 ms' │ '   29.74 x' │\r\n│ Math_Vector4               │    1000    │ '    853 ms' │ '     10 ms' │ '   85.30 x' │\r\n│ Math_Matrix4               │    1000    │ '    406 ms' │ '     12 ms' │ '   33.83 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    401 ms' │ '     11 ms' │ '   36.45 x' │\r\n│ Array_Primitive_String     │    1000    │ '    385 ms' │ '      6 ms' │ '   64.17 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    347 ms' │ '      8 ms' │ '   43.38 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1904 ms' │ '     25 ms' │ '   76.16 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1582 ms' │ '     20 ms' │ '   79.10 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    864 ms' │ '     11 ms' │ '   78.55 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1658 ms' │ '     16 ms' │ '  103.63 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    786 ms' │ '     17 ms' │ '   46.24 x' │\r\n│ Array_Composite_Union      │    1000    │ '    844 ms' │ '     16 ms' │ '   52.75 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1192 ms' │ '     10 ms' │ '  119.20 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    688 ms' │ '     10 ms' │ '   68.80 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     19 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     14 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    164 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '    966 ms' │ '     33 ms' │ '     24 ms' │ '    1.38 x' │\r\n│ Object_Constrained         │  1000000   │ '   1275 ms' │ '     52 ms' │ '     42 ms' │ '    1.24 x' │\r\n│ Object_Vector3             │  1000000   │ '    427 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Object_Box3D               │  1000000   │ '   2024 ms' │ '     56 ms' │ '     50 ms' │ '    1.12 x' │\r\n│ Object_Recursive           │  1000000   │ '   5263 ms' │ '    358 ms' │ '    164 ms' │ '    2.18 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    157 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Tuple_Object               │  1000000   │ '    767 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    769 ms' │ '     26 ms' │ '     15 ms' │ '    1.73 x' │\r\n│ Composite_Union            │  1000000   │ '    501 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    250 ms' │ '     23 ms' │ '     11 ms' │ '    2.09 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1073 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    264 ms' │ '     21 ms' │ '     12 ms' │ '    1.75 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    242 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    151 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5864 ms' │ '     66 ms' │ '     58 ms' │ '    1.14 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5996 ms' │ '    138 ms' │ '    116 ms' │ '    1.19 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22515 ms' │ '   1625 ms' │ '    585 ms' │ '    2.78 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    737 ms' │ '     38 ms' │ '     31 ms' │ '    1.23 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3257 ms' │ '     77 ms' │ '     56 ms' │ '    1.38 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3119 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2108 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1078 ms' │ '     38 ms' │ '     26 ms' │ '    1.46 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4967 ms' │ '    126 ms' │ '     88 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '120.7 kb' │ ' 53.0 kb' │  '2.28 x'   │\r\n│ typebox/errors       │ ' 55.8 kb' │ ' 25.5 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.7 kb' │ '  2.0 kb' │  '2.33 x'   │\r\n│ typebox/value        │ '147.6 kb' │ ' 62.5 kb' │  '2.36 x'   │\r\n│ typebox              │ ' 91.3 kb' │ ' 38.0 kb' │  '2.40 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-JScTTo253fqiQL9MpYdUbSjg8qM5AZpIJ5Tuw78eXxgc7+r/JLHn7dKdsgZKbxmU53FWbuchUrNnGK9pqFOZHQ==","_from":"file:sinclair-typebox-0.32.0-dev-26.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-26_1702361510341_0.18220126424548"},"_hasShrinkwrap":false},"0.32.0-dev-27":{"_id":"@sinclair/typebox@0.32.0-dev-27","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-27","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"3b730fcdf517ad69eb60565c173442c13cb63214","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-27.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is built to be a runtime type system offering similar capabilities to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    242 ms' │ '     10 ms' │ '   24.20 x' │\r\n│ Literal_Number             │    1000    │ '    200 ms' │ '      8 ms' │ '   25.00 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      6 ms' │ '   28.00 x' │\r\n│ Primitive_Number           │    1000    │ '    165 ms' │ '      8 ms' │ '   20.63 x' │\r\n│ Primitive_String           │    1000    │ '    154 ms' │ '      6 ms' │ '   25.67 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    208 ms' │ '     14 ms' │ '   14.86 x' │\r\n│ Primitive_Boolean          │    1000    │ '    142 ms' │ '      6 ms' │ '   23.67 x' │\r\n│ Primitive_Null             │    1000    │ '    143 ms' │ '      6 ms' │ '   23.83 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1217 ms' │ '     31 ms' │ '   39.26 x' │\r\n│ Object_Constrained         │    1000    │ '   1275 ms' │ '     26 ms' │ '   49.04 x' │\r\n│ Object_Vector3             │    1000    │ '    405 ms' │ '     12 ms' │ '   33.75 x' │\r\n│ Object_Box3D               │    1000    │ '   1833 ms' │ '     27 ms' │ '   67.89 x' │\r\n│ Tuple_Primitive            │    1000    │ '    475 ms' │ '     13 ms' │ '   36.54 x' │\r\n│ Tuple_Object               │    1000    │ '   1267 ms' │ '     30 ms' │ '   42.23 x' │\r\n│ Composite_Intersect        │    1000    │ '    604 ms' │ '     18 ms' │ '   33.56 x' │\r\n│ Composite_Union            │    1000    │ '    545 ms' │ '     20 ms' │ '   27.25 x' │\r\n│ Math_Vector4               │    1000    │ '    829 ms' │ '     12 ms' │ '   69.08 x' │\r\n│ Math_Matrix4               │    1000    │ '    405 ms' │ '     10 ms' │ '   40.50 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    372 ms' │ '     12 ms' │ '   31.00 x' │\r\n│ Array_Primitive_String     │    1000    │ '    327 ms' │ '      5 ms' │ '   65.40 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    300 ms' │ '      4 ms' │ '   75.00 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1755 ms' │ '     21 ms' │ '   83.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1516 ms' │ '     20 ms' │ '   75.80 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    825 ms' │ '     14 ms' │ '   58.93 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1616 ms' │ '     16 ms' │ '  101.00 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    776 ms' │ '     16 ms' │ '   48.50 x' │\r\n│ Array_Composite_Union      │    1000    │ '    820 ms' │ '     14 ms' │ '   58.57 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1166 ms' │ '     15 ms' │ '   77.73 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    695 ms' │ '      8 ms' │ '   86.88 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     16 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Literal_Boolean            │  1000000   │ '     15 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    155 ms' │ '     41 ms' │ '     34 ms' │ '    1.21 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1003 ms' │ '     32 ms' │ '     24 ms' │ '    1.33 x' │\r\n│ Object_Constrained         │  1000000   │ '   1265 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Object_Vector3             │  1000000   │ '    418 ms' │ '     22 ms' │ '     13 ms' │ '    1.69 x' │\r\n│ Object_Box3D               │  1000000   │ '   2035 ms' │ '     56 ms' │ '     49 ms' │ '    1.14 x' │\r\n│ Object_Recursive           │  1000000   │ '   5243 ms' │ '    326 ms' │ '    157 ms' │ '    2.08 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    153 ms' │ '     20 ms' │ '     12 ms' │ '    1.67 x' │\r\n│ Tuple_Object               │  1000000   │ '    781 ms' │ '     28 ms' │ '     18 ms' │ '    1.56 x' │\r\n│ Composite_Intersect        │  1000000   │ '    742 ms' │ '     25 ms' │ '     14 ms' │ '    1.79 x' │\r\n│ Composite_Union            │  1000000   │ '    558 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    246 ms' │ '     22 ms' │ '     11 ms' │ '    2.00 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1052 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    272 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    235 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    134 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   6280 ms' │ '     65 ms' │ '     59 ms' │ '    1.10 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   6076 ms' │ '    130 ms' │ '    119 ms' │ '    1.09 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22738 ms' │ '   1730 ms' │ '    635 ms' │ '    2.72 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    689 ms' │ '     35 ms' │ '     30 ms' │ '    1.17 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3266 ms' │ '     63 ms' │ '     52 ms' │ '    1.21 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3310 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2432 ms' │ '     69 ms' │ '     33 ms' │ '    2.09 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1158 ms' │ '     37 ms' │ '     24 ms' │ '    1.54 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5435 ms' │ '    132 ms' │ '     92 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '119.2 kb' │ ' 52.3 kb' │  '2.28 x'   │\r\n│ typebox/errors       │ ' 55.0 kb' │ ' 25.2 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.7 kb' │ '  2.0 kb' │  '2.33 x'   │\r\n│ typebox/value        │ '146.1 kb' │ ' 61.8 kb' │  '2.37 x'   │\r\n│ typebox              │ ' 90.1 kb' │ ' 37.3 kb' │  '2.41 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-pGai7CigzKh7V+nU8GsKFfVuirhNClOPahMIEkWzaypZxgAPX9Igi+4Pfyx9s8tALUV9izjJ5GQXbWUJLyg4Nw==","_from":"file:sinclair-typebox-0.32.0-dev-27.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-27_1702419052016_0.11450007963241982"},"_hasShrinkwrap":false},"0.32.0-dev-28":{"_id":"@sinclair/typebox@0.32.0-dev-28","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-28","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"184b179e31aacfbbccffdad30a8bcb661116dcd8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-28.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory Json Schema objects that infer as TypeScript types. The schematics produced by this library are designed to match the static type checking rules of the TypeScript compiler. TypeBox offers a unified type that can be statically checked by TypeScript and runtime asserted using standard Json Schema validation.\r\n\r\nThis library is built to be a runtime type system offering similar capabilities to TypeScript's static type system. It can be used as a simple tool to build up complex schematics or integrated into REST and RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Import](#types-import)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Template Literal](#types-template-literal)\r\n  - [Indexed](#types-indexed)\r\n  - [Mapped](#types-mapped)\r\n  - [Conditional](#types-conditional)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Transform](#types-transform)\r\n  - [Rest](#types-rest)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Policies](#typesystem-policies)\r\n- [Error Function](#error-function)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │    ? true                   │   type: 'boolean'              │\r\n│   Type.Literal(true),          │    : false                  │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Mapped(         │ type T = {                  │ const T = {                    │\r\n│   Type.Union([                 │   [_ in 'x' | 'y'] : number │   type: 'object',              │\r\n│     Type.Literal('x'),         │ }                           │   required: ['x', 'y'],        │\r\n│     Type.Literal('y')          │                             │   properties: {                │\r\n│   ]),                          │                             │     x: {                       │\r\n│   () => Type.Number()          │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/i)  │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'RegExp'               │\r\n│                                │                             │   source: 'abc'                │\r\n│                                │                             │   flags: 'i'                   │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-import'></a>\r\n\r\n### Import\r\n\r\nYou can import Type to bring in the full type system. This is recommended for most users.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n```\r\nYou can also import types individually. This approach enables modern bundlers to tree shake unused types.\r\n```typescript\r\nimport { Object, Number, String, Boolean, type Static } from '@sinclair/typebox'\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any given type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with functions. TypeBox types extend the TSchema interface so you should constrain parameters to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(T: T) => \r\n  Type.Object({                                      // type Vector<T> = {\r\n    x: T,                                            //   x: T,\r\n    y: T,                                            //   y: T,\r\n    z: T                                             //   z: T\r\n  })                                                 // }\r\n\r\nconst NumberVector = Vector(Type.Number())           // type NumberVector = Vector<number>\r\n```\r\n\r\nGeneric types are often used to create aliases for complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Ref. These types infer the same as the target type but only store a named `$ref` to the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Deref to dereference a type. This function will replace any interior reference with the target type.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\nNote that Ref types do not store structural information about the type they're referencing. Because of this, these types cannot be used with some mapping types (such as Partial or Pick). For applications that require mapping on Ref, use Deref to normalize the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports recursive data structures with Recursive. This type wraps an interior type and provides it a `this` context that allows the type to reference itself. The following creates a recursive type. Singular recursive inference is also supported.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-template-literal'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax or composed from exterior types. TypeBox encodes template literals as regular expressions which enables the template to be checked by Json Schema validators. This type also supports regular expression parsing that enables template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports indexed access types with Index. This type enables uniform access to interior property and element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // type A = T['x']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // type B = T['x' | 'y']\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     //\r\n                                                     // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // type C = T[keyof T]\r\n                                                     //\r\n                                                     // ... evaluated as\r\n                                                     // \r\n                                                     // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-mapped'></a>\r\n\r\n### Mapped Types\r\n\r\nTypeBox supports mapped object types with Mapped. This type accepts two arguments, the first is a union type typically derived from KeyOf, the second is a mapping function that receives a mapping key `K` that can be used to index properties of a type. The following implements Partial using mapped types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst P = Type.Mapped(Type.KeyOf(T), K => {          // type P = { [K in keyof T]?: T[K] }\r\n  return Type.Optional(Type.Index(T, K))             //\r\n})                                                   // ... evaluated as\r\n                                                     // \r\n                                                     // const P: TObject<{\r\n                                                     //   x: TOptional<TNumber>,\r\n                                                     //   y: TOptional<TString>,\r\n                                                     //   z: TOptional<TBoolean>\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check against the first (`left`) and second (`right`) arguments and will return either the third (`true`) or fourth (`false`) argument based on the result. The conditional types Exclude and Extract are also supported. The following shows both TypeScript and TypeBox examples of conditional types.\r\n\r\n```typescript\r\n// Extends\r\nconst T = Type.Extends(                              // type T = string extends number ? true : false\r\n  Type.String(),                                     //   \r\n  Type.Number(),                                     // ... evaluated as\r\n  Type.Literal(true),                                //\r\n  Type.Literal(false)                                // const T: TLiteral<false>\r\n)\r\n\r\n// Extract\r\nconst T = Type.Extract(                              // type T = Extract<1 | 2 | 3, 1>\r\n  Type.Union([                                       //\r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TLiteral<1>\r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\nconst T = Type.Exclude(                              // type T = Exclude<1 | 2 | 3, 1>\r\n  Type.Union([                                       // \r\n    Type.Literal(1),                                 // ... evaluated as\r\n    Type.Literal(2),                                 //\r\n    Type.Literal(3)                                  // const T: TUnion<[\r\n  ]),                                                //   TLiteral<2>,\r\n  Type.Literal(1)                                    //   TLiteral<3>,\r\n)                                                    // ]>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript intrinsic string manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap Literal, Template Literal and Union of Literal types.\r\n\r\n```typescript\r\n// TypeScript\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\n\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\n\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler submodules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value submodule.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = { type: 'number' }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI.\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can check its own types with the TypeGuard module. This module is written for type introspection and provides structural tests for every built-in TypeBox type. Functions of this module return `is` guards which can be used with control flow assertions to obtain schema inference for unknown values. The following guards that the value `T` is TString.\r\n\r\n```typescript\r\nimport { TypeGuard, Kind } from '@sinclair/typebox'\r\n\r\nconst T = { [Kind]: 'String', type: 'string' }\r\n\r\nif(TypeGuard.IsString(T)) {\r\n\r\n  // T is TString\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Symbol(TypeBox.Kind)]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Symbol(TypeBox.Kind)]: 'String',\r\n                                                     //       [Symbol(TypeBox.Optional)]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional Value submodule that can be used to perform structural operations on JavaScript values. This submodule includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This submodule is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nUse Clean to remove excess properties from a value. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nUse Default to generate missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to upcast a value into a target type. This function will retain as much infomation as possible from the original value. The Cast function is intended to be used in data migration scenarios where existing values need to be upgraded to match a modified type.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to generate code that can be written to disk as importable modules. This technique is sometimes referred to as Ahead of Time (AOT) compilation. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides configurations to use either Json Schema or TypeScript type checking semantics. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox assert values inline with TypeScript static checks. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be helpful in Json based protocols such as Json Rpc 2.0. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-Rpc 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='error-function'></a>\r\n\r\n## Error Function\r\n\r\nError messages in TypeBox can be customized by defining an ErrorFunction. This function allows for the localization of error messages as well as enabling custom error messages for custom types. By default, TypeBox will generate messages using the `en-US` locale. To support additional locales, you can replicate the function found in `src/errors/function.ts` and create a locale specific translation. The function can then be set via SetErrorFunction.\r\n\r\nThe following example shows an inline error function that intercepts errors for String, Number and Boolean only. The DefaultErrorFunction is used to return a default error message.\r\n\r\n\r\n```typescript\r\nimport { SetErrorFunction, DefaultErrorFunction, ValueErrorType } from '@sinclair/typebox/errors'\r\n\r\nSetErrorFunction((error) => { // i18n override\r\n  switch(error.errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(error)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.String(),                                  //  TString,\r\n  y: Type.Number(),                                  //  TNumber,\r\n  z: Type.Boolean()                                  //  TBoolean\r\n})                                                   // }>\r\n\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be integrated into toolchains to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.10.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    242 ms' │ '     10 ms' │ '   24.20 x' │\r\n│ Literal_Number             │    1000    │ '    200 ms' │ '      8 ms' │ '   25.00 x' │\r\n│ Literal_Boolean            │    1000    │ '    168 ms' │ '      6 ms' │ '   28.00 x' │\r\n│ Primitive_Number           │    1000    │ '    165 ms' │ '      8 ms' │ '   20.63 x' │\r\n│ Primitive_String           │    1000    │ '    154 ms' │ '      6 ms' │ '   25.67 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    208 ms' │ '     14 ms' │ '   14.86 x' │\r\n│ Primitive_Boolean          │    1000    │ '    142 ms' │ '      6 ms' │ '   23.67 x' │\r\n│ Primitive_Null             │    1000    │ '    143 ms' │ '      6 ms' │ '   23.83 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1217 ms' │ '     31 ms' │ '   39.26 x' │\r\n│ Object_Constrained         │    1000    │ '   1275 ms' │ '     26 ms' │ '   49.04 x' │\r\n│ Object_Vector3             │    1000    │ '    405 ms' │ '     12 ms' │ '   33.75 x' │\r\n│ Object_Box3D               │    1000    │ '   1833 ms' │ '     27 ms' │ '   67.89 x' │\r\n│ Tuple_Primitive            │    1000    │ '    475 ms' │ '     13 ms' │ '   36.54 x' │\r\n│ Tuple_Object               │    1000    │ '   1267 ms' │ '     30 ms' │ '   42.23 x' │\r\n│ Composite_Intersect        │    1000    │ '    604 ms' │ '     18 ms' │ '   33.56 x' │\r\n│ Composite_Union            │    1000    │ '    545 ms' │ '     20 ms' │ '   27.25 x' │\r\n│ Math_Vector4               │    1000    │ '    829 ms' │ '     12 ms' │ '   69.08 x' │\r\n│ Math_Matrix4               │    1000    │ '    405 ms' │ '     10 ms' │ '   40.50 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    372 ms' │ '     12 ms' │ '   31.00 x' │\r\n│ Array_Primitive_String     │    1000    │ '    327 ms' │ '      5 ms' │ '   65.40 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    300 ms' │ '      4 ms' │ '   75.00 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1755 ms' │ '     21 ms' │ '   83.57 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1516 ms' │ '     20 ms' │ '   75.80 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    825 ms' │ '     14 ms' │ '   58.93 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1616 ms' │ '     16 ms' │ '  101.00 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    776 ms' │ '     16 ms' │ '   48.50 x' │\r\n│ Array_Composite_Union      │    1000    │ '    820 ms' │ '     14 ms' │ '   58.57 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1166 ms' │ '     15 ms' │ '   77.73 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    695 ms' │ '      8 ms' │ '   86.88 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types.\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     18 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     16 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Literal_Boolean            │  1000000   │ '     15 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Primitive_Number           │  1000000   │ '     21 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\r\n│ Primitive_String           │  1000000   │ '     22 ms' │ '     18 ms' │ '      9 ms' │ '    2.00 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    155 ms' │ '     41 ms' │ '     34 ms' │ '    1.21 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     19 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1003 ms' │ '     32 ms' │ '     24 ms' │ '    1.33 x' │\r\n│ Object_Constrained         │  1000000   │ '   1265 ms' │ '     49 ms' │ '     38 ms' │ '    1.29 x' │\r\n│ Object_Vector3             │  1000000   │ '    418 ms' │ '     22 ms' │ '     13 ms' │ '    1.69 x' │\r\n│ Object_Box3D               │  1000000   │ '   2035 ms' │ '     56 ms' │ '     49 ms' │ '    1.14 x' │\r\n│ Object_Recursive           │  1000000   │ '   5243 ms' │ '    326 ms' │ '    157 ms' │ '    2.08 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    153 ms' │ '     20 ms' │ '     12 ms' │ '    1.67 x' │\r\n│ Tuple_Object               │  1000000   │ '    781 ms' │ '     28 ms' │ '     18 ms' │ '    1.56 x' │\r\n│ Composite_Intersect        │  1000000   │ '    742 ms' │ '     25 ms' │ '     14 ms' │ '    1.79 x' │\r\n│ Composite_Union            │  1000000   │ '    558 ms' │ '     24 ms' │ '     13 ms' │ '    1.85 x' │\r\n│ Math_Vector4               │  1000000   │ '    246 ms' │ '     22 ms' │ '     11 ms' │ '    2.00 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1052 ms' │ '     43 ms' │ '     28 ms' │ '    1.54 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    272 ms' │ '     22 ms' │ '     12 ms' │ '    1.83 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    235 ms' │ '     24 ms' │ '     14 ms' │ '    1.71 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    134 ms' │ '     23 ms' │ '     14 ms' │ '    1.64 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   6280 ms' │ '     65 ms' │ '     59 ms' │ '    1.10 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   6076 ms' │ '    130 ms' │ '    119 ms' │ '    1.09 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  22738 ms' │ '   1730 ms' │ '    635 ms' │ '    2.72 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    689 ms' │ '     35 ms' │ '     30 ms' │ '    1.17 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3266 ms' │ '     63 ms' │ '     52 ms' │ '    1.21 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3310 ms' │ '     44 ms' │ '     36 ms' │ '    1.22 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2432 ms' │ '     69 ms' │ '     33 ms' │ '    2.09 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1158 ms' │ '     37 ms' │ '     24 ms' │ '    1.54 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   5435 ms' │ '    132 ms' │ '     92 ms' │ '    1.43 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '120.6 kb' │ ' 52.9 kb' │  '2.28 x'   │\r\n│ typebox/errors       │ ' 55.7 kb' │ ' 25.5 kb' │  '2.19 x'   │\r\n│ typebox/system       │ '  4.7 kb' │ '  2.0 kb' │  '2.33 x'   │\r\n│ typebox/value        │ '146.2 kb' │ ' 62.0 kb' │  '2.36 x'   │\r\n│ typebox              │ ' 91.4 kb' │ ' 37.8 kb' │  '2.42 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","module":"./build/import/index.mjs","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-elOextcszz0f4sjgTFocol5xzItnqc3EkOjXeEV4VEKKKOL3X+KCebj6Hopf/Qx1Sv1RUWrJuAjbD4JlUiYOAA==","_from":"file:sinclair-typebox-0.32.0-dev-28.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-28_1702528738529_0.8387211120071285"},"_hasShrinkwrap":false},"0.32.0-dev-3":{"_id":"@sinclair/typebox@0.32.0-dev-3","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-3","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build:esm":"hammer task build_esm","build:cjs":"hammer task build_cjs","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./cjs/index.js","dist":{"shasum":"2bd2037dfef924b70986912e6bceeaa559447f4b","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-3.tgz"},"module":"./esm/index.mjs","types":"./esm/index.d.mts","_integrity":"sha512-uKa3O8gB7Z+mlrB2nH696SUKDWpVFmDSR7DlWjoyvmXMIUkDtewOmgBDdNSddpOYCHLBbiSCbUG4Kff63LKgPw==","_from":"file:sinclair-typebox-0.32.0-dev-3.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-3_1701353789270_0.27843614283743223"},"_hasShrinkwrap":false},"0.32.0-dev-4":{"_id":"@sinclair/typebox@0.32.0-dev-4","name":"@sinclair/typebox","description":"JSONSchema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-4","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","scripts":{"benchmark:compression":"hammer task benchmark_compression","benchmark:measurement":"hammer task benchmark_measurement","benchmark":"hammer task benchmark","install:local":"hammer task install_local","test:typescript":"hammer task test_typescript","test:static":"hammer task test_static","test:runtime":"hammer task test_runtime","build":"hammer task build","test":"hammer task test","clean":"hammer task clean","format":"hammer task format","start":"hammer task start","publish":"hammer task publish","publish:dev":"hammer task publish_dev"},"directories":{},"devDependencies":{"@sinclair/hammer":"^0.18.0","@types/mocha":"^9.1.1","@types/node":"^20.10.1","ajv":"^8.12.0","ajv-formats":"^2.1.1","mocha":"^9.2.2","prettier":"^2.7.1","typescript":"^5.3.2"},"main":"./index.js","dist":{"shasum":"edee7485f157bf11575d9a78173a69af4df803cf","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-4.tgz"},"types":"./index.d.ts","_integrity":"sha512-3jHO6XqEwcAlaZGuH9aMmVRP39SmwVVGCimOp33IHqtJ1KXCF6tA9t8s1pTVlJ5+GSq1H9I0PHqZ1Rqo/WlJtA==","_from":"file:sinclair-typebox-0.32.0-dev-4.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-4_1701482715809_0.18275578254789315"},"_hasShrinkwrap":false},"0.32.0-dev-5":{"_id":"@sinclair/typebox@0.32.0-dev-5","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","directories":{},"main":"./build/default/index.js","dist":{"shasum":"30233fcc92cd02224dd13d39773f35aa7fbe543e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-5.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Rest](#types-rest)\r\n  - [Transform](#types-transform)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Errors](#typesystem-errors)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This type will recursively reconstruct interior referenced types.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check for the first two arguments and will infer one of the second two arguments based on the result. The Extends type is designed to match the assignability rules of TypeScript conditional types. The conditional derived types Exclude and Extract are also supported.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax. TypeBox encodes template literals as regular expression string patterns which enable the template be checked via Json Schema. It also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access Types with Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, TemplateLiteral and Union types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the built-in Json and JavaScript type sets. They also manage TypeBox's localization options (i18n) for error message generation and can control various assertion policies used when type checking. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the TypeSystemErrorFunction to override validation error messages. This can be used to localize errors or create error messages for user defined types.\r\n\r\n```typescript\r\nimport { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'\r\n\r\nTypeSystemErrorFunction.Set((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T = { ... }\r\n  x: Type.String(),\r\n  y: Type.Number(),\r\n  z: Type.Boolean()\r\n})\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    216 ms' │ '      9 ms' │ '   24.00 x' │\r\n│ Literal_Number             │    1000    │ '    169 ms' │ '      7 ms' │ '   24.14 x' │\r\n│ Literal_Boolean            │    1000    │ '    150 ms' │ '      5 ms' │ '   30.00 x' │\r\n│ Primitive_Number           │    1000    │ '    161 ms' │ '      7 ms' │ '   23.00 x' │\r\n│ Primitive_String           │    1000    │ '    148 ms' │ '      6 ms' │ '   24.67 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    185 ms' │ '      9 ms' │ '   20.56 x' │\r\n│ Primitive_Boolean          │    1000    │ '    132 ms' │ '      4 ms' │ '   33.00 x' │\r\n│ Primitive_Null             │    1000    │ '    141 ms' │ '      3 ms' │ '   47.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1109 ms' │ '     30 ms' │ '   36.97 x' │\r\n│ Object_Constrained         │    1000    │ '   1200 ms' │ '     24 ms' │ '   50.00 x' │\r\n│ Object_Vector3             │    1000    │ '    379 ms' │ '      9 ms' │ '   42.11 x' │\r\n│ Object_Box3D               │    1000    │ '   1709 ms' │ '     30 ms' │ '   56.97 x' │\r\n│ Tuple_Primitive            │    1000    │ '    456 ms' │ '     14 ms' │ '   32.57 x' │\r\n│ Tuple_Object               │    1000    │ '   1229 ms' │ '     17 ms' │ '   72.29 x' │\r\n│ Composite_Intersect        │    1000    │ '    570 ms' │ '     17 ms' │ '   33.53 x' │\r\n│ Composite_Union            │    1000    │ '    513 ms' │ '     19 ms' │ '   27.00 x' │\r\n│ Math_Vector4               │    1000    │ '    782 ms' │ '     13 ms' │ '   60.15 x' │\r\n│ Math_Matrix4               │    1000    │ '    393 ms' │ '     12 ms' │ '   32.75 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    361 ms' │ '     12 ms' │ '   30.08 x' │\r\n│ Array_Primitive_String     │    1000    │ '    296 ms' │ '      5 ms' │ '   59.20 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    315 ms' │ '      4 ms' │ '   78.75 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1721 ms' │ '     22 ms' │ '   78.23 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1450 ms' │ '     21 ms' │ '   69.05 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    813 ms' │ '     13 ms' │ '   62.54 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1537 ms' │ '     17 ms' │ '   90.41 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    753 ms' │ '     17 ms' │ '   44.29 x' │\r\n│ Array_Composite_Union      │    1000    │ '    808 ms' │ '     16 ms' │ '   50.50 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1118 ms' │ '     16 ms' │ '   69.88 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    690 ms' │ '      9 ms' │ '   76.67 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     24 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     20 ms' │ '     10 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     25 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     21 ms' │ '     24 ms' │ '      9 ms' │ '    2.67 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    156 ms' │ '     43 ms' │ '     38 ms' │ '    1.13 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     20 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1055 ms' │ '     32 ms' │ '     24 ms' │ '    1.33 x' │\r\n│ Object_Constrained         │  1000000   │ '   1232 ms' │ '     49 ms' │ '     43 ms' │ '    1.14 x' │\r\n│ Object_Vector3             │  1000000   │ '    432 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Object_Box3D               │  1000000   │ '   1993 ms' │ '     54 ms' │ '     46 ms' │ '    1.17 x' │\r\n│ Object_Recursive           │  1000000   │ '   5115 ms' │ '    342 ms' │ '    159 ms' │ '    2.15 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    156 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    740 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    797 ms' │ '     26 ms' │ '     14 ms' │ '    1.86 x' │\r\n│ Composite_Union            │  1000000   │ '    530 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    240 ms' │ '     22 ms' │ '     11 ms' │ '    2.00 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1036 ms' │ '     39 ms' │ '     27 ms' │ '    1.44 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    248 ms' │ '     20 ms' │ '     12 ms' │ '    1.67 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    227 ms' │ '     22 ms' │ '     13 ms' │ '    1.69 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    138 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5540 ms' │ '     66 ms' │ '     59 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5750 ms' │ '    123 ms' │ '    108 ms' │ '    1.14 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21842 ms' │ '   1771 ms' │ '    599 ms' │ '    2.96 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    715 ms' │ '     36 ms' │ '     29 ms' │ '    1.24 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3131 ms' │ '     63 ms' │ '     50 ms' │ '    1.26 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3064 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2172 ms' │ '     65 ms' │ '     31 ms' │ '    2.10 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1032 ms' │ '     37 ms' │ '     24 ms' │ '    1.54 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4859 ms' │ '    114 ms' │ '     86 ms' │ '    1.33 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '109.3 kb' │ ' 48.5 kb' │  '2.25 x'   │\r\n│ typebox/errors       │ ' 54.8 kb' │ ' 24.9 kb' │  '2.20 x'   │\r\n│ typebox/system       │ ' 12.1 kb' │ '  6.1 kb' │  '1.98 x'   │\r\n│ typebox/type         │ ' 77.8 kb' │ ' 32.8 kb' │  '2.37 x'   │\r\n│ typebox/value        │ '143.7 kb' │ ' 61.2 kb' │  '2.35 x'   │\r\n│ typebox              │ ' 77.9 kb' │ ' 32.8 kb' │  '2.37 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./build/types/index.d.ts","module":"./build/import/index.mjs","readmeFilename":"readme.md","_integrity":"sha512-hxxK7BIb3oSQucvFR5hhAK9PnYiCzPfneQUZu2lnfFAUhVhGlzHyHMdViprGptDWD4qMmrhKcQeGvNByF+Oodg==","_from":"file:sinclair-typebox-0.32.0-dev-5.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-5_1701489295395_0.9903728896571504"},"_hasShrinkwrap":false},"0.32.0-dev-6":{"_id":"@sinclair/typebox@0.32.0-dev-6","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-6","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/default/index.js","dist":{"shasum":"ddbffc796d9f653887705bfaacbd3fc469e21564","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-6.tgz"},"types":"./build/types/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-r/+LRfImMeYuBTgSjFvkyMPKTZj/xOtXitVGMr3WaKVyrRQlvcYIhZcLi31lrpMKP1jbKgsKUulRrRPIpy6FQA==","_from":"file:sinclair-typebox-0.32.0-dev-6.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-6_1701490428077_0.617708370803159"},"_hasShrinkwrap":false},"0.32.0-dev-7":{"_id":"@sinclair/typebox@0.32.0-dev-7","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-7","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"9be1c821f0ddcfbddf150db8c37c66cc09dfa93f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-7.tgz"},"readme":"<div align='center'>\r\n\r\n<h1>TypeBox</h1>\r\n\r\n<p>Json Schema Type Builder with Static Type Resolution for TypeScript</p>\r\n\r\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\r\n\r\n<br />\r\n<br />\r\n\r\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\r\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\r\n[![Build](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml/badge.svg)](https://github.com/sinclairzx81/typebox/actions/workflows/build.yml)\r\n[![License](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\r\n\r\n</div>\r\n\r\n<a name=\"Install\"></a>\r\n\r\n## Install\r\n\r\n#### Npm\r\n```bash\r\n$ npm install @sinclair/typebox --save\r\n```\r\n\r\n## Example\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n  z: Type.Number()                                   //   properties: {\r\n})                                                   //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\n\r\n<a name=\"Overview\"></a>\r\n\r\n## Overview\r\n\r\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\r\n\r\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire.\r\n\r\nLicense MIT\r\n\r\n## Contents\r\n- [Install](#install)\r\n- [Overview](#overview)\r\n- [Usage](#usage)\r\n- [Types](#types)\r\n  - [Json](#types-json)\r\n  - [JavaScript](#types-javascript)\r\n  - [Options](#types-options)\r\n  - [Properties](#types-properties)\r\n  - [Generics](#types-generics)\r\n  - [References](#types-references)\r\n  - [Recursive](#types-recursive)\r\n  - [Conditional](#types-conditional)\r\n  - [Template Literal](#types-templateliteral)\r\n  - [Indexed](#types-indexed)\r\n  - [Rest](#types-rest)\r\n  - [Transform](#types-transform)\r\n  - [Intrinsic](#types-intrinsic)\r\n  - [Guard](#types-guard)\r\n  - [Unsafe](#types-unsafe)\r\n  - [Strict](#types-strict)\r\n- [Values](#values)\r\n  - [Create](#values-create)\r\n  - [Clone](#values-clone)\r\n  - [Check](#values-check)\r\n  - [Convert](#values-convert)\r\n  - [Default](#values-default)\r\n  - [Clean](#values-clean)\r\n  - [Cast](#values-cast)\r\n  - [Decode](#values-decode)\r\n  - [Encode](#values-decode)\r\n  - [Equal](#values-equal)\r\n  - [Hash](#values-hash)\r\n  - [Diff](#values-diff)\r\n  - [Patch](#values-patch)\r\n  - [Errors](#values-errors)\r\n  - [Mutate](#values-mutate)\r\n  - [Pointer](#values-pointer)\r\n- [TypeRegistry](#typeregistry)\r\n  - [Type](#typeregistry-type)\r\n  - [Format](#typeregistry-format)\r\n- [TypeCheck](#typecheck)\r\n  - [Ajv](#typecheck-ajv)\r\n  - [TypeCompiler](#typecheck-typecompiler)\r\n- [TypeSystem](#typesystem)\r\n  - [Errors](#typesystem-errors)\r\n  - [Policies](#typesystem-policies)\r\n- [Workbench](#workbench)\r\n- [Codegen](#codegen)\r\n- [Ecosystem](#ecosystem)\r\n- [Benchmark](#benchmark)\r\n  - [Compile](#benchmark-compile)\r\n  - [Validate](#benchmark-validate)\r\n  - [Compression](#benchmark-compression)\r\n- [Contribute](#contribute)\r\n\r\n<a name=\"usage\"></a>\r\n\r\n## Usage\r\n\r\nThe following shows general usage.\r\n\r\n```typescript\r\nimport { Type, type Static } from '@sinclair/typebox'\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// Let's say you have the following type ...\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = {\r\n  id: string,\r\n  name: string,\r\n  timestamp: number\r\n}\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... you can express this type in the following way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nconst T = Type.Object({                              // const T = {\r\n  id: Type.String(),                                 //   type: 'object',\r\n  name: Type.String(),                               //   properties: {\r\n  timestamp: Type.Integer()                          //     id: {\r\n})                                                   //       type: 'string'\r\n                                                     //     },\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     timestamp: {\r\n                                                     //       type: 'integer'\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'name',\r\n                                                     //     'timestamp'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then infer back to the original static type this way.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\ntype T = Static<typeof T>                            // type T = {\r\n                                                     //   id: string,\r\n                                                     //   name: string,\r\n                                                     //   timestamp: number\r\n                                                     // }\r\n\r\n//--------------------------------------------------------------------------------------------\r\n//\r\n// ... then use the type both as Json Schema and as a TypeScript type.\r\n//\r\n//--------------------------------------------------------------------------------------------\r\n\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nfunction receive(value: T) {                         // ... as a Static Type\r\n\r\n  if(Value.Check(T, value)) {                        // ... as a Json Schema\r\n\r\n    // ok...\r\n  }\r\n}\r\n```\r\n\r\n<a name='types'></a>\r\n\r\n## Types\r\n\r\nTypeBox types are Json Schema fragments that compose into more complex types. Each fragment is structured such that any Json Schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox offers a set of Json Types which are used to create Json Schema compliant schematics as well as a JavaScript type set used to create schematics for constructs native to JavaScript.\r\n\r\n<a name='types-json'></a>\r\n\r\n### Json Types\r\n\r\nThe following table lists the supported Json types. These types are fully compatible with the Json Schema Draft 7 specification.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\r\n│                                │                             │   type: 'integer'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\r\n│                                │                             │   type: 'boolean'              │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\r\n│                                │                             │   type: 'null'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\r\n│                                │                             │   const: 42,                   │\r\n│                                │                             │   type: 'number'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\r\n│   Type.Number()                │                             │   type: 'array',               │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\r\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\r\n│ })                             │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\r\n│   Type.Number(),               │                             │   type: 'array',               │\r\n│   Type.Number()                │                             │   items: [{                    │\r\n│ ])                             │                             │     type: 'number'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   additionalItems: false,      │\r\n│                                │                             │   minItems: 2,                 │\r\n│                                │                             │   maxItems: 2                  │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\r\n│   A,                           │   A,                        │   anyOf: [{                    │\r\n│   B                            │   B                         │     type: 'number',            │\r\n│ }                              │ }                           │     const: 0                   │\r\n│                                │                             │   }, {                         │\r\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\r\n│                                │                             │     const: 1                   │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Const({         │ type T = {                  │ const T = {                    │\r\n│   x: 1,                        │   readonly x: 1,            │   type: 'object',              │\r\n│   y: 2,                        │   readonly y: 2             │   required: ['x', 'y'],        │\r\n│ } as const)                    │ }                           │   properties: {                │\r\n│                                │                             │     x: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 1                 │\r\n│                                │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number',          │\r\n│                                │                             │       const: 2                 │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\r\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\r\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\r\n│   })                           │                             │   }, {                         │\r\n│ )                              │                             │     type: 'string',            │\r\n│                                │                             │     const: 'y'                 │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\r\n│   Type.String(),               │                             │   anyOf: [{                    │\r\n│   Type.Number()                │                             │     type: 'string'             │\r\n│ ])                             │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\r\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\r\n│   }),                          │   y: number                 │     required: ['x'],           │\r\n│   Type.Object({                │ }                           │     properties: {              │\r\n│     y: Type.Number()           │                             │       x: {                     │\r\n│   ])                           │                             │         type: 'number'         │\r\n│ ])                             │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'object',            |\r\n│                                │                             │     required: ['y'],           │\r\n│                                │                             │     properties: {              │\r\n│                                │                             │       y: {                     │\r\n│                                │                             │         type: 'number'         │\r\n│                                │                             │       }                        │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }]                           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Composite([     │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number()           │   y: number                 │   required: ['x', 'y'],        │\r\n│   }),                          │ }                           │   properties: {                │\r\n│   Type.Object({                │                             │     x: {                       │\r\n│     y: Type.Number()           │                             │       type: 'number'           │\r\n│   })                           │                             │     },                         │\r\n│ ])                             │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\r\n│                                │                             │   not: {}                      │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Not(            | type T = unknown            │ const T = {                    │\r\n│   Type.String()                │                             │   not: {                       │\r\n│ )                              │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\r\n│   Type.String(),               │  string extends number      │   const: false,                │\r\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\r\n│   Type.Literal(true),          │                             │ }                              │\r\n│   Type.Literal(false)          │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\r\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\r\n│     Type.String(),             │   string                    │ }                              │\r\n│     Type.Number(),             │ >                           │                                │\r\n│   ]),                          │                             │                                │\r\n│   Type.String()                │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\r\n│   Type.Literal('open'),        │                             │   type: 'string',              │\r\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n│ const T = Type                 │                             │                                │\r\n│   .TemplateLiteral([           │                             │                                │\r\n│      Type.Literal('on'),       │                             │                                │\r\n│      U                         │                             │                                │\r\n│   ])                           │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\r\n│   Type.String(),               │   string,                   │   type: 'object',              │\r\n│   Type.Number()                │   number                    │   patternProperties: {         │\r\n│ )                              │ >                           │     '^.*$': {                  │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\r\n│     y: Type.Number()           | }>                          │     x: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     },                         │\r\n│                                │                             │     y: {                       │\r\n│                                │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\r\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\r\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\r\n│       Type.Number()            | }>                          │   properties: {                │\r\n│     ),                         │                             │     x: {                       │\r\n│     y: Type.Optional(          │                             │       type: 'number'           │\r\n│       Type.Number()            │                             │     },                         │\r\n│     )                          │                             │     y: {                       │\r\n│   })                           │                             │       type: 'number'           │\r\n│ )                              │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     x: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'object',              │\r\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\r\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\r\n│   }), ['x']                    |                             │     y: {                       │\r\n│ )                              │                             │       type: 'number'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Index(          │ type T = {                  │ const T = {                    │\r\n│   Type.Object({                │   x: number,                │   type: 'number'               │\r\n│     x: Type.Number(),          │   y: string                 │ }                              │\r\n│     y: Type.String()           │ }['x']                      │                                │\r\n│   }), ['x']                    │                             │                                │\r\n│ )                              │                             │                                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const A = Type.Tuple([         │ type A = [0, 1]             │ const T = {                    │\r\n│   Type.Literal(0),             │ type B = [2, 3]             │   type: 'array',               │\r\n│   Type.Literal(1)              │ type T = [                  │   items: [                     │\r\n│ ])                             │   ...A,                     │     { const: 0 },              │\r\n│ const B = Type.Tuple([         │   ...B                      │     { const: 1 },              │\r\n|   Type.Literal(2),             │ ]                           │     { const: 2 },              │\r\n|   Type.Literal(3)              │                             │     { const: 3 }               │\r\n│ ])                             │                             │   ],                           │\r\n│ const T = Type.Tuple([         │                             │   additionalItems: false,      │\r\n|   ...Type.Rest(A),             │                             │   minItems: 4,                 │\r\n|   ...Type.Rest(B)              │                             │   maxItems: 4                  │\r\n│ ])                             │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uncapitalize(   │ type T = Uncapitalize<      │ const T = {                    │\r\n│   Type.Literal('Hello')        │   'Hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Capitalize(     │ type T = Capitalize<        │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'Hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uppercase(      │ type T = Uppercase<         │ const T = {                    │\r\n│   Type.Literal('hello')        │   'hello'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'HELLO'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Lowercase(      │ type T = Lowercase<         │ const T = {                    │\r\n│   Type.Literal('HELLO')        │   'HELLO'                   │   type: 'string',              │\r\n│ )                              │ >                           │   const: 'hello'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\r\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\r\n│    y: Type.Number()            │   y: number                 │ }                              │\r\n│ }, { $id: 'T' })               | }                           │                                │\r\n│                                │                             │                                │\r\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-javascript'></a>\r\n\r\n### JavaScript Types\r\n\r\nTypeBox provides an extended type set that can be used to create schematics for common JavaScript constructs. These types can not be used with any standard Json Schema validator; but can be used to frame schematics for interfaces that may receive Json validated data. JavaScript types are prefixed with the `[JavaScript]` jsdoc comment for convenience. The following table lists the supported types.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\r\n│   Type.String(),               │  arg0: string,              │   type: 'Constructor',         │\r\n│   Type.Number()                │  arg0: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\r\n|   Type.String(),               │  arg0: string,              │   type: 'Function',            │\r\n│   Type.Number()                │  arg1: number               │   parameters: [{               │\r\n│ ], Type.Boolean())             │ ) => boolean                │     type: 'string'             │\r\n│                                │                             │   }, {                         │\r\n│                                │                             │     type: 'number'             │\r\n│                                │                             │   }],                          │\r\n│                                │                             │   returns: {                   │\r\n│                                │                             │     type: 'boolean'            │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\r\n│   Type.String()                │                             │   type: 'Promise',             │\r\n│ )                              │                             │   item: {                      │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T =                      │ type T =                    │ const T = {                    │\r\n│   Type.AsyncIterator(          │   AsyncIterableIterator<    │   type: 'AsyncIterator',       │\r\n│     Type.String()              │    string                   │   items: {                     │\r\n│   )                            │   >                         │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Iterator(       │ type T =                    │ const T = {                    │\r\n│   Type.String()                │   IterableIterator<string>  │   type: 'Iterator',            │\r\n│ )                              │                             │   items: {                     │\r\n│                                │                             │     type: 'string'             │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.RegExp(/abc/)   │ type T = string             │ const T = {                    │\r\n│                                │                             │   type: 'string'               │\r\n│                                │                             │   pattern: 'abc'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\r\n│                                │                             │   type: 'Uint8Array'           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\r\n│                                │                             │   type: 'Date'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\r\n│                                │                             │   type: 'undefined'            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\r\n│                                │                             │   type: 'symbol'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\r\n│                                │                             │   type: 'bigint'               │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\r\n│                                │                             │   type: 'void'                 │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n\r\n<a name='types-options'></a>\r\n\r\n### Options\r\n\r\nYou can pass Json Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\r\n\r\n```typescript\r\n// String must be an email\r\nconst T = Type.String({                              // const T = {\r\n  format: 'email'                                    //   type: 'string',\r\n})                                                   //   format: 'email'\r\n                                                     // }\r\n\r\n// Number must be a multiple of 2\r\nconst T = Type.Number({                              // const T = {\r\n  multipleOf: 2                                      //  type: 'number',\r\n})                                                   //  multipleOf: 2\r\n                                                     // }\r\n\r\n// Array must have at least 5 integer values\r\nconst T = Type.Array(Type.Integer(), {               // const T = {\r\n  minItems: 5                                        //   type: 'array',\r\n})                                                   //   minItems: 5,\r\n                                                     //   items: {\r\n                                                     //     type: 'integer'\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='types-properties'></a>\r\n\r\n### Properties\r\n\r\nObject properties can be modified with Readonly and Optional. The following table shows how these modifiers map between TypeScript and Json Schema.\r\n\r\n```typescript\r\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\r\n│ TypeBox                        │ TypeScript                  │ Json Schema                    │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   },                           │\r\n│                                │                             │   required: ['name']           │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\r\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\r\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\r\n│     Type.String()              │ }                           │   properties: {                │\r\n│   )                            │                             │     name: {                    │\r\n│ })  \t                         │                             │       type: 'string'           │\r\n│                                │                             │     }                          │\r\n│                                │                             │   }                            │\r\n│                                │                             │ }                              │\r\n│                                │                             │                                │\r\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\r\n```\r\n<a name='types-generics'></a>\r\n\r\n### Generic Types\r\n\r\nGeneric types can be created with generic functions. All types extend the base type TSchema. It is common to constrain generic function arguments to this type. The following creates a generic Vector type.\r\n\r\n```typescript\r\nimport { Type, type Static, type TSchema } from '@sinclair/typebox'\r\n\r\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\r\n\r\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['x', 'y', 'z'],\r\n                                                     //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' },\r\n                                                     //     z: { type: 'number' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\r\n                                                     //   x: number,\r\n                                                     //   y: number,\r\n                                                     //   z: number\r\n                                                     // }\r\n```\r\n\r\nGeneric types are often used to create aliases for more complex types. The following creates a Nullable generic type.\r\n\r\n```typescript\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   anyOf: [\r\n                                                     //     { type: 'string' },\r\n                                                     //     { type: 'null' }\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n```\r\n\r\n<a name='types-references'></a>\r\n\r\n### Reference Types\r\n\r\nReference types can be created with Type.Ref. These types infer the same as the target type.\r\n\r\n```typescript\r\nconst Vector = Type.Object({                         // const Vector = {\r\n  x: Type.Number(),                                  //   type: 'object',\r\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\r\n}, { $id: 'Vector' })                                //   properties: {\r\n                                                     //     x: { type: 'number' },\r\n                                                     //     y: { type: 'number' }\r\n                                                     //   },\r\n                                                     //   $id: 'Vector'\r\n                                                     // }\r\n\r\nconst VectorRef = Type.Ref(Vector)                   // const VectorRef = {\r\n                                                     //   $ref: 'Vector'\r\n                                                     // }\r\n\r\ntype VectorRef = Static<typeof VectorRef>            // type VectorRef = {\r\n                                                     //    x: number,\r\n                                                     //    y: number\r\n                                                     // }\r\n```\r\nUse Type.Deref to dereference a type. This type will recursively reconstruct interior referenced types.\r\n```typescript\r\nconst Vertex = Type.Object({                         // const Vertex = {\r\n  position: VectorRef,                               //   type: 'object',\r\n  texcoord: VectorRef,                               //   required: ['position', 'texcoord'],\r\n})                                                   //   properties: {\r\n                                                     //     position: { $ref: 'Vector' },\r\n                                                     //     texcoord: { $ref: 'Vector' }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst VertexDeref = Type.Deref(Vertex, [Vector])     // const VertexDeref = {\r\n                                                     //   type: 'object',\r\n                                                     //   required: ['position', 'texcoord'],\r\n                                                     //   properties: {\r\n                                                     //     position: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     },\r\n                                                     //     texcoord: {\r\n                                                     //       type: 'object',\r\n                                                     //       required: ['x', 'y', 'z'],\r\n                                                     //       properties: {\r\n                                                     //         x: { type: 'number' },\r\n                                                     //         y: { type: 'number' }\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\n\r\n```\r\nNote that reference types do not contain structural information about the type they're referencing. This means they cannot be used directly with some type mapping types (such as Partial) that require structural information to operate. For applications that need mapping on references, use Type.Deref to dereference the type first.\r\n\r\n<a name='types-recursive'></a>\r\n\r\n### Recursive Types\r\n\r\nTypeBox supports singular recursive data structures. Recursive type inference is also supported. The following creates a recursive Node data structure.\r\n\r\n```typescript\r\nconst Node = Type.Recursive(This => Type.Object({    // const Node = {\r\n  id: Type.String(),                                 //   $id: 'Node',\r\n  nodes: Type.Array(This)                            //   type: 'object',\r\n}), { $id: 'Node' })                                 //   properties: {\r\n                                                     //     id: {\r\n                                                     //       type: 'string'\r\n                                                     //     },\r\n                                                     //     nodes: {\r\n                                                     //       type: 'array',\r\n                                                     //       items: {\r\n                                                     //         $ref: 'Node'\r\n                                                     //       }\r\n                                                     //     }\r\n                                                     //   },\r\n                                                     //   required: [\r\n                                                     //     'id',\r\n                                                     //     'nodes'\r\n                                                     //   ]\r\n                                                     // }\r\n\r\ntype Node = Static<typeof Node>                      // type Node = {\r\n                                                     //   id: string\r\n                                                     //   nodes: Node[]\r\n                                                     // }\r\n\r\nfunction test(node: Node) {\r\n  const id = node.nodes[0].nodes[0].id               // id is string\r\n}\r\n```\r\n\r\n<a name='types-conditional'></a>\r\n\r\n### Conditional Types\r\n\r\nTypeBox supports runtime conditional types with Extends. This type performs a structural assignability check for the first two arguments and will infer one of the second two arguments based on the result. The Extends type is designed to match the assignability rules of TypeScript conditional types. The conditional derived types Exclude and Extract are also supported.\r\n\r\n```typescript\r\n// Extends\r\n\r\ntype T = string extends number ? true : false        // type T = false\r\n\r\nconst T = Type.Extends(                              // const T: TLiteral<false>\r\n  Type.String(), \r\n  Type.Number(), \r\n  Type.Literal(true), \r\n  Type.Literal(false)\r\n)\r\n\r\n// Extract\r\n\r\ntype T = Extract<1 | 2 | 3, 1>                       // type T = 1\r\n\r\nconst T = Type.Extract(                              // const T: TLiteral<1> \r\n  Type.Union([\r\n    Type.Literal(1),\r\n    Type.Literal(2), \r\n    Type.Literal(3) \r\n  ]), \r\n  Type.Literal(1)\r\n)\r\n\r\n// Exclude\r\n\r\ntype T = Exclude<1 | 2 | 3, 1>                       // type T = 2 | 3\r\n\r\nconst T = Type.Exclude(                              // const T: TUnion<[\r\n  Type.Union([                                       //   TLiteral<2>,\r\n    Type.Literal(1),                                 //   TLiteral<3>\r\n    Type.Literal(2),                                 // ]>\r\n    Type.Literal(3)\r\n  ]),\r\n  Type.Literal(1)\r\n)\r\n```\r\n\r\n<a name='types-templateliteral'></a>\r\n\r\n### Template Literal Types\r\n\r\nTypeBox supports template literal types with TemplateLiteral. This type can be created using a syntax similar to the TypeScript template literal syntax. TypeBox encodes template literals as regular expression string patterns which enable the template be checked via Json Schema. It also supports regular expression parsing, enabling template patterns to be used for generative types. The following shows both TypeScript and TypeBox usage.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype K = `prop${'A'|'B'|'C'}`                        // type T = 'propA' | 'propB' | 'propC'\r\n\r\ntype R = Record<K, string>                           // type R = {\r\n                                                     //   propA: string\r\n                                                     //   propB: string\r\n                                                     //   propC: string\r\n                                                     // }\r\n\r\n// TypeBox\r\n\r\nconst K = Type.TemplateLiteral('prop${A|B|C}')       // const K: TTemplateLiteral<[\r\n                                                     //   TLiteral<'prop'>,\r\n                                                     //   TUnion<[\r\n                                                     //      TLiteral<'A'>,\r\n                                                     //      TLiteral<'B'>,\r\n                                                     //      TLiteral<'C'>,\r\n                                                     //   ]>\r\n                                                     // ]>\r\n\r\nconst R = Type.Record(K, Type.String())              // const R: TObject<{\r\n                                                     //   hello1: TString,\r\n                                                     //   hello2: TString,\r\n                                                     //   hello3: TString,\r\n                                                     // }>\r\n```\r\n\r\n<a name='types-indexed'></a>\r\n\r\n### Indexed Access Types\r\n\r\nTypeBox supports Indexed Access Types with Index. This type enables uniform access to interior property and array element types without having to extract them from the underlying schema representation. This type is supported for Object, Array, Tuple, Union and Intersect types.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T: TObject<{\r\n  x: Type.Number(),                                  //   x: TNumber,\r\n  y: Type.String(),                                  //   y: TString,\r\n  z: Type.Boolean()                                  //   z: TBoolean\r\n})                                                   // }>\r\n\r\nconst A = Type.Index(T, ['x'])                       // const A: TNumber\r\n\r\nconst B = Type.Index(T, ['x', 'y'])                  // const B: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     // ]>\r\n\r\nconst C = Type.Index(T, Type.KeyOf(T))               // const C: TUnion<[\r\n                                                     //   TNumber,\r\n                                                     //   TString,\r\n                                                     //   TBoolean\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-rest'></a>\r\n\r\n### Rest Types\r\n\r\nTypeBox provides the Rest type to uniformly extract variadic tuples from Intersect, Union and Tuple types. This type can be useful to remap variadic types into different forms. The following uses Rest to remap a Tuple into a Union.\r\n\r\n```typescript\r\nconst T = Type.Tuple([                               // const T: TTuple<[\r\n  Type.String(),                                     //   TString,\r\n  Type.Number()                                      //   TNumber\r\n])                                                   // ]>\r\n\r\nconst R = Type.Rest(T)                               // const R: [TString, TNumber]\r\n\r\nconst U = Type.Union(R)                              // const T: TUnion<[\r\n                                                     //   TString,\r\n                                                     //   TNumber\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-transform'></a>\r\n\r\n### Transform Types\r\n\r\nTypeBox supports value decoding and encoding with Transform types. These types work in tandem with the Encode and Decode functions available on the Value and TypeCompiler modules. Transform types can be used to convert Json encoded values into constructs more natural to JavaScript. The following creates a Transform type to decode numbers into Dates using the Value module.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n\r\nconst T = Type.Transform(Type.Number())\r\n  .Decode(value => new Date(value))                  // required: number to Date\r\n  .Encode(value => value.getTime())                  // required: Date to number\r\n\r\nconst decoded = Value.Decode(T, 0)                   // const decoded = Date(1970-01-01T00:00:00.000Z)\r\nconst encoded = Value.Encode(T, decoded)             // const encoded = 0\r\n```\r\nUse the StaticEncode or StaticDecode types to infer a Transform type.\r\n```typescript\r\nimport { Static, StaticDecode, StaticEncode } from '@sinclair/typebox'\r\n\r\nconst T = Type.Transform(Type.Array(Type.Number(), { uniqueItems: true }))         \r\n  .Decode(value => new Set(value))\r\n  .Encode(value => [...value])\r\n\r\ntype D = StaticDecode<typeof T>                      // type D = Set<number>      \r\ntype E = StaticEncode<typeof T>                      // type E = Array<number>\r\ntype T = Static<typeof T>                            // type T = Array<number>\r\n```\r\n\r\n<a name='types-intrinsic'></a>\r\n\r\n### Intrinsic Types\r\n\r\nTypeBox supports the TypeScript Intrinsic String Manipulation types Uppercase, Lowercase, Capitalize and Uncapitalize. These types can be used to remap String Literal, TemplateLiteral and Union types.\r\n\r\n```typescript\r\n// TypeScript\r\n\r\ntype A = Capitalize<'hello'>                         // type A = 'Hello'\r\ntype B = Capitalize<'hello' | 'world'>               // type C = 'Hello' | 'World'\r\ntype C = Capitalize<`hello${1|2|3}`>                 // type B = 'Hello1' | 'Hello2' | 'Hello3'\r\n\r\n// TypeBox\r\n\r\nconst A = Type.Capitalize(Type.Literal('hello'))     // const A: TLiteral<'Hello'>\r\n\r\nconst B = Type.Capitalize(Type.Union([               // const B: TUnion<[\r\n  Type.Literal('hello'),                             //   TLiteral<'Hello'>,\r\n  Type.Literal('world')                              //   TLiteral<'World'>\r\n]))                                                  // ]>\r\n\r\nconst C = Type.Capitalize(                           // const C: TTemplateLiteral<[\r\n  Type.TemplateLiteral('hello${1|2|3}')              //   TLiteral<'Hello'>,\r\n)                                                    //   TUnion<[\r\n                                                     //     TLiteral<'1'>,\r\n                                                     //     TLiteral<'2'>,\r\n                                                     //     TLiteral<'3'>\r\n                                                     //   ]>\r\n                                                     // ]>\r\n```\r\n\r\n<a name='types-unsafe'></a>\r\n\r\n### Unsafe Types\r\n\r\nTypeBox supports user defined types with Unsafe. This type allows you to specify both schema representation and inference type. The following creates an Unsafe type with a number schema that infers as string.\r\n\r\n```typescript\r\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\r\n                                                     //   type: 'number'\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string - ?\r\n```\r\nThe Unsafe type is often used to create schematics for extended specifications like OpenAPI\r\n```typescript\r\n\r\nconst Nullable = <T extends TSchema>(schema: T) => Type.Unsafe<Static<T> | null>({ \r\n  ...schema, nullable: true \r\n})\r\n\r\nconst T = Nullable(Type.String())                    // const T = {\r\n                                                     //   type: 'string',\r\n                                                     //   nullable: true\r\n                                                     // }\r\n\r\ntype T = Static<typeof T>                            // type T = string | null\r\n\r\nconst StringEnum = <T extends string[]>(values: [...T]) => Type.Unsafe<T[number]>({ \r\n  type: 'string', enum: values \r\n})\r\nconst S = StringEnum(['A', 'B', 'C'])                // const S = {\r\n                                                     //   enum: ['A', 'B', 'C']\r\n                                                     // }\r\n\r\ntype S = Static<typeof T>                            // type S = 'A' | 'B' | 'C'\r\n```\r\n<a name='types-guard'></a>\r\n\r\n### TypeGuard\r\n\r\nTypeBox can type check its own types with the TypeGuard module. This module is written for reflection and provides structural tests for every TypeBox type. Functions of this module return `is` guards which can be used with TypeScript control flow assertions to obtain schema inference. The following guards that the value A is TString.\r\n\r\n```typescript\r\nimport { Type, TypeGuard } from '@sinclair/typebox'\r\n\r\nconst A: unknown = { ... }\r\n\r\nif(TypeGuard.TString(A)) {\r\n\r\n  A.type                                             // A.type = 'string'\r\n}\r\n```\r\n\r\n<a name='types-strict'></a>\r\n\r\n### Strict\r\n\r\nTypeBox types contain various symbol properties that are used for reflection, composition and compilation. These properties are not strictly valid Json Schema; so in some cases it may be desirable to omit them. TypeBox provides a `Strict` function that will omit these properties if necessary.\r\n\r\n```typescript\r\nconst T = Type.Object({                              // const T = {\r\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\r\n})                                                   //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string',\r\n                                                     //       [Kind]: 'String',\r\n                                                     //       [Optional]: 'Optional'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n\r\nconst U = Type.Strict(T)                             // const U = {\r\n                                                     //   type: 'object',\r\n                                                     //   properties: {\r\n                                                     //     name: {\r\n                                                     //       type: 'string'\r\n                                                     //     }\r\n                                                     //   }\r\n                                                     // }\r\n```\r\n\r\n<a name='values'></a>\r\n\r\n## Values\r\n\r\nTypeBox provides an optional utility module that can be used to perform structural operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\r\n\r\n```typescript\r\nimport { Value } from '@sinclair/typebox/value'\r\n```\r\n\r\n<a name='values-create'></a>\r\n\r\n### Create\r\n\r\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\r\n\r\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\r\n```\r\n\r\n<a name='values-clone'></a>\r\n\r\n### Clone\r\n\r\nUse the Clone function to deeply clone a value.\r\n\r\n```typescript\r\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\r\n```\r\n\r\n<a name='values-check'></a>\r\n\r\n### Check\r\n\r\nUse the Check function to type check a value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R = Value.Check(T, { x: 1 })                   // const R = true\r\n```\r\n\r\n<a name='values-convert'></a>\r\n\r\n### Convert\r\n\r\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible. This function may return an invalid value and should be checked before use. Its return type is `unknown`.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number() })\r\n\r\nconst R1 = Value.Convert(T, { x: '3.14' })           // const R1 = { x: 3.14 }\r\n\r\nconst R2 = Value.Convert(T, { x: 'not a number' })   // const R2 = { x: 'not a number' }\r\n```\r\n\r\n<a name='values-clean'></a>\r\n\r\n### Clean\r\n\r\nRemoves excess properties from a value and returns the result. This function does not check the value and returns an unknown type. You should Check the result before use. Clean is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number(), \r\n  y: Type.Number() \r\n})\r\n\r\nconst X = Value.Clean(T, null)                        // const 'X = null\r\n\r\nconst Y = Value.Clean(T, { x: 1 })                    // const 'Y = { x: 1 }\r\n\r\nconst Z = Value.Clean(T, { x: 1, y: 2, z: 3 })        // const 'Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-default'></a>\r\n\r\n### Default\r\n\r\nGenerates missing properties on a value using default schema annotations if available. This function does not check the value and returns an unknown type. You should Check the result before use. Default is a mutable operation. To avoid mutation, Clone the value first.\r\n\r\n```typescript\r\nconst T = Type.Object({ \r\n  x: Type.Number({ default: 0 }), \r\n  y: Type.Number({ default: 0 })\r\n})\r\n\r\nconst X = Value.Default(T, null)                        // const 'X = null - non-enumerable\r\n\r\nconst Y = Value.Default(T, { })                         // const 'Y = { x: 0, y: 0 }\r\n\r\nconst Z = Value.Default(T, { x: 1 })                    // const 'Z = { x: 1, y: 0 }\r\n```\r\n\r\n<a name='values-cast'></a>\r\n\r\n### Cast\r\n\r\nUse the Cast function to cast a value with a type. The cast function will retain as much information as possible from the original value.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\r\n\r\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\r\n\r\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\r\n\r\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\r\n```\r\n\r\n<a name='values-decode'></a>\r\n\r\n### Decode\r\n\r\nUse the Decode function to decode a value from a type, or throw if the value is invalid. The return value will infer as the decoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Decode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Decode(Type.String(), 42)             // throw\r\n```\r\n<a name='values-decode'></a>\r\n\r\n### Encode\r\n\r\nUse the Encode function to encode a value to a type, or throw if the value is invalid. The return value will infer as the encoded type. This function will run Transform codecs if available.\r\n\r\n```typescript\r\nconst A = Value.Encode(Type.String(), 'hello')        // const A = 'hello'\r\n\r\nconst B = Value.Encode(Type.String(), 42)             // throw\r\n```\r\n\r\n<a name='values-equal'></a>\r\n\r\n### Equal\r\n\r\nUse the Equal function to deeply check for value equality.\r\n\r\n```typescript\r\nconst R = Value.Equal(                               // const R = true\r\n  { x: 1, y: 2, z: 3 },\r\n  { x: 1, y: 2, z: 3 }\r\n)\r\n```\r\n\r\n<a name='values-hash'></a>\r\n\r\n### Hash\r\n\r\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\r\n\r\n```typescript\r\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })           // const A = 2910466848807138541n\r\n\r\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })           // const B = 1418369778807423581n\r\n```\r\n\r\n<a name='values-diff'></a>\r\n\r\n### Diff\r\n\r\nUse the Diff function to generate a sequence of edits that will transform one value into another.\r\n\r\n```typescript\r\nconst E = Value.Diff(                                // const E = [\r\n  { x: 1, y: 2, z: 3 },                              //   { type: 'update', path: '/y', value: 4 },\r\n  { y: 4, z: 5, w: 6 }                               //   { type: 'update', path: '/z', value: 5 },\r\n)                                                    //   { type: 'insert', path: '/w', value: 6 },\r\n                                                     //   { type: 'delete', path: '/x' }\r\n                                                     // ]\r\n```\r\n\r\n<a name='values-patch'></a>\r\n\r\n### Patch\r\n\r\nUse the Patch function to apply a sequence of edits.\r\n\r\n```typescript\r\nconst A = { x: 1, y: 2 }\r\n\r\nconst B = { x: 3 }\r\n\r\nconst E = Value.Diff(A, B)                           // const E = [\r\n                                                     //   { type: 'update', path: '/x', value: 3 },\r\n                                                     //   { type: 'delete', path: '/y' }\r\n                                                     // ]\r\n\r\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\r\n```\r\n\r\n<a name='values-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the Errors function to enumerate validation errors.\r\n\r\n```typescript\r\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\r\n\r\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: '42',\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\n<a name='values-mutate'></a>\r\n\r\n### Mutate\r\n\r\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\r\n\r\n```typescript\r\nconst Y = { z: 1 }                                   // const Y = { z: 1 }\r\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\r\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }\r\n\r\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }\r\n\r\nconst R0 = A.x.y.z === 2                             // const R0 = true\r\nconst R1 = A.x.y === Y                               // const R1 = true\r\nconst R2 = A.x === X                                 // const R2 = true\r\n```\r\n\r\n<a name='values-pointer'></a>\r\n\r\n### Pointer\r\n\r\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) Json Pointers.\r\n\r\n```typescript\r\nimport { ValuePointer } from '@sinclair/typebox/value'\r\n\r\nconst A = { x: 0, y: 0, z: 0 }\r\n\r\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\r\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\r\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\r\n```\r\n\r\n<a name='typeregistry'></a>\r\n\r\n## TypeRegistry\r\n\r\nThe TypeBox type system can be extended with additional types and formats using the TypeRegistry and FormatRegistry modules. These modules integrate deeply with TypeBox's internal type checking infrastructure and can be used to create application specific types, or register schematics for alternative specifications.\r\n\r\n<a name='typeregistry-type'></a>\r\n\r\n### TypeRegistry\r\n\r\nUse the TypeRegistry to register a new type. The Kind must match the registered type name.\r\n\r\n```typescript\r\nimport { TypeRegistry, Symbols } from '@sinclair/typebox'\r\n\r\nTypeRegistry.Set('Foo', (schema, value) => value === 'foo')\r\n\r\nconst A = Value.Check({ [Kind]: 'Foo' }, 'foo')      // const A = true\r\nconst B = Value.Check({ [Kind]: 'Foo' }, 'bar')      // const B = false\r\n```\r\n\r\n<a name='typeregistry-format'></a>\r\n\r\n### FormatRegistry\r\n\r\nUse the FormatRegistry to register a string format.\r\n\r\n```typescript\r\nimport { FormatRegistry } from '@sinclair/typebox'\r\n\r\nFormatRegistry.Set('foo', (value) => value === 'foo')\r\n\r\nconst T = Type.String({ format: 'foo' })\r\n\r\nconst A = Value.Check(T, 'foo')                      // const A = true\r\nconst B = Value.Check(T, 'bar')                      // const B = false\r\n```\r\n\r\n<a name='typecheck'></a>\r\n\r\n## TypeCheck\r\n\r\nTypeBox types target Json Schema Draft 7 and are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for TypeBox types that offers high performance compilation and value checking.\r\n\r\nThe following sections detail using Ajv and the TypeBox compiler infrastructure.\r\n\r\n<a name='typecheck-ajv'></a>\r\n\r\n## Ajv\r\n\r\nThe following shows the recommended setup for Ajv.\r\n\r\n```bash\r\n$ npm install ajv ajv-formats --save\r\n```\r\n\r\n```typescript\r\nimport { Type }   from '@sinclair/typebox'\r\nimport addFormats from 'ajv-formats'\r\nimport Ajv        from 'ajv'\r\n\r\nconst ajv = addFormats(new Ajv({}), [\r\n  'date-time',\r\n  'time',\r\n  'date',\r\n  'email',\r\n  'hostname',\r\n  'ipv4',\r\n  'ipv6',\r\n  'uri',\r\n  'uri-reference',\r\n  'uuid',\r\n  'uri-template',\r\n  'json-pointer',\r\n  'relative-json-pointer',\r\n  'regex'\r\n])\r\n\r\nconst validate = ajv.compile(Type.Object({\r\n  x: Type.Number(),\r\n  y: Type.Number(),\r\n  z: Type.Number()\r\n}))\r\n\r\nconst R = validate({ x: 1, y: 2, z: 3 })             // const R = true\r\n```\r\n\r\n<a name='typecheck-typecompiler'></a>\r\n\r\n### TypeCompiler\r\n\r\nThe TypeBox TypeCompiler is a high performance JIT validation compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is built to serve as a validation backend that can be integrated into larger applications. It can also be used for code generation.\r\n\r\nThe TypeCompiler is provided as an optional import.\r\n\r\n```typescript\r\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\r\n```\r\n\r\nUse the Compile function to JIT compile a type. Note that compilation is generally an expensive operation and should only be performed once per type during application start up. TypeBox does not cache previously compiled types, and applications are expected to hold references to each compiled type for the lifetime of the application.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\r\n```\r\n\r\nUse the Errors function to generate diagnostic errors for a value. The Errors function will return an iterator that when enumerated; will perform an exhaustive check across the entire value yielding any error found. For performance, this function should only be called after a failed Check. Applications may also choose to yield only the first value to avoid exhaustive error generation.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\r\n  x: Type.Number(),                                  //     x: TNumber;\r\n  y: Type.Number(),                                  //     y: TNumber;\r\n  z: Type.Number()                                   //     z: TNumber;\r\n}))                                                  // }>>\r\n\r\nconst value = { }\r\n\r\nconst first = C.Errors(value).First()                // const first = {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }\r\n\r\nconst all = [...C.Errors(value)]                     // const all = [{\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/x',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/y',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }, {\r\n                                                     //   schema: { type: 'number' },\r\n                                                     //   path: '/z',\r\n                                                     //   value: undefined,\r\n                                                     //   message: 'Expected number'\r\n                                                     // }]\r\n```\r\n\r\nUse the Code function to generate assertion functions as strings. This function can be used to create high performance assertions that can be written to disk as importable modules. The following generates code to check a string.\r\n\r\n```typescript\r\nconst C = TypeCompiler.Code(Type.String())           // const C = `return function check(value) {\r\n                                                     //   return (\r\n                                                     //     (typeof value === 'string')\r\n                                                     //   )\r\n                                                     // }`\r\n```\r\n\r\n<a name='typesystem'></a>\r\n\r\n## TypeSystem\r\n\r\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the built-in Json and JavaScript type sets. They also manage TypeBox's localization options (i18n) for error message generation and can control various assertion policies used when type checking. Configurations made to the TypeSystem module are observed by the TypeCompiler, Value and Error modules.\r\n\r\n<a name='typesystem-errors'></a>\r\n\r\n### Errors\r\n\r\nUse the TypeSystemErrorFunction to override validation error messages. This can be used to localize errors or create error messages for user defined types.\r\n\r\n```typescript\r\nimport { TypeSystemErrorFunction, ValueErrorType, DefaultErrorFunction } from '@sinclair/typebox/system'\r\n\r\nTypeSystemErrorFunction.Set((schema, errorType) => { // i18n override\r\n  switch(errorType) {\r\n    /* en-US */ case ValueErrorType.String: return 'Expected string'\r\n    /* fr-FR */ case ValueErrorType.Number: return 'Nombre attendu'  \r\n    /* ko-KR */ case ValueErrorType.Boolean: return '예상 부울'      \r\n    /* en-US */ default: return DefaultErrorFunction(schema, errorType)          \r\n  }\r\n})\r\nconst T = Type.Object({                              // const T = { ... }\r\n  x: Type.String(),\r\n  y: Type.Number(),\r\n  z: Type.Boolean()\r\n})\r\nconst E = [...Value.Errors(T, {                      // const E = [{\r\n  x: null,                                           //   type: 48,\r\n  y: null,                                           //   schema: { ... },\r\n  z: null                                            //   path: '/x',\r\n})]                                                  //   value: null,\r\n                                                     //   message: 'Expected string'\r\n                                                     // }, {\r\n                                                     //   type: 34,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/y',\r\n                                                     //   value: null,\r\n                                                     //   message: 'Nombre attendu'\r\n                                                     // }, {\r\n                                                     //   type: 14,\r\n                                                     //   schema: { ... },\r\n                                                     //   path: '/z',\r\n                                                     //   value: null,\r\n                                                     //   message: '예상 부울'\r\n                                                     // }]\r\n```\r\n\r\n<a name='typesystem-policies'></a>\r\n\r\n### Policies\r\n\r\nTypeBox validates using standard Json Schema assertion policies by default. The TypeSystemPolicy module can override some of these to have TypeBox check values inline with TypeScript static assertions. It also provides overrides for certain checking rules related to non-serializable values (such as void) which can be useful in Json based protocols such as JsonRpc-2. \r\n\r\nThe following overrides are available.\r\n\r\n```typescript\r\nimport { TypeSystemPolicy } from '@sinclair/typebox/system'\r\n\r\n// Disallow undefined values for optional properties (default is false)\r\n//\r\n// const A: { x?: number } = { x: undefined } - disallowed when enabled\r\n\r\nTypeSystemPolicy.ExactOptionalPropertyTypes = true\r\n\r\n// Allow arrays to validate as object types (default is false)\r\n//\r\n// const A: {} = [] - allowed in TS\r\n\r\nTypeSystemPolicy.AllowArrayObject = true\r\n\r\n// Allow numeric values to be NaN or + or - Infinity (default is false)\r\n//\r\n// const A: number = NaN - allowed in TS\r\n\r\nTypeSystemPolicy.AllowNaN = true\r\n\r\n// Allow void types to check with undefined and null (default is false)\r\n//\r\n// Used to signal void return on Json-RPC 2.0 protocol\r\n\r\nTypeSystemPolicy.AllowNullVoid = true\r\n```\r\n\r\n<a name='workbench'></a>\r\n\r\n## TypeBox Workbench\r\n\r\nTypeBox offers a web based code generation tool that can convert TypeScript types into TypeBox types as well as several other ecosystem libraries.\r\n\r\n[TypeBox Workbench Link Here](https://sinclairzx81.github.io/typebox-workbench/)\r\n\r\n<a name='codegen'></a>\r\n\r\n## TypeBox Codegen\r\n\r\nTypeBox provides a code generation library that can be used to automate type translation between TypeScript and TypeBox. This library also includes functionality to transform TypeScript types to other ecosystem libraries.\r\n\r\n[TypeBox Codegen Link Here](https://github.com/sinclairzx81/typebox-codegen)\r\n\r\n<a name='ecosystem'></a>\r\n\r\n## Ecosystem\r\n\r\nThe following is a list of community packages that offer general tooling, extended functionality and framework integration support for TypeBox.\r\n\r\n| Package   |  Description |\r\n| ------------- | ------------- |\r\n| [drizzle-typebox](https://www.npmjs.com/package/drizzle-typebox) | Generates TypeBox types from Drizzle ORM schemas |\r\n| [elysia](https://github.com/elysiajs/elysia) | Fast and friendly Bun web framework |\r\n| [fastify-type-provider-typebox](https://github.com/fastify/fastify-type-provider-typebox) | Fastify TypeBox integration with the Fastify Type Provider |\r\n| [feathersjs](https://github.com/feathersjs/feathers) | The API and real-time application framework |\r\n| [fetch-typebox](https://github.com/erfanium/fetch-typebox) | Drop-in replacement for fetch that brings easy integration with TypeBox |\r\n| [h3-typebox](https://github.com/kevinmarrec/h3-typebox) | Schema validation utilities for h3 using TypeBox & Ajv |\r\n| [http-wizard](https://github.com/flodlc/http-wizard) | Type safe http client library for Fastify |\r\n| [openapi-box](https://github.com/geut/openapi-box) | Generate TypeBox types from OpenApi IDL + Http client library |\r\n| [schema2typebox](https://github.com/xddq/schema2typebox)  | Creating TypeBox code from Json Schemas |\r\n| [ts2typebox](https://github.com/xddq/ts2typebox) | Creating TypeBox code from Typescript types |\r\n| [typebox-form-parser](https://github.com/jtlapp/typebox-form-parser) | Parses form and query data based on TypeBox schemas |\r\n| [typebox-validators](https://github.com/jtlapp/typebox-validators) | Advanced validators supporting discriminated and heterogeneous unions |\r\n\r\n<a name='benchmark'></a>\r\n\r\n## Benchmark\r\n\r\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0 running on Node 20.0.0.\r\n\r\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\r\n\r\n<a name='benchmark-compile'></a>\r\n\r\n### Compile\r\n\r\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/compile.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │    1000    │ '    216 ms' │ '      9 ms' │ '   24.00 x' │\r\n│ Literal_Number             │    1000    │ '    169 ms' │ '      7 ms' │ '   24.14 x' │\r\n│ Literal_Boolean            │    1000    │ '    150 ms' │ '      5 ms' │ '   30.00 x' │\r\n│ Primitive_Number           │    1000    │ '    161 ms' │ '      7 ms' │ '   23.00 x' │\r\n│ Primitive_String           │    1000    │ '    148 ms' │ '      6 ms' │ '   24.67 x' │\r\n│ Primitive_String_Pattern   │    1000    │ '    185 ms' │ '      9 ms' │ '   20.56 x' │\r\n│ Primitive_Boolean          │    1000    │ '    132 ms' │ '      4 ms' │ '   33.00 x' │\r\n│ Primitive_Null             │    1000    │ '    141 ms' │ '      3 ms' │ '   47.00 x' │\r\n│ Object_Unconstrained       │    1000    │ '   1109 ms' │ '     30 ms' │ '   36.97 x' │\r\n│ Object_Constrained         │    1000    │ '   1200 ms' │ '     24 ms' │ '   50.00 x' │\r\n│ Object_Vector3             │    1000    │ '    379 ms' │ '      9 ms' │ '   42.11 x' │\r\n│ Object_Box3D               │    1000    │ '   1709 ms' │ '     30 ms' │ '   56.97 x' │\r\n│ Tuple_Primitive            │    1000    │ '    456 ms' │ '     14 ms' │ '   32.57 x' │\r\n│ Tuple_Object               │    1000    │ '   1229 ms' │ '     17 ms' │ '   72.29 x' │\r\n│ Composite_Intersect        │    1000    │ '    570 ms' │ '     17 ms' │ '   33.53 x' │\r\n│ Composite_Union            │    1000    │ '    513 ms' │ '     19 ms' │ '   27.00 x' │\r\n│ Math_Vector4               │    1000    │ '    782 ms' │ '     13 ms' │ '   60.15 x' │\r\n│ Math_Matrix4               │    1000    │ '    393 ms' │ '     12 ms' │ '   32.75 x' │\r\n│ Array_Primitive_Number     │    1000    │ '    361 ms' │ '     12 ms' │ '   30.08 x' │\r\n│ Array_Primitive_String     │    1000    │ '    296 ms' │ '      5 ms' │ '   59.20 x' │\r\n│ Array_Primitive_Boolean    │    1000    │ '    315 ms' │ '      4 ms' │ '   78.75 x' │\r\n│ Array_Object_Unconstrained │    1000    │ '   1721 ms' │ '     22 ms' │ '   78.23 x' │\r\n│ Array_Object_Constrained   │    1000    │ '   1450 ms' │ '     21 ms' │ '   69.05 x' │\r\n│ Array_Tuple_Primitive      │    1000    │ '    813 ms' │ '     13 ms' │ '   62.54 x' │\r\n│ Array_Tuple_Object         │    1000    │ '   1537 ms' │ '     17 ms' │ '   90.41 x' │\r\n│ Array_Composite_Intersect  │    1000    │ '    753 ms' │ '     17 ms' │ '   44.29 x' │\r\n│ Array_Composite_Union      │    1000    │ '    808 ms' │ '     16 ms' │ '   50.50 x' │\r\n│ Array_Math_Vector4         │    1000    │ '   1118 ms' │ '     16 ms' │ '   69.88 x' │\r\n│ Array_Math_Matrix4         │    1000    │ '    690 ms' │ '      9 ms' │ '   76.67 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-validate'></a>\r\n\r\n### Validate\r\n\r\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/build/benchmark/measurement/module/check.ts).\r\n\r\n```typescript\r\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\r\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\r\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\r\n│ Literal_String             │  1000000   │ '     24 ms' │ '      5 ms' │ '      4 ms' │ '    1.25 x' │\r\n│ Literal_Number             │  1000000   │ '     15 ms' │ '     20 ms' │ '     10 ms' │ '    2.00 x' │\r\n│ Literal_Boolean            │  1000000   │ '     14 ms' │ '     19 ms' │ '      9 ms' │ '    2.11 x' │\r\n│ Primitive_Number           │  1000000   │ '     25 ms' │ '     18 ms' │ '     10 ms' │ '    1.80 x' │\r\n│ Primitive_String           │  1000000   │ '     21 ms' │ '     24 ms' │ '      9 ms' │ '    2.67 x' │\r\n│ Primitive_String_Pattern   │  1000000   │ '    156 ms' │ '     43 ms' │ '     38 ms' │ '    1.13 x' │\r\n│ Primitive_Boolean          │  1000000   │ '     18 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Primitive_Null             │  1000000   │ '     20 ms' │ '     17 ms' │ '      9 ms' │ '    1.89 x' │\r\n│ Object_Unconstrained       │  1000000   │ '   1055 ms' │ '     32 ms' │ '     24 ms' │ '    1.33 x' │\r\n│ Object_Constrained         │  1000000   │ '   1232 ms' │ '     49 ms' │ '     43 ms' │ '    1.14 x' │\r\n│ Object_Vector3             │  1000000   │ '    432 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Object_Box3D               │  1000000   │ '   1993 ms' │ '     54 ms' │ '     46 ms' │ '    1.17 x' │\r\n│ Object_Recursive           │  1000000   │ '   5115 ms' │ '    342 ms' │ '    159 ms' │ '    2.15 x' │\r\n│ Tuple_Primitive            │  1000000   │ '    156 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Tuple_Object               │  1000000   │ '    740 ms' │ '     29 ms' │ '     18 ms' │ '    1.61 x' │\r\n│ Composite_Intersect        │  1000000   │ '    797 ms' │ '     26 ms' │ '     14 ms' │ '    1.86 x' │\r\n│ Composite_Union            │  1000000   │ '    530 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\r\n│ Math_Vector4               │  1000000   │ '    240 ms' │ '     22 ms' │ '     11 ms' │ '    2.00 x' │\r\n│ Math_Matrix4               │  1000000   │ '   1036 ms' │ '     39 ms' │ '     27 ms' │ '    1.44 x' │\r\n│ Array_Primitive_Number     │  1000000   │ '    248 ms' │ '     20 ms' │ '     12 ms' │ '    1.67 x' │\r\n│ Array_Primitive_String     │  1000000   │ '    227 ms' │ '     22 ms' │ '     13 ms' │ '    1.69 x' │\r\n│ Array_Primitive_Boolean    │  1000000   │ '    138 ms' │ '     21 ms' │ '     13 ms' │ '    1.62 x' │\r\n│ Array_Object_Unconstrained │  1000000   │ '   5540 ms' │ '     66 ms' │ '     59 ms' │ '    1.12 x' │\r\n│ Array_Object_Constrained   │  1000000   │ '   5750 ms' │ '    123 ms' │ '    108 ms' │ '    1.14 x' │\r\n│ Array_Object_Recursive     │  1000000   │ '  21842 ms' │ '   1771 ms' │ '    599 ms' │ '    2.96 x' │\r\n│ Array_Tuple_Primitive      │  1000000   │ '    715 ms' │ '     36 ms' │ '     29 ms' │ '    1.24 x' │\r\n│ Array_Tuple_Object         │  1000000   │ '   3131 ms' │ '     63 ms' │ '     50 ms' │ '    1.26 x' │\r\n│ Array_Composite_Intersect  │  1000000   │ '   3064 ms' │ '     44 ms' │ '     35 ms' │ '    1.26 x' │\r\n│ Array_Composite_Union      │  1000000   │ '   2172 ms' │ '     65 ms' │ '     31 ms' │ '    2.10 x' │\r\n│ Array_Math_Vector4         │  1000000   │ '   1032 ms' │ '     37 ms' │ '     24 ms' │ '    1.54 x' │\r\n│ Array_Math_Matrix4         │  1000000   │ '   4859 ms' │ '    114 ms' │ '     86 ms' │ '    1.33 x' │\r\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\r\n```\r\n\r\n<a name='benchmark-compression'></a>\r\n\r\n### Compression\r\n\r\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\r\n\r\n```typescript\r\n┌──────────────────────┬────────────┬────────────┬─────────────┐\r\n│       (index)        │  Compiled  │  Minified  │ Compression │\r\n├──────────────────────┼────────────┼────────────┼─────────────┤\r\n│ typebox/compiler     │ '109.3 kb' │ ' 48.5 kb' │  '2.25 x'   │\r\n│ typebox/errors       │ ' 54.8 kb' │ ' 24.9 kb' │  '2.20 x'   │\r\n│ typebox/system       │ ' 12.1 kb' │ '  6.1 kb' │  '1.98 x'   │\r\n│ typebox/type         │ ' 77.8 kb' │ ' 32.8 kb' │  '2.37 x'   │\r\n│ typebox/value        │ '143.7 kb' │ ' 61.2 kb' │  '2.35 x'   │\r\n│ typebox              │ ' 77.9 kb' │ ' 32.8 kb' │  '2.37 x'   │\r\n└──────────────────────┴────────────┴────────────┴─────────────┘\r\n```\r\n\r\n<a name='contribute'></a>\r\n\r\n## Contribute\r\n\r\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\r\n","types":"./build/require/index.d.ts","readmeFilename":"readme.md","_integrity":"sha512-kXQqjqc6Gqg3tlekvD4WDV5uMX60qU4RDvYnnLhwnQ5LizfsnepGNk2SEMKjA7yrBczJTHheNLv3+ZHxle4f9g==","_from":"file:sinclair-typebox-0.32.0-dev-7.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-7_1701497420636_0.07099781757081036"},"_hasShrinkwrap":false},"0.32.0-dev-8":{"_id":"@sinclair/typebox@0.32.0-dev-8","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-8","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"0de661481d98eeac1f2128c3ef9eb8c10c254b97","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-8.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-KdEUKCaVC8cWVOEx+GYxQbwe/SrfeLoY7dmSSVtmw6ddDkl+InwT3kPlHziNzHhOetyzDiV7isFekiXWUzj19Q==","_from":"file:sinclair-typebox-0.32.0-dev-8.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-8_1701498329852_0.5090859952407734"},"_hasShrinkwrap":false},"0.32.0-dev-9":{"_id":"@sinclair/typebox@0.32.0-dev-9","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0-dev-9","keywords":["typescript","json-schema","validate","typecheck"],"author":{"name":"sinclairzx81","email":"","url":""},"repository":{"type":"git","url":"https://github.com/sinclairzx81/typebox"},"license":"MIT","directories":{},"main":"./build/require/index.js","dist":{"shasum":"54f1c18407d418a71e5189c6bc8b2a2b9ccc450a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0-dev-9.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-8bewiPy/yWFu7y2BIM4RCgOdaMd7Ei7bGxVMcTeeVMijbS1DNzMDqgbL6pVKVWcYtFXnqc5yiAQdMJ7MtT7qOg==","_from":"file:sinclair-typebox-0.32.0-dev-9.tgz","_nodeVersion":"18.18.2","_npmVersion":"9.8.1","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0-dev-9_1701508003148_0.8089861599615353"},"_hasShrinkwrap":false},"0.32.0":{"_id":"@sinclair/typebox@0.32.0","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.0","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"17b6003a99f34686cc28d50c3ee2a68c9b3d6099","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.0.tgz"},"module":"./build/import/index.mjs","types":"./build/require/index.d.ts","_integrity":"sha512-FdBgO+ib0JCSPtq55cDva/5xd55vfAAyTXWVLCaTAFzNjVPaR5lNRKoEzMHTtArELEaHNs4E6WmdNJIY+gUoZw==","_from":"file:sinclair-typebox-0.32.0.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.0_1703221645352_0.7914765093974809"},"_hasShrinkwrap":false},"0.32.1":{"_id":"@sinclair/typebox@0.32.1","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.1","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"082ce58e8fc9200a1056e76a467bf8ae1ffcf33e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.1.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-DJKtxrcKL5MqUc5Gr0w+m/744wXhinq3d3hrRokNz4I9v5JbQCJleYqaQGfFwgkeZKHh01abFevbWX44CmUy1w==","_from":"file:sinclair-typebox-0.32.1.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.1_1703306657818_0.866481235770802"},"_hasShrinkwrap":false},"0.32.2":{"_id":"@sinclair/typebox@0.32.2","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.2","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"11ced43441a33757e9857e21dff60ce2f693eac9","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.2.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-QnCMPXH56cA/hYiHGZSm1nvopFisrubJu4gYTWAapT66ieo3yroPc6hLYFieAs+D9ZLJuD910adm117xZplsOQ==","_from":"file:sinclair-typebox-0.32.2.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.2_1703420273718_0.037704388134492284"},"_hasShrinkwrap":false},"0.32.3":{"_id":"@sinclair/typebox@0.32.3","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.3","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ccc2ae8b59f9a7e8e1f6aea0965ef8ee2c7796c8","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.3.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-o1OzDySkCSEobAEAVS1SGrzznes9KqPOC3arGfH5rQhOIeokLQYLKQmy68lr979BmPr43v4m9d85ttUSRpHdFA==","_from":"file:sinclair-typebox-0.32.3.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.3_1703431817312_0.7447103019296877"},"_hasShrinkwrap":false},"0.32.4":{"_id":"@sinclair/typebox@0.32.4","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.4","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"94b8744215c1f54f38df9bd33626ef821ce66ca3","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.4.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-Q2Pex6H+HGuyxIGuFadkpqwtjZFXiVZlvy1rVX9XgAzUrDmUDEM69M2c4CkWUgMJ1NaFPvUf+cMBljY96GJVNQ==","_from":"file:sinclair-typebox-0.32.4.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.4_1703822784271_0.14906610378893315"},"_hasShrinkwrap":false},"0.32.5":{"_id":"@sinclair/typebox@0.32.5","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.5","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"7f5995e2abc02be4e9fa38b58987b77e0bfe5ead","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.5.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-0M6FyxZwIEu/Ly6W+l7iYqiZQYJ8khLOJGzg+cxivNKRKqk9hctcuDC0UYI7B9vNgycExA8w40m4M3yDKW37RA==","_from":"file:sinclair-typebox-0.32.5.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.5_1704426622807_0.991759221016931"},"_hasShrinkwrap":false},"0.32.6":{"_id":"@sinclair/typebox@0.32.6","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.6","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"b3a7c5290ce6f713924f29ffad0bfdf0db4c1b6a","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.6.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-mgcPAfLZEL2B/hrF+vPDdwwZ1MR0UuALvz+tI2zx7IYHfREmua3C82XsYgkwxCCJKpO3ibTje4QrHYrOAHWhxA==","_from":"file:sinclair-typebox-0.32.6.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.6_1704858995315_0.9069802485019476"},"_hasShrinkwrap":false},"0.32.7":{"_id":"@sinclair/typebox@0.32.7","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.7","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"05822cf21091ddca245c24aa9163bb7384db5c1f","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.7.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-XI+xC3gBLkto5nigJpqxF63uth+3t5PQt3o/yWFvvzuXax1nvRKlm5iSorgyZiT70REsGHk6i4EYeFaONFWwbQ==","_from":"file:sinclair-typebox-0.32.7.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.7_1704884773591_0.2363028479624656"},"_hasShrinkwrap":false},"0.32.8":{"_id":"@sinclair/typebox@0.32.8","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.8","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"9d1559d1dfe8e7f75004cbbb2037d9d0085fef44","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.8.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-ifqNG6GBr0QRao2Vy+2P2WzxkOnpGmHfZCFXWwuR/0elH4h79mGXN8mEYwnJ2qGEr7MGgfqvf8Njwj4dBGFMBA==","_from":"file:sinclair-typebox-0.32.8.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.8_1704888224150_0.7265404898731502"},"_hasShrinkwrap":false},"0.32.9":{"_id":"@sinclair/typebox@0.32.9","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.9","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"025f05fa16aea3357f78cdcdbecbd6047de87673","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.9.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-6oeJJPTIb0y3cs713HmXmXSx3WRWgid74KICYL9blOhNFuAcAB18dDWfATgcgzynfpF5xDzHGxEVbDYYr6nvgg==","_from":"file:sinclair-typebox-0.32.9.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.9_1705071871399_0.7575111929761458"},"_hasShrinkwrap":false},"0.32.10":{"_id":"@sinclair/typebox@0.32.10","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.10","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"346ee6b68242142a28e01d72b42521b43a005156","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.10.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-CZwwK09fdC/uKPD/cCJbNBLPQww3gYl5bYu86cqfziPXTVatUGU/o+vqu84gDGuIDoQRIvCB0Uj0MvcgsCsb8g==","_from":"file:sinclair-typebox-0.32.10.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.10_1705510851908_0.6690640622086526"},"_hasShrinkwrap":false},"0.32.11":{"_id":"@sinclair/typebox@0.32.11","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.11","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"b0ec8db3b178dfd237e07b0f952cff08e6f7a16d","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.11.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-YtmrPo85LgWnw12GEwfdu44P/I7GsU6r/7PNHDxToHEIJxZk0+c3pZQBBj9ElP2uB2UwG2H2aazB+UHDG4iC1w==","_from":"file:sinclair-typebox-0.32.11.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.11_1705775592972_0.4731341080164333"},"_hasShrinkwrap":false},"0.32.12":{"_id":"@sinclair/typebox@0.32.12","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.12","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"6e0fef781f9ec6709d6c6c7e38984c8e7af3a1da","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.12.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-uKRQW9a+alkPwZMzQk6W8cCZC117kZJZ3GQx3Yn9unu2oWX09PxEsyMF7D9tuvoH8se1hIZqLRja+FtU7HKGhQ==","_from":"file:sinclair-typebox-0.32.12.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.12_1705817671730_0.8824180790747733"},"_hasShrinkwrap":false},"0.32.13":{"_id":"@sinclair/typebox@0.32.13","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.13","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"1b9bf6de7319d17bfb6e34b9b5b2051ba6c71278","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.13.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-6gfhrgov2RWxPIlGyFcCVn1DejhmQvObIiBIx/Qx3FRnxlLS/RuoyDxK1hhhVU+S5+1Xmul32QALLErVfinyxw==","_from":"file:sinclair-typebox-0.32.13.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.13_1706219567676_0.3333706276843005"},"_hasShrinkwrap":false},"0.32.14":{"_id":"@sinclair/typebox@0.32.14","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.14","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"ef0a4ed981515fd430cadfb65cb6c2719a0b5539","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.14.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-EC77Mw8huT2z9YlYbWfpIQgN6shZE1tH4NP4/Trig8UBel9FZNMZRJ42ubJI8PLor2uIU+waLml1dce5ReCOPg==","_from":"file:sinclair-typebox-0.32.14.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.14_1707621652940_0.6247011545994094"},"_hasShrinkwrap":false},"0.32.15":{"_id":"@sinclair/typebox@0.32.15","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.15","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"92dcdc12907f7c0f6d954ba3700b5bb888d2eb34","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.15.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-5Lrwo7VOiWEBJBhHmqNmf3TPB9ll8gcEshvYJyAIJyCZ2PF48MFOtiDHJNj8+FsNcqImaQYmxVkKBCBlyAa/wg==","_from":"file:sinclair-typebox-0.32.15.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.15_1709279116128_0.6695122325566814"},"_hasShrinkwrap":false},"0.32.16":{"_id":"@sinclair/typebox@0.32.16","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.16","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"1c5f3a0007aa751dfc382f977a0994c648489849","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.16.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-jNsVbv3jV58KBSXIhnEOuEI6mquQbW72HcDDEAHH22qvCaiwGozcaLbL4NEfInMqkDZ0FLFctjOGx4ysxVY8Lw==","_from":"file:sinclair-typebox-0.32.16.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.16_1710869311784_0.7095818671313754"},"_hasShrinkwrap":false},"0.32.17":{"_id":"@sinclair/typebox@0.32.17","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.17","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"4b9795a5c42c84a03d27f0f466be87149a8e326e","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.17.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-jgY31gR1xtOB9XpGo+xqrq6K3ssdEyCPKSrB6uRUPNuZ26L5S4u8Qi+bhiNa6PbJklozEoFZvbev7SoQ9ffuAA==","_from":"file:sinclair-typebox-0.32.17.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.17_1710928055554_0.2750633725638476"},"_hasShrinkwrap":false},"0.32.18":{"_id":"@sinclair/typebox@0.32.18","name":"@sinclair/typebox","description":"Json Schema Type Builder with Static Type Resolution for TypeScript","version":"0.32.18","keywords":["typescript","json-schema","validate","typecheck"],"homepage":"https://github.com/sinclairzx81/typebox#readme","author":{"name":"sinclairzx81"},"repository":{"type":"git","url":"git+https://github.com/sinclairzx81/typebox.git"},"bugs":{"url":"https://github.com/sinclairzx81/typebox/issues"},"license":"MIT","scripts":{"test":"echo test"},"directories":{},"main":"./build/require/index.js","dist":{"shasum":"6d342310d85a993edec9a32fce9eb3d03d2bb008","tarball":"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-public-npm/npm/registry/@sinclair/typebox/-/typebox-0.32.18.tgz"},"types":"./build/require/index.d.ts","module":"./build/import/index.mjs","_integrity":"sha512-ioMK5TA5YOloYf/GcnF+1fT4eTvowJes2j7Pm0Ivlm9xq61keqQw/XtbQQnPG8O4uq2y2DDenU8OqNc93xn11Q==","_from":"file:sinclair-typebox-0.32.18.tgz","_nodeVersion":"20.10.0","_npmVersion":"10.2.3","_npmUser":{"name":"sinclair","email":"haydn.developer@gmail.com"},"maintainers":[{"name":"sinclair","email":"haydn.developer@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/typebox_0.32.18_1711007365247_0.9585034567983084"},"_hasShrinkwrap":false}},"time":{"created":"2023-01-13T12:58:58Z","modified":"2024-03-21T11:49:50Z","0.8.0":"2023-01-13T12:58:58Z","0.8.1":"2023-01-13T12:58:58Z","0.9.0":"2023-01-13T12:58:58Z","0.9.1":"2023-01-13T12:58:58Z","0.9.2":"2023-01-13T12:58:58Z","0.9.3":"2023-01-13T12:58:58Z","0.9.4":"2023-01-13T12:58:58Z","0.9.5":"2023-01-13T12:58:58Z","0.9.6":"2023-01-13T12:58:58Z","0.9.7":"2023-01-13T12:58:58Z","0.9.8":"2023-01-13T12:58:58Z","0.9.9":"2023-01-13T12:58:58Z","0.9.10":"2023-01-13T12:58:58Z","0.9.11":"2023-01-13T12:58:58Z","0.9.12":"2023-01-13T12:58:58Z","0.9.13":"2023-01-13T12:58:58Z","0.9.14":"2023-01-13T12:58:58Z","0.9.15":"2023-01-13T12:58:58Z","0.9.16":"2023-01-13T12:58:58Z","0.10.0":"2023-01-13T12:58:58Z","0.10.1":"2023-01-13T12:58:58Z","0.11.0":"2023-01-13T12:58:58Z","0.12.0":"2023-01-13T12:58:58Z","0.12.1":"2023-01-13T12:58:58Z","0.12.2":"2023-01-13T12:58:58Z","0.12.3":"2023-01-13T12:58:58Z","0.12.4":"2023-01-13T12:58:58Z","0.12.5":"2023-01-13T12:58:58Z","0.12.6":"2023-01-13T12:58:58Z","0.12.7":"2023-01-13T12:58:58Z","0.12.8":"2023-01-13T12:58:58Z","0.12.9":"2023-01-13T12:58:58Z","0.14.0":"2023-01-13T12:58:58Z","0.14.1":"2023-01-13T12:58:58Z","0.15.0":"2023-01-13T12:58:58Z","0.16.0":"2023-01-13T12:58:58Z","0.16.1":"2023-01-13T12:58:58Z","0.16.2":"2023-01-13T12:58:58Z","0.16.3":"2023-01-13T12:58:58Z","0.16.4":"2023-01-13T12:58:58Z","0.16.5":"2023-01-13T12:58:58Z","0.16.6":"2023-01-13T12:58:58Z","0.16.7":"2023-01-13T12:58:58Z","0.17.0":"2023-01-13T12:58:58Z","0.17.1":"2023-01-13T12:58:58Z","0.17.2":"2023-01-13T12:58:58Z","0.17.3":"2023-01-13T12:58:58Z","0.17.4":"2023-01-13T12:58:58Z","0.17.5":"2023-01-13T12:58:58Z","0.17.6":"2023-01-13T12:58:58Z","0.17.7":"2023-01-13T12:58:58Z","0.17.8":"2023-01-13T12:58:58Z","0.18.0":"2023-01-13T12:58:58Z","0.18.1":"2023-01-13T12:58:58Z","0.19.0":"2023-01-13T12:58:58Z","0.19.1":"2023-01-13T12:58:58Z","0.19.2":"2023-01-13T12:58:58Z","0.20.0":"2023-01-13T12:58:58Z","0.20.1":"2023-01-13T12:58:58Z","0.20.2":"2023-01-13T12:58:58Z","0.20.3":"2023-01-13T12:58:58Z","0.20.4":"2023-01-13T12:58:58Z","0.20.5":"2023-01-13T12:58:58Z","0.20.6":"2023-01-13T12:58:58Z","0.21.0":"2023-01-13T12:58:58Z","0.21.1":"2023-01-13T12:58:58Z","0.21.2":"2023-01-13T12:58:58Z","0.22.0":"2023-01-13T12:58:58Z","0.22.1":"2023-01-13T12:58:58Z","0.23.0":"2023-01-13T12:58:58Z","0.23.1":"2023-01-13T12:58:58Z","0.23.2":"2023-01-13T12:58:58Z","0.23.3":"2023-01-13T12:58:58Z","0.23.4":"2023-01-13T12:58:58Z","0.23.5":"2023-01-13T12:58:58Z","0.24.0":"2023-01-13T12:58:58Z","0.24.1":"2023-01-13T12:58:58Z","0.24.2":"2023-01-13T12:58:58Z","0.24.3":"2023-01-13T12:58:58Z","0.24.4":"2023-01-13T12:58:58Z","0.24.5":"2023-01-13T12:58:58Z","0.24.6":"2023-01-13T12:58:58Z","0.24.7":"2023-01-13T12:58:58Z","0.24.8":"2023-01-13T12:58:58Z","0.24.9":"2023-01-13T12:58:58Z","0.24.10":"2023-01-13T12:58:58Z","0.24.11":"2023-01-13T12:58:58Z","0.24.12":"2023-01-13T12:58:58Z","0.24.13":"2023-01-13T12:58:58Z","0.24.14":"2023-01-13T12:58:58Z","0.24.15":"2023-01-13T12:58:58Z","0.24.16":"2023-01-13T12:58:58Z","0.24.17":"2023-01-13T12:58:58Z","0.24.18":"2023-01-13T12:58:58Z","0.24.19":"2023-01-13T12:58:58Z","0.24.20":"2023-01-13T12:58:58Z","0.24.21":"2023-01-13T12:58:58Z","0.24.22":"2023-01-13T12:58:58Z","0.24.23":"2023-01-13T12:58:58Z","0.24.24":"2023-01-13T12:58:58Z","0.24.25":"2023-01-13T12:58:58Z","0.24.26":"2023-01-13T12:58:58Z","0.24.27":"2023-01-13T12:58:58Z","0.24.28":"2023-01-13T12:58:58Z","0.24.29":"2023-01-13T12:58:58Z","0.24.30":"2023-01-13T12:58:58Z","0.24.31":"2023-01-13T12:58:58Z","0.24.32":"2023-01-13T12:58:58Z","0.24.33":"2023-01-13T12:58:58Z","0.24.34":"2023-01-13T12:58:58Z","0.24.35":"2023-01-13T12:58:58Z","0.24.36":"2023-01-13T12:58:58Z","0.24.37":"2023-01-13T12:58:58Z","0.24.38":"2023-01-13T12:58:58Z","0.24.39":"2023-01-13T12:58:58Z","0.24.40":"2023-01-13T12:58:58Z","0.24.41":"2023-01-13T12:58:58Z","0.24.42":"2023-01-13T12:58:58Z","0.24.43":"2023-01-13T12:58:58Z","0.24.44":"2023-01-13T12:58:58Z","0.24.45":"2023-01-13T12:58:58Z","0.24.46":"2023-01-13T12:58:58Z","0.24.47":"2023-01-13T12:58:58Z","0.24.48":"2023-01-13T12:58:58Z","0.24.49":"2023-01-13T12:58:58Z","0.24.50":"2023-01-13T12:58:58Z","0.24.51":"2023-01-13T12:59:09Z","0.25.0":"2023-01-13T12:58:58Z","0.25.1":"2023-01-13T12:58:58Z","0.25.2":"2023-01-13T12:58:58Z","0.25.3":"2023-01-13T12:58:58Z","0.25.4":"2023-01-13T12:58:58Z","0.25.5":"2023-01-13T12:58:58Z","0.25.6":"2023-01-13T12:58:58Z","0.25.7":"2023-01-13T12:58:58Z","0.25.8":"2023-01-13T12:58:58Z","0.25.9":"2023-01-13T12:58:58Z","0.25.10":"2023-01-13T12:58:58Z","0.25.11":"2023-01-13T12:58:58Z","0.25.12":"2023-01-13T12:58:58Z","0.25.13":"2023-01-13T12:58:58Z","0.25.14":"2023-01-13T12:58:58Z","0.25.15":"2023-01-13T12:58:58Z","0.25.16":"2023-01-13T12:58:58Z","0.25.17":"2023-01-13T12:58:58Z","0.25.18":"2023-01-13T12:58:58Z","0.25.19":"2023-01-13T12:58:58Z","0.25.20":"2023-01-13T12:58:58Z","0.25.21":"2023-01-19T08:51:07Z","0.25.22":"2023-02-15T08:51:09Z","0.25.23":"2023-02-16T11:52:16Z","0.25.24":"2023-03-24T16:54:22Z","0.26.0-dev":"2023-03-17T17:39:19Z","0.26.0-dev.1":"2023-03-18T08:50:22Z","0.26.0-dev.2":"2023-03-18T11:46:03Z","0.26.0-dev.3":"2023-03-19T05:47:47Z","0.26.0-dev.4":"2023-03-19T11:53:16Z","0.26.0-dev.5":"2023-03-20T08:52:30Z","0.26.0":"2023-03-21T17:53:06Z","0.26.1":"2023-03-22T20:57:09Z","0.26.2":"2023-03-23T08:47:42Z","0.26.3":"2023-03-24T05:45:17Z","0.26.4":"2023-03-26T08:47:34Z","0.26.5":"2023-03-27T05:38:53Z","0.26.6":"2023-03-28T17:51:12Z","0.26.7":"2023-03-29T05:48:11Z","0.26.8":"2023-03-29T20:44:05Z","0.27.0":"2023-04-08T17:58:23Z","0.27.1":"2023-04-10T11:42:48Z","0.27.2":"2023-04-10T23:42:47Z","0.27.3":"2023-04-11T08:46:03Z","0.27.4":"2023-04-12T14:52:56Z","0.27.5":"2023-04-14T02:43:47Z","0.27.6":"2023-04-14T05:51:16Z","0.27.7":"2023-04-14T08:41:24Z","0.27.8":"2023-08-07T20:04:47Z","0.28.0":"2023-04-20T23:52:11Z","0.28.1":"2023-04-20T23:52:11Z","0.28.2":"2023-04-21T14:59:44Z","0.28.3":"2023-04-21T23:45:05Z","0.28.4":"2023-04-22T02:53:57Z","0.28.5":"2023-04-23T05:49:40Z","0.28.6":"2023-04-25T11:48:37Z","0.28.7":"2023-04-27T08:50:37Z","0.28.8":"2023-04-28T11:39:50Z","0.28.9":"2023-05-01T14:40:55Z","0.28.10":"2023-05-13T17:49:08Z","0.28.11":"2023-05-17T05:46:25Z","0.28.12":"2023-05-25T05:57:45Z","0.28.13":"2023-05-26T05:56:27Z","0.28.14":"2023-05-29T20:48:57Z","0.28.15":"2023-06-10T09:01:43Z","0.28.16":"2023-06-20T08:48:11Z","0.28.17":"2023-06-21T17:57:45Z","0.28.18":"2023-06-22T05:48:39Z","0.28.19":"2023-06-26T20:53:12Z","0.28.20":"2023-06-27T08:48:20Z","0.29.0":"2023-07-02T14:48:16Z","0.29.1":"2023-07-02T20:48:54Z","0.29.2":"2023-07-03T23:54:39Z","0.29.3":"2023-07-03T23:54:39Z","0.29.4":"2023-07-06T02:54:04Z","0.29.5":"2023-07-18T17:52:02Z","0.29.6":"2023-07-18T17:52:02Z","0.30.0-dev-1":"2023-07-28T17:46:16Z","0.30.0-dev-2":"2023-07-28T17:46:16Z","0.30.0-dev-3":"2023-07-28T20:50:21Z","0.30.0-dev-4":"2023-07-28T20:50:21Z","0.30.0-dev-5":"2023-07-31T08:44:45Z","0.30.0-dev-6":"2023-07-31T08:44:45Z","0.30.0-dev-7":"2023-07-31T14:58:48Z","0.30.0":"2023-08-01T08:50:22Z","0.30.1":"2023-08-02T11:51:27Z","0.30.2":"2023-08-02T11:51:27Z","0.30.3":"2023-08-05T08:49:46Z","0.30.4":"2023-08-05T14:45:30Z","0.31.0-dev-1":"2023-08-08T23:57:03Z","0.31.0-dev-2":"2023-08-08T23:57:03Z","0.31.0":"2023-08-11T23:46:50Z","0.31.1":"2023-08-14T05:44:56Z","0.31.2":"2023-08-22T20:44:45Z","0.31.3":"2023-08-25T08:49:18Z","0.31.4":"2023-08-26T08:42:20Z","0.31.5":"2023-08-27T08:59:38Z","0.31.6":"2023-08-29T11:53:58Z","0.31.7":"2023-08-29T20:41:59Z","0.31.8":"2023-08-30T20:53:08Z","0.31.9":"2023-09-03T17:48:25Z","0.31.10":"2023-09-04T20:49:04Z","0.31.11":"2023-09-05T17:50:35Z","0.31.12":"2023-09-05T17:50:35Z","0.31.13":"2023-09-05T20:44:48Z","0.31.14":"2023-09-05T20:44:48Z","0.31.15":"2023-09-14T08:45:05Z","0.31.16":"2023-09-25T08:57:55Z","0.31.17":"2023-09-26T08:47:14Z","0.31.18":"2023-10-17T17:59:32Z","0.31.19":"2023-10-25T23:44:13Z","0.31.20":"2023-10-26T14:53:35Z","0.31.21":"2023-10-29T14:55:57Z","0.31.22":"2023-11-02T20:51:14Z","0.31.23":"2023-11-07T20:49:40Z","0.31.24":"2023-11-15T11:51:25Z","0.31.25":"2023-11-15T17:50:19Z","0.31.26":"2023-11-18T14:46:16Z","0.31.27":"2023-11-19T23:42:59Z","0.31.28":"2023-11-20T17:42:18Z","0.32.0-dev-1":"2023-11-30T14:47:29Z","0.32.0-dev-10":"2023-12-02T14:40:54Z","0.32.0-dev-11":"2023-12-02T17:54:09Z","0.32.0-dev-12":"2023-12-03T20:49:56Z","0.32.0-dev-13":"2023-12-04T11:55:05Z","0.32.0-dev-14":"2023-12-05T17:51:36Z","0.32.0-dev-15":"2023-12-06T17:54:03Z","0.32.0-dev-16":"2023-12-07T11:41:24Z","0.32.0-dev-17":"2023-12-07T11:41:24Z","0.32.0-dev-18":"2023-12-08T11:46:29Z","0.32.0-dev-19":"2023-12-08T14:50:01Z","0.32.0-dev-2":"2023-11-30T17:57:46Z","0.32.0-dev-20":"2023-12-08T20:44:37Z","0.32.0-dev-21":"2023-12-10T08:47:48Z","0.32.0-dev-22":"2023-12-10T17:40:46Z","0.32.0-dev-23":"2023-12-10T17:40:46Z","0.32.0-dev-24":"2023-12-11T11:49:21Z","0.32.0-dev-25":"2023-12-12T08:55:06Z","0.32.0-dev-26":"2023-12-12T11:47:43Z","0.32.0-dev-27":"2023-12-13T02:47:03Z","0.32.0-dev-28":"2023-12-14T08:40:51Z","0.32.0-dev-3":"2023-11-30T17:57:46Z","0.32.0-dev-4":"2023-12-02T05:40:58Z","0.32.0-dev-5":"2023-12-02T08:50:50Z","0.32.0-dev-6":"2023-12-02T08:50:50Z","0.32.0-dev-7":"2023-12-02T11:50:21Z","0.32.0-dev-8":"2023-12-02T11:50:21Z","0.32.0-dev-9":"2023-12-02T14:40:54Z","0.32.0":"2023-12-22T08:51:56Z","0.32.1":"2023-12-23T08:41:36Z","0.32.2":"2023-12-24T17:51:11Z","0.32.3":"2023-12-24T20:45:21Z","0.32.4":"2023-12-29T08:48:01Z","0.32.5":"2024-01-05T08:47:56Z","0.32.6":"2024-01-10T08:47:48Z","0.32.7":"2024-01-10T14:43:15Z","0.32.8":"2024-01-10T17:44:23Z","0.32.9":"2024-01-12T20:47:17Z","0.32.10":"2024-01-17T20:42:49Z","0.32.11":"2024-01-20T23:54:37Z","0.32.12":"2024-01-21T11:45:06Z","0.32.13":"2024-01-26T02:56:27Z","0.32.14":"2024-02-11T08:42:25Z","0.32.15":"2024-03-01T11:45:15Z","0.32.16":"2024-03-19T20:40:35Z","0.32.17":"2024-03-20T14:54:47Z","0.32.18":"2024-03-21T11:49:50Z"}}
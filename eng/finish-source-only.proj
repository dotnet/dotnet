<Project Sdk="Microsoft.Build.NoTargets">

  <PropertyGroup>
    <TargetFramework>$(NetCurrent)</TargetFramework>

    <!-- Need to set to false to calculate RepositoryCommit. -->
    <EnableSourceControlManagerQueries>false</EnableSourceControlManagerQueries>

    <PackageReportDataFile>$(ArtifactsLogDir)prebuilt-usage.xml</PackageReportDataFile>
    <ProjectAssetsJsonArchiveFile>$(ArtifactsLogDir)all-project-assets-json-files.zip</ProjectAssetsJsonArchiveFile>

    <ResultingPrebuiltPackagesDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsLogDir)', 'prebuilt-packages'))</ResultingPrebuiltPackagesDir>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="$(TasksDir)Microsoft.DotNet.UnifiedBuild.Tasks\Microsoft.DotNet.UnifiedBuild.Tasks.csproj" />
    <ProjectReference Include="$(TasksDir)Microsoft.DotNet.SourceBuild.Tasks.LeakDetection\Microsoft.DotNet.SourceBuild.Tasks.LeakDetection.csproj" />
    <ProjectReference Include="$(RepositoryEngineeringDir)extract-sdk-archive.proj" />
    <ProjectReference Include="$(RepositoryEngineeringDir)merge-asset-manifests.proj" />
  </ItemGroup>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WritePackageUsageData" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="WritePrebuiltUsageData"
          BeforeTargets="Build"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)WritePrebuiltUsageData.complete">
    <ItemGroup>
      <!--
        Note the usage of */*/*.nupkg and not **/*.nupkg. The latter would include nupkgs
        carried as content, i.e. in Microsoft.FSharp.Compiler nupkg, and cause false positives.
        Content nupkgs were not restored and should not be used in prebuit detection.

        Example of a restored package:
        $(NuGetPackageRoot)microsoft.fsharp.compiler/12.8.300-beta.24203.1/microsoft.fsharp.compiler.12.8.300-beta.24203.1.nupkg

        Example of a content package:
        $(NuGetPackageRoot)microsoft.fsharp.compiler/12.8.300-beta.24203.1/contentFiles/Release/FSharp.Core.8.0.300.nupkg
      -->
      <RestoredPackageFile Include="$(NuGetPackageRoot)*/*/*.nupkg"
                           Exclude="$(NuGetPackageRoot)tests/**/*.nupkg" />

      <!-- Only contains packages when building. -->
      <TarballPrebuiltPackageFile Include="$(PrebuiltPackagesPath)*.nupkg" />

      <SourceBuiltPackageFile Include="$(ArtifactsPackagesDir)**/*.nupkg" />
      <SourceBuiltPackageFile Include="$(PreviouslySourceBuiltPackagesPath)*.nupkg" />
      <ReferencePackageFile Include="$(ReferencePackagesDir)**/*.nupkg" />

      <!-- Check all RIDs from all restored Microsoft.NETCore.Platforms packages. -->
      <PlatformsRuntimeJsonFile Include="$(NuGetPackageRoot)microsoft.netcore.platforms/*/PortableRuntimeIdentifierGraph.json" />
    </ItemGroup>

    <ItemGroup>
      <RepoProject Include="$(RepoProjectsDir)*.proj" />
      <RepoProjectDirectory Include="@(RepoProject->'$(SrcDir)%(Filename)')" />

      <!-- Add some other potential top-level project directories for a more specific report. -->
      <RepoProjectDirectory Include="$(SourceBuiltSdksDir);$(TasksDir);$(ArtifactsObjDir)" />
      <!-- Finally, scan entire source-build, in case project.assets.json ends up in an unexpected place. -->
      <RepoProjectDirectory Include="$(RepoRoot)" />
    </ItemGroup>

    <ItemGroup>
      <!-- This file is a resource tracked by Git, not generated by restore. Ignore false positive. -->
      <IgnoredProjectAssetsJsonFile Include="$(SrcDir)*nuget-client*/**/test/NuGet.Core.Tests/NuGet.Build.Tasks.Pack.Test/compiler/resources/project.assets.json"/>
    </ItemGroup>

    <WritePackageUsageData
      RestoredPackageFiles="@(RestoredPackageFile)"
      TarballPrebuiltPackageFiles="@(TarballPrebuiltPackageFile)"
      SourceBuiltPackageFiles="@(SourceBuiltPackageFile)"
      ReferencePackageFiles="@(ReferencePackageFile)"
      PlatformsRuntimeJsonFiles="@(PlatformsRuntimeJsonFile)"
      TargetRid="$(TargetRid)"
      ProjectDirectories="@(RepoProjectDirectory)"
      RootDir="$(RepoRoot)"
      IgnoredProjectAssetsJsonFiles="@(IgnoredProjectAssetsJsonFile)"
      DataFile="$(PackageReportDataFile)"
      ProjectAssetsJsonArchiveFile="$(ProjectAssetsJsonArchiveFile)" />

    <!-- Copy packages detected as prebuilts to the artifacts prebuilt folder -->
    <ItemGroup>
      <AllowedPackageFile Include="@(TarballPrebuiltPackageFile)" />
      <AllowedPackageFile Include="@(SourceBuiltPackageFile)" />
      <AllowedPackageFile Include="@(ReferencePackageFile)" />
      <AllowedPackageFile>
        <LCFilename>$([System.String]::Copy(%(Filename)).ToLowerInvariant())</LCFilename>
      </AllowedPackageFile>

      <PrebuiltPackageFile Include="@(RestoredPackageFile)" >
        <LCFilename>$([System.String]::Copy(%(Filename)).ToLowerInvariant())</LCFilename>
      </PrebuiltPackageFile>
      <PrebuiltPackageFile Remove="@(AllowedPackageFile)" MatchOnMetadata="LCFilename" />
    </ItemGroup>

    <Copy SourceFiles="@(PrebuiltPackageFile)" DestinationFolder="$(ResultingPrebuiltPackagesDir)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)WritePrebuiltUsageData.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <!-- After building, generate a prebuilt usage report.
       Also, dev scenario: rewrite a prebuilt-report. This makes it easy to add data to an existing
       prebuilt report without performing another full build. This doesn't reevalutate which packages
       are prebuilts or search the projects: it uses the existing usage.xml file to generate report
       XMLs based on the info put in artifacts/. -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WriteUsageReports" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.ValidateUsageAgainstBaseline" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="ReportPrebuiltUsage"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)ReportPrebuiltUsage.complete"
          DependsOnTargets="WritePrebuiltUsageData"
          BeforeTargets="Build">
    <PropertyGroup>
      <FailOnPrebuiltBaselineError Condition="'$(FailOnPrebuiltBaselineError)' == ''">false</FailOnPrebuiltBaselineError>
    </PropertyGroup>

    <ItemGroup>
      <PackageVersionPropsSavedSnapshotFile Include="$(PackageVersionsDir)PackageVersions.*.Snapshot.props" />
    </ItemGroup>
    <Copy SourceFiles="@(PackageVersionPropsSnapshotFiles)" DestinationFolder="$(ArtifactsLogDir)snapshots/" />

    <WriteUsageReports DataFile="$(PackageReportDataFile)"
                       PackageVersionPropsSnapshots="@(PackageVersionPropsSavedSnapshotFile)"
                       PoisonedReportFile="$(PoisonedReportFile)"
                       OutputDirectory="$(ArtifactsLogDir)" />

    <PropertyGroup Condition="'$(ContinueOnPrebuiltBaselineError)' == ''">
      <ContinueOnPrebuiltBaselineError>false</ContinueOnPrebuiltBaselineError>
      <ContinueOnPrebuiltBaselineError Condition="'$(FailOnPrebuiltBaselineError)' != 'true'">true</ContinueOnPrebuiltBaselineError>
    </PropertyGroup>

    <ValidateUsageAgainstBaseline
      DataFile="$(PackageReportDataFile)"
      BaselineDataFile="$(BaselineDataFile)"
      OutputBaselineFile="$(ArtifactsLogDir)generated-new-baseline.xml"
      OutputReportFile="$(ArtifactsLogDir)baseline-comparison.xml"
      AllowTestProjectUsage="$(AllowTestProjectUsage)"
      ContinueOnError="$(ContinueOnPrebuiltBaselineError)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)ReportPrebuiltUsage.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.WriteSBRPUsageReport" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="ReportSbrpUsage"
          BeforeTargets="Build"
          Condition="'$(ReportSbrpUsage)' == 'true'">
    <ItemGroup>
      <ProjectAssetsJsonFile Include="$(ArtifactsDir)**/project.assets.json" />
      <ProjectAssetsJsonFile Include="$(SrcDir)**/artifacts/**/project.assets.json" />
    </ItemGroup>

    <WriteSbrpUsageReport SbrpRepoSrcPath="$(SbrpRepoSrcDir)"
                          ProjectAssetsJsons="@(ProjectAssetsJsonFile)"
                          OutputPath="$(ArtifactsLogDir)" />
  </Target>

  <Target Name="DetermineSourceBuiltSdkNonStableVersion"
          DependsOnTargets="DetermineSourceBuiltSdkVersion">
    <ItemGroup>
      <SdkVersionFileItem Include="$(DotNetSdkExtractDir)/sdk/**/.version" />
    </ItemGroup>

    <PropertyGroup>
      <SourceBuiltSdkNonStableVersion>$([System.Text.RegularExpressions.Regex]::Split('$([System.IO.File]::ReadAllText('%(SdkVersionFileItem.Identity)'))', '\r\n|\r|\n')[3])</SourceBuiltSdkNonStableVersion>
    </PropertyGroup>
  </Target>

  <!--
    Determine symbols tarball names and discover all intermediate symbols,
    to be used as inputs and outputs of symbols repackaging targets.
  -->
  <Target Name="DetermineSymbolsTargetsInputsAndOutputs"
          AfterTargets="Build"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion">
    <PropertyGroup>
      <UnifiedSymbolsTarball>$(ArtifactsAssetsDir)dotnet-symbols-all-$(SourceBuiltSdkNonStableVersion)-$(TargetRid)$(ArchiveExtension)</UnifiedSymbolsTarball>
      <SdkSymbolsTarball>$(ArtifactsAssetsDir)dotnet-symbols-sdk-$(SourceBuiltSdkNonStableVersion)-$(TargetRid)$(ArchiveExtension)</SdkSymbolsTarball>
    </PropertyGroup>
    <ItemGroup>
      <IntermediateSymbol Include="$(IntermediateSymbolsRootDir)**/*" />
    </ItemGroup>
  </Target>

  <!-- After building, repackage symbols into a single tarball. -->
  <Target Name="RepackageSymbols"
          BeforeTargets="Build"
          DependsOnTargets="DetermineSymbolsTargetsInputsAndOutputs"
          Inputs="@(IntermediateSymbol)"
          Outputs="$(UnifiedSymbolsTarball)">

    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(UnifiedSymbolsTarball)'))" />
    <Exec Command="tar --numeric-owner -czf $(UnifiedSymbolsTarball) *"
          WorkingDirectory="$(IntermediateSymbolsRootDir)" />

    <!-- Mark the artifact so that it gets binplaced. -->
    <ItemGroup>
      <BinPlaceFile Include="$(UnifiedSymbolsTarball)" />
    </ItemGroup>

    <Message Importance="High" Text="Packaged all symbols in '$(UnifiedSymbolsTarball)'" />
  </Target>

  <!-- After building, create the sdk symbols tarball. -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.CreateSdkSymbolsLayout" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="CreateSdkSymbolsTarball"
          BeforeTargets="Build"
          DependsOnTargets="RepackageSymbols"
          Inputs="@(IntermediateSymbol);$(SdkTarballPath)"
          Outputs="$(SdkSymbolsTarball)">
    <PropertyGroup>
      <IntermediateSdkSymbolsLayout>$(BaseIntermediateOutputPath)SdkSymbols</IntermediateSdkSymbolsLayout>
    </PropertyGroup>

    <CreateSdkSymbolsLayout SdkLayoutPath="$(DotNetSdkExtractDir)"
                            AllSymbolsPath="$(IntermediateSymbolsRootDir)"
                            SdkSymbolsLayoutPath="$(IntermediateSdkSymbolsLayout)"
                            FailOnMissingPDBs="false" />

    <Exec Command="tar --numeric-owner -czf $(SdkSymbolsTarball) *"
          WorkingDirectory="$(IntermediateSdkSymbolsLayout)" />

    <!-- Mark the artifact so that it gets binplaced. -->
    <ItemGroup>
      <BinPlaceFile Include="$(SdkSymbolsTarball)" />
    </ItemGroup>

    <Message Importance="High" Text="Packaged sdk symbols in '$(SdkSymbolsTarball)'" />

    <RemoveDir Directories="$(IntermediateSdkSymbolsLayout)" />
  </Target>

  <UsingTask TaskName="Microsoft.DotNet.SourceBuild.Tasks.LeakDetection.CheckForPoison" AssemblyFile="$(MicrosoftDotNetSourceBuildTasksLeakDetectionAssembly)" TaskFactory="TaskHostFactory" Condition="'$(EnablePoison)' == 'true'" />
  <Target Name="ReportPoisonUsage"
          BeforeTargets="Build"
          DependsOnTargets="CopySdkArchive"
          Condition="'$(EnablePoison)' == 'true'"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)ReportPoisonUsage.complete" >
    <ItemGroup>
      <!-- Include dotnet-sdk-*.tar.gz -->
      <SdkArchive Include="$(ArtifactsAssetsDir)dotnet-sdk-*$(ArchiveExtension)" />
      <!-- Include shipping nuget packages. -->
      <ShippingPackageToCheck Include="$(ArtifactsShippingPackagesDir)**/*.nupkg" />
      <!-- Add and mark SBRP packages to validate that they have the correct poison attribute. -->
      <SbrpPackageToCheck Include="$(ReferencePackagesDir)**\*.nupkg" IsSourceBuildReferencePackage="true" />
    </ItemGroup>

    <Error Condition="'@(SdkArchive)' == ''" Text="SDK will not be poison checked - this is unexpected!" />
    <Error Condition="'@(ShippingPackageToCheck)' == ''" Text="No shipping packages will be poison checked - this is unexpected!" />
    <Error Condition="'@(SbrpPackageToCheck)' == ''" Text="No SBRP packages will be poison checked - this is unexpected!" />

    <ItemGroup>
      <PoisonFileToCheck Include="@(SdkArchive)" />
      <PoisonFileToCheck Include="@(ShippingPackageToCheck)" />
      <PoisonFileToCheck Include="@(SbrpPackageToCheck)" />
    </ItemGroup>

    <Message Importance="High" Text="[$([System.DateTime]::Now.ToString('HH:mm:ss.ff'))] Checking @(PoisonFileToCheck) for poisoned files." />

    <CheckForPoison FilesToCheck="@(PoisonFileToCheck)"
                    ProjectDirPath="$(RepoRoot)"
                    HashCatalogFilePath="$(PoisonReportDataFile)"
                    MarkerFileName="$(PoisonMarkerFile)"
                    PoisonReportOutputFilePath="$(PoisonUsageReportFile)" />

    <Message Importance="High" Text="[$([System.DateTime]::Now.ToString('HH:mm:ss.ff'))] Done checking for poison." />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)ReportPoisonUsage.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WriteUsageBurndownData" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="GeneratePrebuiltBurndownData"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)GeneratePrebuiltBurndownData.complete" >
    <PropertyGroup>
      <PrebuiltBurndownDataFile>$(ArtifactsLogDir)PrebuiltBurndownData.csv</PrebuiltBurndownDataFile>
    </PropertyGroup>

    <WriteUsageBurndownData RootDirectory="$(RepoRoot)"
                            PrebuiltBaselineFile="$(BaselineDataFile)"
                            OutputFilePath="$(PrebuiltBurndownDataFile)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)GeneratePrebuiltBurndownData.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <Target Name="CreatePrebuiltsTarball"
          BeforeTargets="Build"
          DependsOnTargets="
            CheckIfPrebuiltsExistToPack;
            CreatePrebuiltsTarballIfPrebuiltsExist"/>

  <Target Name="CheckIfPrebuiltsExistToPack">
    <!-- Directory existence doesn't mean there are files inside. Use a pattern to find files. -->
    <ItemGroup>
      <PrebuiltFile Include="$(ResultingPrebuiltPackagesDir)**" />
    </ItemGroup>

    <Message Text="Found @(PrebuiltFile->Count()) files in prebuilt packages dir." Importance="High" />
  </Target>

  <Target Name="CreatePrebuiltsTarballIfPrebuiltsExist"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion"
          Condition="'@(PrebuiltFile)' != ''">
    <PropertyGroup>
      <PrebuiltsTarball>$(ArtifactsAssetsDir)$(SourceBuiltPrebuiltsTarballName).$(SourceBuiltSdkNonStableVersion).$(TargetRid)$(ArchiveExtension)</PrebuiltsTarball>
      <PrebuiltsTarballWorkingDir>$(ResultingPrebuiltPackagesDir)</PrebuiltsTarballWorkingDir>
    </PropertyGroup>

    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(PrebuiltsTarball)'))" />
    <Exec Command="tar --numeric-owner -zcf $(PrebuiltsTarball) -C $(PrebuiltsTarballWorkingDir) ." />

    <!-- Mark the artifact so that it gets binplaced. -->
    <ItemGroup>
      <BinPlaceFile Include="$(PrebuiltsTarball)" />
    </ItemGroup>

    <Message Text="Tarball '$(PrebuiltsTarball)' was successfully created from '$(PrebuiltsTarballWorkingDir)'" Importance="High" />
  </Target>

  <Target Name="ErrorOnPrebuilts"
          DependsOnTargets="CreatePrebuiltsTarball"
          AfterTargets="BinPlaceFiles;Build"
          Condition="'@(PrebuiltFile)' != '' and '$(SkipErrorOnPrebuilts)' != 'true'">
    <Error Text="@(PrebuiltFile->Count()) Prebuilts Exist" />
  </Target>

  <Target Name="GetInputsOutputForCreatePrivateSourceBuiltArtifactsArchive"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion;ResolveProjectReferences">
    <!-- Inputs: Packages to include in the tarball -->
    <ItemGroup>
      <ArtifactsPackageToBundle Include="$(ArtifactsShippingPackagesDir)**;
                                          $(ArtifactsNonShippingPackagesDir)**" />
      <ArtifactsPackageToBundle Remove="@(ArtifactsPackageToBundle)"
                                Condition="$([System.String]::Copy('%(Identity)').EndsWith('.symbols.nupkg'))" />
      <ReferencePackageToBundle Include="$(ReferencePackagesDir)**" />
      <ReferencePackageToBundle Remove="@(ReferencePackageToBundle)"
                                Condition="$([System.String]::Copy('%(Identity)').EndsWith('.symbols.nupkg'))" />
      <MergedAssetManifest Include="$(MergedAssetManifestOutputPath)" />
    </ItemGroup>

    <PropertyGroup>
      <!-- Create a layout directory for the files that are to be included in the artifacts tarball. -->
      <SourceBuiltLayoutDir>$([MSBuild]::NormalizeDirectory('$(BaseIntermediateOutputPath)', 'artifacts-layout'))</SourceBuiltLayoutDir>

      <!-- Outputs -->
      <SourceBuiltTarballName>$(ArtifactsAssetsDir)$(SourceBuiltArtifactsTarballName).$(SourceBuiltSdkNonStableVersion).$(TargetRid)$(ArchiveExtension)</SourceBuiltTarballName>
      <SourceBuiltVersionName>$(SourceBuiltLayoutDir).version</SourceBuiltVersionName>
      <AllPackageVersionsPropsName>$(SourceBuiltLayoutDir)PackageVersions.props</AllPackageVersionsPropsName>
      <SourceBuiltMergedAssetManifestName>$(SourceBuiltLayoutDir)%(MergedAssetManifest.Filename)%(MergedAssetManifest.Extension)</SourceBuiltMergedAssetManifestName>
    </PropertyGroup>
  </Target>

  <!-- Discover the produced packages from the merged asset manifest -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.GetKnownArtifactsFromAssetManifests" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="GetProducedPackages" Returns="@(ProducedPackage)">
    <GetKnownArtifactsFromAssetManifests AssetManifests="$(MergedAssetManifestOutputPath)">
      <Output TaskParameter="KnownPackages" ItemName="ProducedPackage" />
    </GetKnownArtifactsFromAssetManifests>
  </Target>

  <!-- Create the SourceBuilt.Private.Artifacts archive when building source-only. -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.WritePackageVersionsProps" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="CreatePrivateSourceBuiltArtifactsArchive"
          BeforeTargets="Build"
          DependsOnTargets="GetInputsOutputForCreatePrivateSourceBuiltArtifactsArchive;GetProducedPackages"
          Inputs="@(ArtifactsPackageToBundle);@(ReferencePackageToBundle);@(MergedAssetManifest)"
          Outputs="$(SourceBuiltTarballName);$(SourceBuiltVersionName);$(AllPackageVersionsPropsName);$(SourceBuiltMergedAssetManifestName)">
    <!-- Copy packages to layout directory. Since there are a large number of files,
          this will use symlinks instead of copying files to make this execute quickly. -->
    <Copy SourceFiles="@(ArtifactsPackageToBundle)"
          DestinationFolder="$(SourceBuiltLayoutDir)"
          UseSymbolicLinksIfPossible="true" />
    <Copy SourceFiles="@(ReferencePackageToBundle)"
          DestinationFolder="$(SourceBuiltLayoutDir)$(PreviouslySourceBuiltReferencePackagesDirName)"
          UseSymbolicLinksIfPossible="true" />

    <!-- Content of the .version file to include in the tarball -->
    <ItemGroup>
      <VersionFileContent Include="$(RepositoryCommit);$(SourceBuiltSdkNonStableVersion)" />
    </ItemGroup>

    <WriteLinesToFile File="$(SourceBuiltVersionName)"
                      Lines="@(VersionFileContent)"
                      Overwrite="true" />

    <!-- Copy the merged asset manifest into the tarball -->
    <Copy SourceFiles="@(MergedAssetManifest)"
          DestinationFolder="$(SourceBuiltLayoutDir)"
          UseSymbolicLinksIfPossible="true" />

    <!-- Create a PackageVersions.props file that includes entries for all packages. -->
    <WritePackageVersionsProps KnownPackages="@(ProducedPackage)"
                               ExtraProperties="@(ExtraPackageVersionPropsPackageInfo)"
                               VersionPropsFlowType="AllPackages"
                               OutputPath="$(AllPackageVersionsPropsName)" />

    <Exec Command="tar --numeric-owner -czhf $(SourceBuiltTarballName) $([System.IO.Path]::GetFileName('$(SourceBuiltVersionName)')) *"
          WorkingDirectory="$(SourceBuiltLayoutDir)" />

    <!-- Mark the artifact so that it gets binplaced. -->
    <ItemGroup>
      <BinPlaceFile Include="$(SourceBuiltTarballName)" />
    </ItemGroup>

    <Message Importance="High" Text="Packaged source-built artifacts to $(SourceBuiltTarballName)" />
  </Target>

    <!-- Copy SDK archive to assets root as source-only build partners expect the file to be there. -->
  <Target Name="CopySdkArchive"
          BeforeTargets="Build"
          DependsOnTargets="DetermineSourceBuiltSdkVersion">
    <Copy SourceFiles="$(SdkTarballPath)"
          DestinationFolder="$(ArtifactsAssetsDir)"
          SkipUnchangedFiles="true"
          UseHardlinksIfPossible="true" />
    
    <!-- Mark the artifact so that it gets binplaced. -->
    <ItemGroup>
      <BinPlaceFile Include="$(ArtifactsAssetsDir)$([System.IO.Path]::GetFileName('$(SdkTarballPath)'))" />
    </ItemGroup>
  </Target>

</Project>

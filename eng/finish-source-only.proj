<Project Sdk="Microsoft.Build.NoTargets">

  <PropertyGroup>
    <TargetFramework>$(NetCurrent)</TargetFramework>

    <!-- Need to set to false to calculate RepositoryCommit. -->
    <EnableSourceControlManagerQueries>false</EnableSourceControlManagerQueries>

    <PackageReportDataFile>$(ArtifactsLogDir)prebuilt-usage.xml</PackageReportDataFile>
    <ProjectAssetsJsonArchiveFile>$(ArtifactsLogDir)all-project-assets-json-files.zip</ProjectAssetsJsonArchiveFile>

    <ResultingPrebuiltPackagesDir>$([MSBuild]::NormalizeDirectory('$(ArtifactsLogDir)', 'prebuilt-packages'))</ResultingPrebuiltPackagesDir>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="$(TasksDir)Microsoft.DotNet.UnifiedBuild.Tasks\Microsoft.DotNet.UnifiedBuild.Tasks.csproj" />
    <ProjectReference Include="$(TasksDir)Microsoft.DotNet.SourceBuild.Tasks.LeakDetection\Microsoft.DotNet.SourceBuild.Tasks.LeakDetection.csproj" />
    <ProjectReference Include="$(RepositoryEngineeringDir)extract-sdk-archive.proj" />
  </ItemGroup>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WritePackageUsageData" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="WritePrebuiltUsageData"
          BeforeTargets="Build"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)WritePrebuiltUsageData.complete">
    <ItemGroup>
      <!--
        Note the usage of */*/*.nupkg and not **/*.nupkg. The latter would include nupkgs
        carried as content, i.e. in Microsoft.FSharp.Compiler nupkg, and cause false positives.
        Content nupkgs were not restored and should not be used in prebuit detection.

        Example of a restored package:
        $(NuGetPackageRoot)microsoft.fsharp.compiler/12.8.300-beta.24203.1/microsoft.fsharp.compiler.12.8.300-beta.24203.1.nupkg

        Example of a content package:
        $(NuGetPackageRoot)microsoft.fsharp.compiler/12.8.300-beta.24203.1/contentFiles/Release/FSharp.Core.8.0.300.nupkg
      -->
      <RestoredPackageFile Include="$(NuGetPackageRoot)*/*/*.nupkg"
                           Exclude="$(NuGetPackageRoot)tests/**/*.nupkg" />

      <!-- Only contains packages when building. -->
      <TarballPrebuiltPackageFile Include="$(PrebuiltPackagesPath)*.nupkg" />

      <SourceBuiltPackageFile Include="$(ArtifactsPackagesDir)**/*.nupkg" />
      <SourceBuiltPackageFile Include="$(PreviouslySourceBuiltPackagesPath)*.nupkg" />
      <ReferencePackageFile Include="$(ReferencePackagesDir)**/*.nupkg" />

      <!-- Check all RIDs from all restored Microsoft.NETCore.Platforms packages. -->
      <PlatformsRuntimeJsonFile Include="$(NuGetPackageRoot)microsoft.netcore.platforms/*/PortableRuntimeIdentifierGraph.json" />
    </ItemGroup>

    <ItemGroup>
      <RepoProject Include="$(RepoProjectsDir)*.proj" />
      <RepoProjectDirectory Include="@(RepoProject->'$(SrcDir)%(Filename)')" />

      <!-- Add some other potential top-level project directories for a more specific report. -->
      <RepoProjectDirectory Include="$(SourceBuiltSdksDir);$(TasksDir);$(ArtifactsObjDir)" />
      <!-- Finally, scan entire source-build, in case project.assets.json ends up in an unexpected place. -->
      <RepoProjectDirectory Include="$(RepoRoot)" />
    </ItemGroup>

    <ItemGroup>
      <!-- This file is a resource tracked by Git, not generated by restore. Ignore false positive. -->
      <IgnoredProjectAssetsJsonFile Include="$(SrcDir)*nuget-client*/**/test/NuGet.Core.Tests/NuGet.Build.Tasks.Pack.Test/compiler/resources/project.assets.json"/>
    </ItemGroup>

    <WritePackageUsageData
      RestoredPackageFiles="@(RestoredPackageFile)"
      TarballPrebuiltPackageFiles="@(TarballPrebuiltPackageFile)"
      SourceBuiltPackageFiles="@(SourceBuiltPackageFile)"
      ReferencePackageFiles="@(ReferencePackageFile)"
      PlatformsRuntimeJsonFiles="@(PlatformsRuntimeJsonFile)"
      TargetRid="$(TargetRid)"
      ProjectDirectories="@(RepoProjectDirectory)"
      RootDir="$(RepoRoot)"
      IgnoredProjectAssetsJsonFiles="@(IgnoredProjectAssetsJsonFile)"
      DataFile="$(PackageReportDataFile)"
      ProjectAssetsJsonArchiveFile="$(ProjectAssetsJsonArchiveFile)" />

    <!-- Copy packages detected as prebuilts to the artifacts prebuilt folder -->
    <ItemGroup>
      <AllowedPackageFile Include="@(TarballPrebuiltPackageFile)" />
      <AllowedPackageFile Include="@(SourceBuiltPackageFile)" />
      <AllowedPackageFile Include="@(ReferencePackageFile)" />
      <AllowedPackageFile>
        <LCFilename>$([System.String]::Copy(%(Filename)).ToLowerInvariant())</LCFilename>
      </AllowedPackageFile>

      <PrebuiltPackageFile Include="@(RestoredPackageFile)" >
        <LCFilename>$([System.String]::Copy(%(Filename)).ToLowerInvariant())</LCFilename>
      </PrebuiltPackageFile>
      <PrebuiltPackageFile Remove="@(AllowedPackageFile)" MatchOnMetadata="LCFilename" />
    </ItemGroup>

    <Copy SourceFiles="@(PrebuiltPackageFile)" DestinationFolder="$(ResultingPrebuiltPackagesDir)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)WritePrebuiltUsageData.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <!-- After building, generate a prebuilt usage report.
       Also, dev scenario: rewrite a prebuilt-report. This makes it easy to add data to an existing
       prebuilt report without performing another full build. This doesn't reevalutate which packages
       are prebuilts or search the projects: it uses the existing usage.xml file to generate report
       XMLs based on the info put in artifacts/. -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WriteUsageReports" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.ValidateUsageAgainstBaseline" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="ReportPrebuiltUsage"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)ReportPrebuiltUsage.complete"
          DependsOnTargets="WritePrebuiltUsageData"
          BeforeTargets="Build">
    <PropertyGroup>
      <FailOnPrebuiltBaselineError Condition="'$(FailOnPrebuiltBaselineError)' == ''">false</FailOnPrebuiltBaselineError>
    </PropertyGroup>

    <ItemGroup>
      <PackageVersionPropsSavedSnapshotFile Include="$(PackageVersionsDir)PackageVersions.*.Snapshot.props" />
    </ItemGroup>
    <Copy SourceFiles="@(PackageVersionPropsSnapshotFiles)" DestinationFolder="$(ArtifactsLogDir)snapshots/" />

    <WriteUsageReports DataFile="$(PackageReportDataFile)"
                       PackageVersionPropsSnapshots="@(PackageVersionPropsSavedSnapshotFile)"
                       PoisonedReportFile="$(PoisonedReportFile)"
                       OutputDirectory="$(ArtifactsLogDir)" />

    <PropertyGroup Condition="'$(ContinueOnPrebuiltBaselineError)' == ''">
      <ContinueOnPrebuiltBaselineError>false</ContinueOnPrebuiltBaselineError>
      <ContinueOnPrebuiltBaselineError Condition="'$(FailOnPrebuiltBaselineError)' != 'true'">true</ContinueOnPrebuiltBaselineError>
    </PropertyGroup>

    <ValidateUsageAgainstBaseline
      DataFile="$(PackageReportDataFile)"
      BaselineDataFile="$(BaselineDataFile)"
      OutputBaselineFile="$(ArtifactsLogDir)generated-new-baseline.xml"
      OutputReportFile="$(ArtifactsLogDir)baseline-comparison.xml"
      AllowTestProjectUsage="$(AllowTestProjectUsage)"
      ContinueOnError="$(ContinueOnPrebuiltBaselineError)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)ReportPrebuiltUsage.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.WriteSBRPUsageReport" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="ReportSbrpUsage"
          BeforeTargets="Build"
          Condition="'$(ReportSbrpUsage)' == 'true'">
    <ItemGroup>
      <ProjectAssetsJsonFile Include="$(ArtifactsDir)**/project.assets.json" />
      <ProjectAssetsJsonFile Include="$(SrcDir)**/artifacts/**/project.assets.json" />
    </ItemGroup>

    <WriteSbrpUsageReport SbrpRepoSrcPath="$(SbrpRepoSrcDir)"
                          ProjectAssetsJsons="@(ProjectAssetsJsonFile)"
                          OutputPath="$(ArtifactsLogDir)" />
  </Target>

  <Target Name="DetermineSourceBuiltSdkNonStableVersion"
          DependsOnTargets="DetermineSourceBuiltSdkVersion">
    <ItemGroup>
      <SdkVersionFileItem Include="$(DotNetSdkExtractDir)/sdk/**/.version" />
    </ItemGroup>

    <PropertyGroup>
      <SourceBuiltSdkNonStableVersion>$([System.Text.RegularExpressions.Regex]::Split('$([System.IO.File]::ReadAllText('%(SdkVersionFileItem.Identity)'))', '\r\n|\r|\n')[3])</SourceBuiltSdkNonStableVersion>
    </PropertyGroup>
  </Target>

  <!-- Write out the .version file to be bundled into the source-build tarball -->
  <Target Name="WriteSourceBuiltSdkVersionFile"
          AfterTargets="Build"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion">
    <!-- Content of the .version file to include in the tarball -->
    <ItemGroup>
      <VersionFileContent Include="$(RepositoryCommit);$(SourceBuiltSdkNonStableVersion)" />
    </ItemGroup>

    <WriteLinesToFile File="$(ArtifactsAssetsDir).version"
                      Lines="@(VersionFileContent)" />
  </Target>

  <!--
    Determine symbols tarball names and discover all intermediate symbols,
    to be used as inputs and outputs of symbols repackaging targets.
  -->
  <Target Name="DetermineSymbolsTargetsInputsAndOutputs"
          AfterTargets="Build"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion">
    <PropertyGroup>
      <UnifiedSymbolsTarball>$(ArtifactsAssetsDir)dotnet-symbols-all-$(SourceBuiltSdkNonStableVersion)-$(TargetRid)$(ArchiveExtension)</UnifiedSymbolsTarball>
      <SdkSymbolsTarball>$(ArtifactsAssetsDir)dotnet-symbols-sdk-$(SourceBuiltSdkNonStableVersion)-$(TargetRid)$(ArchiveExtension)</SdkSymbolsTarball>
    </PropertyGroup>
    <ItemGroup>
      <IntermediateSymbol Include="$(IntermediateSymbolsRootDir)**/*" />
    </ItemGroup>
  </Target>

  <!-- After building, repackage symbols into a single tarball. -->
  <Target Name="RepackageSymbols"
          BeforeTargets="Build"
          DependsOnTargets="DetermineSymbolsTargetsInputsAndOutputs"
          Inputs="@(IntermediateSymbol)"
          Outputs="$(UnifiedSymbolsTarball)">

    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(UnifiedSymbolsTarball)'))" />
    <Exec Command="tar --numeric-owner -czf $(UnifiedSymbolsTarball) *"
          WorkingDirectory="$(IntermediateSymbolsRootDir)" />

    <Message Importance="High" Text="Packaged all symbols in '$(UnifiedSymbolsTarball)'" />
  </Target>

  <!-- After building, create the sdk symbols tarball. -->
  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.CreateSdkSymbolsLayout" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="CreateSdkSymbolsTarball"
          BeforeTargets="Build"
          DependsOnTargets="RepackageSymbols"
          Inputs="@(IntermediateSymbol);$(SdkTarballPath)"
          Outputs="$(SdkSymbolsTarball)">
    <PropertyGroup>
      <IntermediateSdkSymbolsLayout>$(BaseIntermediateOutputPath)SdkSymbols</IntermediateSdkSymbolsLayout>
    </PropertyGroup>

    <CreateSdkSymbolsLayout SdkLayoutPath="$(DotNetSdkExtractDir)"
                            AllSymbolsPath="$(IntermediateSymbolsRootDir)"
                            SdkSymbolsLayoutPath="$(IntermediateSdkSymbolsLayout)"
                            FailOnMissingPDBs="false" />

    <Exec Command="tar --numeric-owner -czf $(SdkSymbolsTarball) *"
          WorkingDirectory="$(IntermediateSdkSymbolsLayout)" />

    <Message Importance="High" Text="Packaged sdk symbols in '$(SdkSymbolsTarball)'" />

    <RemoveDir Directories="$(IntermediateSdkSymbolsLayout)" />
  </Target>

  <UsingTask TaskName="Microsoft.DotNet.UnifiedBuild.Tasks.UsageReport.WriteUsageBurndownData" AssemblyFile="$(MicrosoftDotNetUnifiedBuildTasksAssembly)" TaskFactory="TaskHostFactory" />
  <Target Name="GeneratePrebuiltBurndownData"
          Inputs="$(MSBuildProjectFullPath)"
          Outputs="$(BaseIntermediateOutputPath)GeneratePrebuiltBurndownData.complete" >
    <PropertyGroup>
      <PrebuiltBurndownDataFile>$(ArtifactsLogDir)PrebuiltBurndownData.csv</PrebuiltBurndownDataFile>
    </PropertyGroup>

    <WriteUsageBurndownData RootDirectory="$(RepoRoot)"
                            PrebuiltBaselineFile="$(BaselineDataFile)"
                            OutputFilePath="$(PrebuiltBurndownDataFile)" />

    <MakeDir Directories="$(BaseIntermediateOutputPath)" />
    <Touch Files="$(BaseIntermediateOutputPath)GeneratePrebuiltBurndownData.complete" AlwaysCreate="true">
      <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
    </Touch>
  </Target>

  <Target Name="CreatePrebuiltsTarball"
          BeforeTargets="Build"
          DependsOnTargets="
            CheckIfPrebuiltsExistToPack;
            CreatePrebuiltsTarballIfPrebuiltsExist"/>

  <Target Name="CheckIfPrebuiltsExistToPack">
    <!-- Directory existence doesn't mean there are files inside. Use a pattern to find files. -->
    <ItemGroup>
      <PrebuiltFile Include="$(ResultingPrebuiltPackagesDir)**" />
    </ItemGroup>

    <Message Text="Found @(PrebuiltFile->Count()) files in prebuilt packages dir." Importance="High" />
  </Target>

  <Target Name="CreatePrebuiltsTarballIfPrebuiltsExist"
          DependsOnTargets="DetermineSourceBuiltSdkNonStableVersion"
          Condition="'@(PrebuiltFile)' != ''">
    <PropertyGroup>
      <PrebuiltsTarball>$(ArtifactsAssetsDir)$(SourceBuiltPrebuiltsTarballName).$(SourceBuiltSdkNonStableVersion).$(TargetRid)$(ArchiveExtension)</PrebuiltsTarball>
      <PrebuiltsTarballWorkingDir>$(ResultingPrebuiltPackagesDir)</PrebuiltsTarballWorkingDir>
    </PropertyGroup>

    <MakeDir Directories="$([System.IO.Path]::GetDirectoryName('$(PrebuiltsTarball)'))" />
    <Exec Command="tar --numeric-owner -zcf $(PrebuiltsTarball) -C $(PrebuiltsTarballWorkingDir) ." />

    <Message Text="Tarball '$(PrebuiltsTarball)' was successfully created from '$(PrebuiltsTarballWorkingDir)'" Importance="High" />

    <Error Text="@(PrebuiltFile->Count()) Prebuilts Exist" Condition="'$(SkipErrorOnPrebuilts)' != 'true'" />
  </Target>
</Project>